<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>进程和线程 | 今晚你会梦到电子羊吗</title><meta name="keywords" content="进程,线程"><meta name="author" content="sakura,2294014200@qq.com"><meta name="copyright" content="sakura"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程和线程一个程序至少一个进程,一个进程至少一个线程.线程不能单独运行,它一定是运行在进程的内部的. Java程序的启动 启动java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言] 开启一个JVM进程 - jvm.exe[windows中的可执行文件,C语言写的程序字节编译成了.exe可执行文件]  当JVM进程启动之后,同时开启两个线程 - 分别是main主线程以">
<meta property="og:type" content="article">
<meta property="og:title" content="进程和线程">
<meta property="og:url" content="http://beautifulboyy/2021/08/09/java13/index.html">
<meta property="og:site_name" content="今晚你会梦到电子羊吗">
<meta property="og:description" content="进程和线程一个程序至少一个进程,一个进程至少一个线程.线程不能单独运行,它一定是运行在进程的内部的. Java程序的启动 启动java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言] 开启一个JVM进程 - jvm.exe[windows中的可执行文件,C语言写的程序字节编译成了.exe可执行文件]  当JVM进程启动之后,同时开启两个线程 - 分别是main主线程以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://beautifulboyy/img/wlop012.jpg">
<meta property="article:published_time" content="2021-08-09T10:17:57.000Z">
<meta property="article:modified_time" content="2021-08-15T12:23:38.511Z">
<meta property="article:author" content="sakura">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://beautifulboyy/img/wlop012.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://beautifulboyy/2021/08/09/java13/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: sakura","link":"链接: ","source":"来源: 今晚你会梦到电子羊吗","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程和线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-15 20:23:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/wlop012.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">今晚你会梦到电子羊吗</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程和线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-09T10:17:57.000Z" title="发表于 2021-08-09 18:17:57">2021-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-15T12:23:38.511Z" title="更新于 2021-08-15 20:23:38">2021-08-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进程和线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p><strong>一个程序至少一个进程,一个进程至少一个线程</strong>.线程不能单独运行,它一定是运行在进程的内部的.</p>
<h2 id="Java程序的启动"><a href="#Java程序的启动" class="headerlink" title="Java程序的启动"></a>Java程序的启动</h2><ol>
<li><p>启动java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言]</p>
<p>开启一个JVM进程 - jvm.exe[windows中的可执行文件,C语言写的程序字节编译成了.exe可执行文件]</p>
</li>
<li><p>当JVM进程启动之后,同时开启两个线程 - 分别是<strong>main主线程</strong>以及一个<strong>GC线程</strong>[后台守护线程]</p>
<p>守护线程 - 如果后台只剩下守护线程在执行的时候,进程就会结束. -&gt; <strong>进程的结束不需要等到守护线程全部执行完才会结束</strong>.</p>
</li>
<li><p>main线程负责执行main方法中的程序 - main方法中的程序全部执行完之后,main线程运行结束.<br>GC线程负责进行垃圾对象的回收.</p>
</li>
</ol>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>正在执行中的应用程序: 是<strong>并发执行的程序在执行过程中分配和管理资源的基本单位</strong>,是一个动态概念.</p>
<p><em><strong>竞争计算机系统资源的基本单位</strong></em>。 - “多任务操作系统” - “多个进程在**”同时”**在运行” - CPU分配资源 - <strong>“分时分片”</strong> - CPU调度的基本单位</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>是进程的一个执行单元</strong>，是进程内部调度实体。<strong>比进程更小的独立运行的基本单位</strong>。<strong>线程也被称为轻量级进程</strong>。</p>
<p>一个进程可以拥有多个线程的同一个进程内部的多个线程是可以共享进程资源的</p>
<h3 id="线程的创建-传统方式"><a href="#线程的创建-传统方式" class="headerlink" title="线程的创建[传统方式]"></a>线程的创建[传统方式]</h3><ol>
<li><p>写一个类去继承java.lang.Thread类 - 重写里面的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的名称</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread01(); <span class="comment">// 面向父类编程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread01();</span><br><span class="line">        <span class="comment">// A.当线程对象一旦被创建成功,线程处于新建状态/瞬态</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.设置线程属性</span></span><br><span class="line">        <span class="comment">// 设置线程的属性一定是在启动线程之前完成的</span></span><br><span class="line">        t1.setName(<span class="string">&quot;线程01&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程02&quot;</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 3.启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// B.一旦调用了start方法,表示线程已经处于就绪态[并不是运行态]</span></span><br><span class="line">        <span class="comment">// C.运行态 - 程序正常运行的过程</span></span><br><span class="line">        <span class="comment">// D.Dead[死亡状态] - 结束状态 - 线程执行结束了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意要点:</p>
<ol>
<li>目前接触的线程状态<ul>
<li>新建状态/瞬态: 线程对象被创建new成功时的状态</li>
<li>就绪态: 启动线程时调用start方法后的状态</li>
<li>运行态: 程序正常运行的状态</li>
<li>死亡态: 线程执行结束的状态</li>
</ul>
</li>
<li>设置线程的属性一定在启动线程之前完成.</li>
<li>如果没有给线程设置名称,那么系统会自动默认给线程分配名称.<br>格式: Thread-数字</li>
<li><strong>线程的启动调用的是start方法,重写的是run方法.底层是让jvm调度线程,所以run方法是由jvm进行调度的</strong>.</li>
<li>并不是先启动哪个线程,就一定会先去执行哪个线程 - <strong>线程的执行是由cpu控制的</strong> - 不是人为进行控制的.所以程序的运行结果不是一定的.</li>
</ol>
</blockquote>
</li>
<li><p>写一个类去实现java.lang.Runnale接口 - 重写里面的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/9 18:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程的创建 - 实现Runnable接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread02</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的名称</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread02</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.线程的创建</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Thread02();</span><br><span class="line">        <span class="comment">// 构造:public Thread(Runnable target)</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置线程属性</span></span><br><span class="line">        t1.setName(<span class="string">&quot;线程-1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>写一个类去实现java.util.concurrent包下的Callable接口 - 重写里面的call方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   ~~~</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">#### Thread和Runnable的区别</span><br><span class="line"></span><br><span class="line">* Thread:**共享代码,不共享资源**</span><br><span class="line"></span><br><span class="line">  ~~~java</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 创建线程</span></span><br><span class="line">          Thread t1 = <span class="keyword">new</span> T1();</span><br><span class="line">          Thread t2 = <span class="keyword">new</span> T1();</span><br><span class="line">          t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">          t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">      <span class="comment">// 定义一个属性</span></span><br><span class="line">      <span class="keyword">private</span> Integer tickets = <span class="number">10</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">              <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                  System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在购票,剩余:&quot;</span>+(--tickets));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">线程1正在购票,剩余:9</span><br><span class="line">线程2正在购票,剩余:9</span><br><span class="line">线程1正在购票,剩余:8</span><br><span class="line">线程1正在购票,剩余:7</span><br><span class="line">线程1正在购票,剩余:6</span><br><span class="line">线程1正在购票,剩余:5</span><br><span class="line">线程1正在购票,剩余:4</span><br><span class="line">线程1正在购票,剩余:3</span><br><span class="line">线程1正在购票,剩余:2</span><br><span class="line">线程1正在购票,剩余:1</span><br><span class="line">线程1正在购票,剩余:0</span><br><span class="line">线程2正在购票,剩余:8</span><br><span class="line">线程2正在购票,剩余:7</span><br><span class="line">线程2正在购票,剩余:6</span><br><span class="line">线程2正在购票,剩余:5</span><br><span class="line">线程2正在购票,剩余:4</span><br><span class="line">线程2正在购票,剩余:3</span><br><span class="line">线程2正在购票,剩余:2</span><br><span class="line">线程2正在购票,剩余:1</span><br><span class="line">线程2正在购票,剩余:0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程的调度不是人为控制的,所以每次的结果可能都是不同的.这个运行结果表示每个线程都拥有各自的资源[指的tickets],它不是共享的.</p>
</blockquote>
<p>  只有当资源设置成静态的时候才能进行资源共享</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer tickets = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">线程1正在购票,剩余:9</span><br><span class="line">线程2正在购票,剩余:8</span><br><span class="line">线程1正在购票,剩余:7</span><br><span class="line">线程2正在购票,剩余:6</span><br><span class="line">线程1正在购票,剩余:5</span><br><span class="line">线程2正在购票,剩余:4</span><br><span class="line">线程2正在购票,剩余:2</span><br><span class="line">线程1正在购票,剩余:3</span><br><span class="line">线程2正在购票,剩余:1</span><br><span class="line">线程1正在购票,剩余:0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个结果表示线程拥有的资源是共享的,因为tickets是静态的,静态资源是类加载的时候被分配空间以及初始化,在内存中只有1份.并且这种情况可能仍旧可能出现两个线程在操作同一份tickets的情况,因为没用锁.</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个属性</span></span><br><span class="line">    <span class="comment">//private static Integer tickets = 10;</span></span><br><span class="line">    <span class="keyword">private</span> Integer tickets = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在购票,剩余:&quot;</span>+(--tickets));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">线程2正在购票,剩余:9</span><br><span class="line">线程1正在购票,剩余:9</span><br><span class="line">线程1正在购票,剩余:8</span><br><span class="line">线程2正在购票,剩余:8</span><br><span class="line">线程1正在购票,剩余:7</span><br><span class="line">线程2正在购票,剩余:7</span><br><span class="line">线程2正在购票,剩余:6</span><br><span class="line">线程1正在购票,剩余:6</span><br><span class="line">线程2正在购票,剩余:5</span><br><span class="line">线程1正在购票,剩余:5</span><br><span class="line">线程2正在购票,剩余:4</span><br><span class="line">线程1正在购票,剩余:4</span><br><span class="line">线程2正在购票,剩余:3</span><br><span class="line">线程1正在购票,剩余:3</span><br><span class="line">线程1正在购票,剩余:2</span><br><span class="line">线程2正在购票,剩余:2</span><br><span class="line">线程2正在购票,剩余:1</span><br><span class="line">线程1正在购票,剩余:1</span><br><span class="line">线程2正在购票,剩余:0</span><br><span class="line">线程1正在购票,剩余:0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Runnable:<strong>共享代码,共享资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> T2();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Integer tickets = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在购票,剩余:&quot;</span>+(--tickets));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">线程1正在购票,剩余:9</span><br><span class="line">线程1正在购票,剩余:7</span><br><span class="line">线程1正在购票,剩余:6</span><br><span class="line">线程1正在购票,剩余:5</span><br><span class="line">线程1正在购票,剩余:4</span><br><span class="line">线程1正在购票,剩余:3</span><br><span class="line">线程1正在购票,剩余:2</span><br><span class="line">线程2正在购票,剩余:8</span><br><span class="line">线程1正在购票,剩余:1</span><br><span class="line">线程2正在购票,剩余:0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程安全的类和线程非安全的类"><a href="#线程安全的类和线程非安全的类" class="headerlink" title="线程安全的类和线程非安全的类"></a>线程安全的类和线程非安全的类</h3><ul>
<li>StringBuilder - 线程非安全的字符串类; StringBuffer - 线程安全的字符串类</li>
<li>ArrayList - 线程非安全的集合;  Vector - 线程安全的集合</li>
<li>HashMap - 线程非安全的集合;  Hashtable - 线程安全的集合</li>
</ul>
<blockquote>
<p>以上线程安全的类,它们的api方法都使用了<strong>synchronized</strong>进行修饰.<strong>在某个时刻只能由一个线程去访问,其他线程都是出于等待状态</strong>.</p>
</blockquote>
<h4 id="实例-使用类型安全的类"><a href="#实例-使用类型安全的类" class="headerlink" title="实例 - 使用类型安全的类"></a>实例 - 使用类型安全的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/9 19:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 线程安全与线程非安全的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> TS();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TS</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//线程安全的类</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span> ; i++) &#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;大小:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+vector.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运行结果:(随机展示了三种情况)</span><br><span class="line">大小:Thread-0:175656</span><br><span class="line">大小:Thread-1:200000</span><br><span class="line"></span><br><span class="line">大小:Thread-0:200000</span><br><span class="line">大小:Thread-1:200000</span><br><span class="line"></span><br><span class="line">大小:Thread-1:174163</span><br><span class="line">大小:Thread-0:200000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问:是否能理解为什么数值可以不为200000</p>
<p>在实际运行时,很少能有两个结果都为200000的情况.因为实际时很难做到完成的同步,通常都是第一个打印的结果比第二个打印的结果小(但具体是线程1先打印还是线程2先打印也是不一定的).因为在运行的时候,可能会有一个运行的比较快,然后另一个还没运行完.</p>
<p>老师的例子:小红和小蓝有一个共用的工资卡[Vector],到了发工资的时候,两个人同时发工资,小红五千五千地转钱到这个工资卡,而小蓝则是一千一千的转钱到工资卡.转钱的动作是同时进行的,小红在转十万的同时,小蓝也在向工资卡里面转钱.</p>
<p>有三种情况:<br>第一种情况是小红转完了小蓝还没有转完,小红查看时发现卡里有她自己转的十万,还有小蓝转的几万.<br>第二种情况是小红转完的同时小蓝也转完了,他俩查看的时候都发现卡里正好有二十万.<br>第三种情况是小红转的太慢了,小蓝转完了的时候小红还没转完,小蓝查看的时候有他自己转的十万,还有小红转的几万.</p>
<p><strong>最终的结果不是由一个线程在做贡献,两个线程都在做贡献</strong></p>
</blockquote>
<h4 id="实例-使用类型不安全的类"><a href="#实例-使用类型不安全的类" class="headerlink" title="实例 - 使用类型不安全的类"></a>实例 - 使用类型不安全的类</h4><p><strong>线程非安全的类 - 不要让它设置成一个共享资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程不安全的类</span></span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Integer&gt; vector = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span> ; i++) &#123;</span><br><span class="line">        vector.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;大小:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+vector.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.ArrayIndexOutOfBoundsException: 163</span><br><span class="line">大小:Thread-1:100136</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两者之间的对比:</p>
<p>Vector类中的add方法是由<strong>synchronized</strong>修饰的,要么是由线程1执行,要么是由线程2执行,<strong>不可能两个线程同时进入到这个add方法</strong>.</p>
<p>而ArrayList类中add方法没有由synchronized修饰,两个线程会同时进入到add方法,明明应该是添加了两个元素,但<strong>其中一个线程的值会覆盖另外一个线程的值</strong>,导致实际上仅仅是向容器中添加了一个元素.并且每次add方法调用时,底层的size就会自增,但是集合中的有效个数却会少掉一个,导致<strong>有效数据&lt;size</strong>,因此报错.</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>static Thread currentThread();    //返回当前正在执行的线程的引用对象</li>
<li>String getName();    // 返回线程的名称</li>
<li>void start();    // 启动线程,本质上当线程.start时底层会让jvm去启动线程,我们的程序是没有资格和能力去真正的把一个线程给启动起来的.  CPU调度JVM线程 - JVM调用线程</li>
<li>void setName(String name);    // 给线程设置名称</li>
</ol>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><ol>
<li>java语言的关键字</li>
<li><strong>可以用来给对象,方法或者代码块加锁</strong></li>
<li>当它锁定一个方法[同步方法]或者一个代码块[同步代码块]的时候,<strong>同一时刻最多只有一个线程执行这段代码</strong></li>
<li>当两个并发线程访问同一个对象object中的这个加锁同步代码块时,一个时间内只能有一个线程得到执行,另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块.</li>
</ol>
<h4 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h4><p>在java中,<strong>每个对象有且仅有一个同步锁</strong>,并且同步锁是依赖于对象存在的.当我们调用对象的synchronized修饰的同步方法的时候,就是获取了该对象的同步锁.</p>
<ol>
<li>修饰普通方法 - <strong>对象锁</strong> -  不同的对象拥有独立的”一把锁”,<strong>每个对象的”锁”是不冲突的</strong>.</li>
<li>修饰静态方法 - <strong>类锁</strong> - 作用于这个类下的所有对象 - 这个类实例化出来的所有对象竞争的是<strong>同一把锁</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.syn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/10 18:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynHello</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//add3();</span></span><br><span class="line">        add4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:0&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:0&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSynHello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> SynHello();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> SynHello();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用synchronized修饰非静态方法时是对象锁,每个对象拥有独立的锁,而t1和t2是两个不同的对象,所以不影响结果.</p>
<p>使用synchronized修饰静态方法时是类锁,这个类实例化出来的对象t1和t2竞争的都是同一把锁,所以结果改变,真正实现了将add方法锁住.</p>
<p>还有一个点就是对于Runnable而言,即使是使用synchronized修饰非静态方法,但利用Runnable创建线程new的对象是相同的,所以也是能锁住的.</p>
</blockquote>
<ol start="3">
<li>修饰代码块<code>synchronized(this)</code> - 对象锁</li>
<li>修饰代码块<code>synchronized(类名.class)</code> - 类锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.syn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/10 19:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> synchronized修饰代码块</span></span><br><span class="line"><span class="comment"> * 场景:没有必要锁住整个方法,仅仅只需要锁住需要同步的代码即可.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynLockDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynLockDemo.class)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:0&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:0&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSynLockDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> SynLockDemo();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> SynLockDemo();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>领悟到对象锁和类锁之间的区别就ok啦.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynLock2Demo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();  <span class="comment">// 要记得初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            <span class="comment">// 这个obj在这里的含义和this是一样哒</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:0&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h4><ol>
<li><p>原子性</p>
<p><strong>原子性代表一个操作或者多个操作,要么执行全部并且执行的过程中不能被任何因素打断,要么就不执行.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">比如i++;i+=<span class="number">2</span>;i=i+<span class="number">1</span>;这些操作都不是原子操作,它们要经过[读取,计算,赋值]这三个操作.</span><br><span class="line">三个步骤中的任何一个步骤在执行的时候都可能被其他线程打断.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;	<span class="comment">// 这就是一个原子操作</span></span><br><span class="line"><span class="keyword">double</span> x = <span class="number">3.0d</span>;	<span class="comment">// 这不是原子操作</span></span><br><span class="line"><span class="keyword">long</span> x = <span class="number">20L</span>;	<span class="comment">// 这也不是原子操作.</span></span><br></pre></td></tr></table></figure></li>
<li><p>可见性</p>
<p><strong>多个线程访问同一个资源的时候,这个资源的状态信息等对其他线程都是可见的.</strong></p>
<p>线程在遇到synchronized时,会清空本地工作内存,然后重新去主存拷贝最新的值.</p>
</li>
<li><p>有序性</p>
<p>在同一个时刻,只能由一个线程进入.</p>
</li>
<li><p>可重入性.</p>
<p>当一个线程申请到锁资源并且执行完毕之后释放,仍然有机会再去申请曾经申请过的锁资源.</p>
</li>
</ol>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>JMM - <strong>Java内存模型(Java memory model)</strong> </p>
<ol>
<li>JMM规定<strong>所有的变量都存储在主内存中</strong>,包括实例变量[类中的非静态属性],静态变量,但是不包括局部变量和方法参数.</li>
<li>每个线程都有自己的工作内存,<strong>线程的工作内存保存了该线程用到的变量和主内存的副本拷贝,线程对变量的操作都在工作内存中进行.线程不能直接读写主内存中的变量</strong></li>
<li><strong>不同的线程之间也无法访问对方工作内存中的变量,线程直接变量值的传递需要通过主内存来完成.</strong></li>
</ol>
<p><img src="/2021/08/09/java13/jmm.jpeg"></p>
<h3 id="原子性实例"><a href="#原子性实例" class="headerlink" title="原子性实例"></a>原子性实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusNoAtomicity</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个属性</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span> ; j++) &#123;</span><br><span class="line">            add();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPlusNoAtomicity</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> PlusNoAtomicity();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">Thread-0:200</span><br><span class="line">Thread-1:200</span><br><span class="line"></span><br><span class="line">因为自加100次很快,两个线程都在一瞬间完成了,导致结果两个都是200.</span><br></pre></td></tr></table></figure>

<p>如果将循环的次数修改为十万次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span> ; j++) &#123;</span><br><span class="line">            add();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">Thread-0:14203</span><br><span class="line">Thread-1:15055</span><br><span class="line"></span><br><span class="line">Thread-0:13494</span><br><span class="line">Thread-1:13695</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么结果为什么不是两个二十万???</p>
<p>这就要设计到JMM,前面也提到了,JMM规定所有的变量都存储在主内存中,因此i是存储在主内存中的,而每个线程都有自己的工作内存,存储了主内存的副本拷贝 ,对变量的操作都在工作内存中进行.所以在i++进行时,线程将i的副本保存进工作内存,在工作内存中进行自增,然后刷新会主存.</p>
</blockquote>
<p><img src="/2021/08/09/java13/atomicity.png"></p>
<p>这幅图同样也解释了为什么两个的结果都不是二十万.</p>
<h4 id="i-过程-多线程安全问题"><a href="#i-过程-多线程安全问题" class="headerlink" title="i++过程 - 多线程安全问题"></a>i++过程 - 多线程安全问题</h4><p>重点前提:</p>
<ol>
<li><p>线程是不能够操作对主存中的数据进行直接的操作的,必须是在本地的工作内存中去完成的.完成之后,刷回主存的</p>
</li>
<li><p><strong>线程之间是隔离的</strong>.每个线程去执行方法的时候,都会在本地开辟一块区域[栈帧 - 线程栈],每个线程在本地工作内存中</p>
<p>对资源的修改,那么这个资源的信息,状态对其他线程都是不可见的.</p>
</li>
</ol>
<p>add方法没有使用synchronized进行修饰,导致在实现的过程中有线程会使用脏数据.</p>
<p><strong>脏数据</strong> - 本地工作内存中的变量的数据和主存中的变量的数据的值已经不一样,违背了”JMM中的缓存一致性”的原则.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">i++ 不是一个原子性操作的意思就是在它的中间的过程中,可以被被其他线程打断</span><br><span class="line">①T1线程从主存中拷贝变量的副本到本地的工作内存中 - read读取(i=0)      =&gt; T1</span><br><span class="line">  				`T1线程让出了CPU执行权力.T0线程获取执行权力 - 从主存拷贝变量的副本(i=0)`   =&gt; T0	</span><br><span class="line">          `T0线程直接进行了计算,赋值,重新刷回到主存[i=1]`   =&gt; T0</span><br><span class="line">  			  `T0线程刷回i到主存之后,此时主存的i=1,T0线程让出cpu执行权` </span><br><span class="line">②在本地的工作内存中对i进行计算,计算完之后,再把自增的数据重新赋值个i   =&gt; T1</span><br><span class="line">  				`T1线程继续执行②,由于之前T1线程并没有执行结束,因此它不会从已经更新的主存中重新去拷贝i的副本`</span><br><span class="line">  				`所以T1线程继续执行的时候,使用的仍然是自己本地工作内存中的那个变量i[read下来的,初始值仍然是0]`</span><br><span class="line">  				`T1线程i = i + 1,刷回到主存[i=1]`</span><br><span class="line">  				`因为线程是隔离的,T1线程它是不知道T0线程对i进行了修改的.`</span><br><span class="line">③把最终的本地工作内存中的i的计算结果 - [当前线程执行完毕之后]刷回到主存中[时间是不固定的.但是当前线程执行完毕之后,它肯定会刷回到主存]  =&gt; T1</span><br><span class="line">  [如果是单线程环境下,当T1线程把最终的结果刷回到主存之后,第二次再次调用add()方法的时候,那么T1线程仍然会再次从主存中</span><br><span class="line">   获取变量的副本,重复执行①②③)</span><br><span class="line">  </span><br><span class="line">隐约的信号:如果线程T1没有执行结束,那么它是不会从主存中重新拉取值的</span><br><span class="line">   </span><br><span class="line">看到的效果是 - 俩个线程都同时操作了i++,但是主存中的i实际上是只加了1次的结果.</span><br></pre></td></tr></table></figure>

<h4 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h4><p><strong>使用synchronized对i++所在的方法进行修饰</strong></p>
<p>当某个对象调用add方法,得到锁资源的时候,会先<strong>清空</strong>本地工作内存.清空的目的是为了让后面的操作重新从主存中拷贝最新的值.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">Thread-0:18895</span><br><span class="line">Thread-1:20000</span><br><span class="line">可能线程0走的比较快线程1还没走完线程0就走完了,所以结果不到20000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">Thread-0:20000</span><br><span class="line">Thread-1:20000</span><br></pre></td></tr></table></figure>

<ol>
<li>因为add方法进行了同步 - synchronized进行了修饰了.在某个时刻,只能由一个线程[获得锁资源的]进去执行</li>
<li>[<strong>读取,计算,赋值</strong>] - 三个步骤中.其他线程是不可能介入的.因为没有获取锁资源的线程都在外部进行同步阻塞.</li>
<li>当正在执行的线程释放锁资源之前,它会将本地工作内存中的改变刷回到主存.</li>
</ol>
<h3 id="工作内存的改变什么时候同步到主存"><a href="#工作内存的改变什么时候同步到主存" class="headerlink" title="工作内存的改变什么时候同步到主存"></a>工作内存的改变什么时候同步到主存</h3><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>单线程 - <strong>单线程执行方法结束的时候</strong></p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><ol>
<li>线程释放锁资源的时候</li>
<li>线程切换的时候</li>
</ol>
<h3 id="可见性实例"><a href="#可见性实例" class="headerlink" title="可见性实例"></a>可见性实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/10 14:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        x = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">5</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">5</span>)</span><br><span class="line">            System.out.println(<span class="string">&quot;----stopped----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestVisibilityDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VisibilityDemo vb = <span class="keyword">new</span> VisibilityDemo();</span><br><span class="line">        <span class="comment">// 创建一个写线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            vb.writeX();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            vb.readX();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先写再读"><a href="#先写再读" class="headerlink" title="先写再读"></a>先写再读</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1.start();</span><br><span class="line"><span class="comment">// 睡一会</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行结果:</span><br><span class="line">----stopped----</span><br></pre></td></tr></table></figure>

<p>写线程运行时拷贝主存中的x,默认初值为0,然后将x赋值为5,并且刷新回主存,过了一秒以后读线程再运行,拷贝主存中的x,[一秒钟的时间写线程早就运行完了],x的值就为5,所以打印stopped.</p>
<h4 id="先读再写"><a href="#先读再写" class="headerlink" title="先读再写"></a>先读再写</h4><p>首先我们需要知道一个道理,<strong>多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是不可见的</strong>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果先读后写</span></span><br><span class="line">t2.start();<span class="comment">//读</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t1.start();<span class="comment">//写</span></span><br></pre></td></tr></table></figure>

<p>所以在本实例中,如果先启动读线程,读线程拷贝主存中的数据x=0,然后一直在死循环中,等待了一秒钟以后,写线程启动,拷贝主存中的x=0,将其赋值为5并刷新回主存,此时主存中的x=5,但是读线程并不知道,它也不会从主存中重新拷贝值,一直停留在死循环中.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">5</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">5</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;----stopped----&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果readX方法如上所示,结果又会不同.因为println方法中使用到了锁,<strong>对象在获得锁资源的时候,会先清空本地工作内存,强制从主存中去拷贝已经更新的变量</strong>.</p>
<p>所以在这个实例中,每次打印数据后读线程都会清空本地缓存,从主存中拷贝更新后的变量,所以当写线程把主存中变量的值修改以后,读线程能够知道变量已经改变了,从而退出死循环.</p>
<h4 id="如何解决问题-1"><a href="#如何解决问题-1" class="headerlink" title="如何解决问题"></a>如何解决问题</h4><ol>
<li><p>使用synchronized来保证可见性.</p>
</li>
<li><p><strong>使用volatile来修饰实例变量</strong></p>
<p>强制让程序遵守”缓存一致性”协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去.</p>
</li>
</ol>
<h3 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h3><ol>
<li><p>保证可见性</p>
<p><img src="/2021/08/09/java13/volatile01.png"></p>
</li>
<li><p>volatile是不会造成阻塞的.</p>
</li>
<li><p>禁止指令重排</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">指令重排 - JVM指令优化之后</span><br><span class="line">①给对象分配空间</span><br><span class="line">②空间地址立即给s,s保存到栈</span><br><span class="line">③对象的初始化</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> Student s = <span class="keyword">new</span> Student();<span class="comment">//禁止指令重排</span></span><br><span class="line">①给对象分配空间</span><br><span class="line">③对象的初始化</span><br><span class="line">②空间地址立即给s,s保存到栈</span><br></pre></td></tr></table></figure></li>
<li><p>不能保证原子性</p>
<p><img src="/2021/08/09/java13/volatile02.png"></p>
</li>
</ol>
<h3 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h3><ol>
<li>volatile只能作用于变量,而synchronized可以作用于变量,方法和代码块.</li>
<li>多线程访问volatile不会发射是那个阻塞,而synchronized可能发生阻塞[锁].</li>
<li>volatile能够保证数据的可见性,但不能保证原子性.而synchronized关键字都可以保证</li>
<li>volatile关键字主要解决的是多个线程之间的可见性,而synchronized关键字保证的是多个线程访问资源的同步性.</li>
<li>volatile可以禁止jvm指令重排,而synchronized不能.</li>
</ol>
<h3 id="synchronized的底层原理"><a href="#synchronized的底层原理" class="headerlink" title="synchronized的底层原理"></a>synchronized的底层原理</h3><p>了解即可.</p>
<p><strong>每一个锁都对应一个monitor对象</strong>，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。</p>
<p><img src="/2021/08/09/java13/monitor.png"></p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ol>
<li><p>地址空间：同一进程的线程共享本进程的地址空间，而<strong>进程之间则是独立的地址空间。</strong></p>
<p><strong>进程与进程之间是独立的.</strong> <strong>同一个进程内部的多个线程是可以共享进程资源的.</strong></p>
</li>
<li><p>资源拥有：同一进程内的<strong>线程共享本进程的资源</strong>，但是<strong>进程之间的资源是独立的。</strong></p>
</li>
<li><p>一个进程崩溃后，在保护模式下不会对其他进程产生影响，<strong>但是一个线程崩溃整个进程都死掉</strong>。<strong>所以多进程要比多线程健壮。</strong></p>
</li>
<li><p><strong>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时</strong>，<strong>使用线程要好于进程</strong>。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。</p>
<p>-<em>进程重量级的单位(创建,切换,销毁 - 费时)</em></p>
<p><em>-线程轻量级的单位(创建,切换,销毁 - 比较高)</em></p>
</li>
<li><p>执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是<strong>线程不能独立执行</strong>，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
</li>
<li><p><strong>线程是处理器调度的基本单位，但是进程不是。</strong></p>
</li>
<li><p><strong>两者均可并发执行。</strong>   </p>
</li>
</ol>
<p><strong>一个线程只属于一个进程，但是一个进程可以拥有多个线程，但至少一个线程</strong>资源分配给进程，同一进程中所有线程共享该进程的所有资源。</p>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p><img src="/2021/08/09/java13/thread_status.png"></p>
<ol>
<li>New：<strong>新建状态</strong>/<strong>瞬态</strong>，当线程对象创立后，即进入了新建状态，如：Thread t = new MyThread()</li>
<li>Runnable：就绪状态，当调用线程对象的start()方法（t.start()），线程就进入就绪状态。处于就绪状态的线程，<strong>只是说明此线程已经做好了准备，随时等待cpu调度执行</strong>，并不是说执行了t.start()此线程立即就会执行</li>
<li>Running：运行状态，当cpu开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</li>
<li>Blocked：阻塞状态，处于运行状态中的线程由于某种原因，暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态</li>
<li>Dead：死亡状态(结束状态)，线程执行完了或者因异常退出了run()方法，该线程结束生命周期</li>
</ol>
<p>（1）就绪状态是进入到运行状态的唯一入口<br>（2）线程想要进入到运行状态执行，首先必须处于就绪状态中<br>（3）根据阻塞产生的原因，阻塞状态又可以分为三种：<br> 【1】等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态<br> 【2】同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态<br> 【3】其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态.之前获取键盘输入.</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>GC - 运行在后台的 - 负责回收垃圾对象</p>
<p>核心: **线程结束的时候不需要关心后台的守护线程是否也运行结束,线程是不会等后台的守护线程全部运行结束才结束.**当后台只有守护线程在执行的时候,就可以认为线程可以结束了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/11 9:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 守护线程的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> T1();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> T2();</span><br><span class="line">		<span class="comment">// 将打印数字的线程设置成后台守护线程</span></span><br><span class="line">        <span class="comment">// 如果后台只剩下守护线程在执行就可以结束了</span></span><br><span class="line">        <span class="comment">// 不需要等待所有的守护线程运行结束才结束</span></span><br><span class="line">        t2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">65</span>; i &lt;=<span class="number">90</span> ; i++) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lock-同步代码"><a href="#Lock-同步代码" class="headerlink" title="Lock - 同步代码"></a>Lock - 同步代码</h3><p>Lock是一个接口,下面有很多的实现类.</p>
<ul>
<li>lock需要<strong>手动申请锁</strong>(对象锁)</li>
<li>lock是锁代码块</li>
<li>lock出现异常的时候是不会主动释放资源的.</li>
</ul>
<h4 id="Lock提供的方法"><a href="#Lock提供的方法" class="headerlink" title="Lock提供的方法"></a>Lock提供的方法</h4><ol>
<li>void lock();    // 手动上锁</li>
<li>boolean tryLock();    // 如果获取锁失败,则直接返回false,如果获取锁成功,返回true</li>
<li>boolean tryLock(long time,TimeUnit unit);    // 如果在尝试获取锁的过程中等待超过了time,就会导致获取锁失败.</li>
</ol>
<h3 id="面试题-synchronized和Lock的区别"><a href="#面试题-synchronized和Lock的区别" class="headerlink" title="面试题 - synchronized和Lock的区别"></a>面试题 - synchronized和Lock的区别</h3><p>synchronized和lock都属于<strong>独占锁</strong></p>
<ol>
<li><p><strong>实现层面不一样</strong>.synchronized是Java关键字,jvm层面实现加锁和释放锁.Lock是一个接口,在代码层面实现加锁和释放锁.</p>
</li>
<li><p><strong>是否自动释放锁</strong>.synchronized在线程代码执行完或出现异常时自动释放锁.Lock不会自动释放锁,需要在finally{}代码块中显式地释放锁.</p>
</li>
<li><p><strong>是否一直等待</strong>.synchronized会导致线程拿不到锁一直等等待.Lock可以设置尝试获取锁或者获取锁失败一定时间超时.</p>
</li>
<li><p><strong>获取锁成功是否可知</strong>.synchronized无法得知是否获取锁成功.Lock可以通过tryLock获得加锁是否能够.</p>
</li>
<li><p><strong>功能复杂性</strong>.synchronized加锁<strong>可重入,不可中断,非公平</strong>.Lock<strong>可重入,可中断,可公平和不公平,细分读写锁提高效率</strong>.</p>
<ul>
<li>读锁 - java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock - 共享锁 - 允许多个线程去读.</li>
<li>写锁 - java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock - 互斥锁 - 一次只能由一个线程去写.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不可中断synchronized  - A线程竞争到锁资源 - 顺利进入同步代码块执行 - 只要A资源不释放这个锁资源.B线程只能在外面等待.</span><br><span class="line"></span><br><span class="line">可中断Lock -&gt; A线程顺利执行同步代码,B线程如果tryLock方法话,那么B线程不断尝试获取锁资源.如果设置了超时等待时间.B线程等太久.已经超过了设置的时间.B线程将不会再傻乎乎继续等待下去[可中断],B线程就有可能去干别的事情了.</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><p>synchronized</p>
<ol>
<li>wait(); Object类中的方法,必须放在<strong>循环体和同步代码块</strong>中,执行该方法的线程会<strong>释放锁</strong>,然后进入<strong>线程等待池</strong>等待再次被唤醒,再放入锁池中竞争同步锁.</li>
<li>notify(); Object类中的方法,随机唤醒一个线程.</li>
<li>notifyAll(); Object类中的方法,唤醒所有线程</li>
</ol>
<p>lock</p>
<ol>
<li>Condition new Condition(); 创建等待度列</li>
<li>void await();  当前线程会进入到阻塞状态,必须要等其他线程唤醒.</li>
<li>void signal(); 哪个线程的Contion对象去调用signal()方法,哪个线程就会被唤醒.</li>
</ol>
<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>单个生产者和单个消费者 </p>
<p>生产者线程 - 负责生产产品-box[把产品放入到box]</p>
<p>消费者线程 - 负责消费产品-box[从box中去获取产品]</p>
<p>通信的流程</p>
<ol>
<li><p>俩条线程并发执行 - 调用的是不同的方法</p>
</li>
<li><p>假设消费者线程先执行 - 直接从box中去获取产品.但是此时此刻box中尚无产品.</p>
<p>消费者线程就需要调用<strong>wait方法 - 自己会释放锁资源</strong>,消费者线程进入到线程等待池[意味着当前的线程会进入到等待阻塞的状态]</p>
<p>-getter方法</p>
</li>
<li><p>假设生产者线程 - setter方法</p>
<p>先执行了.发现box中没有产品的,顺利放入一个产品到box中的.但是放完之后.生产者还是会继续执行.继续执行的时候又会调用</p>
<p>setter方法.这个时候,不能允许生产者线程连续再放 - 就得调用<strong>生产者线程的wait方法</strong>,同时还需要唤醒消费者线程过来消费.</p>
</li>
<li><p>消费者线程一旦消费成功,它还是会继续执行自己的getter方法.发现box中没有了.回到第2个步骤</p>
</li>
</ol>
<p>demo1 - synchronized实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/11 10:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Communication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box box = <span class="keyword">new</span> Box();</span><br><span class="line"></span><br><span class="line">        Thread product = <span class="keyword">new</span> ProductThread(box);</span><br><span class="line">        Thread customer = <span class="keyword">new</span> CustomerThread(box);</span><br><span class="line"></span><br><span class="line">        product.setName(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        customer.setName(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line"></span><br><span class="line">        product.start();</span><br><span class="line"></span><br><span class="line">        customer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> content;    <span class="comment">//产品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">int</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">//产品</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductThread</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box = box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;放&quot;</span>+(++i)+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">            box.setContent(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Box  box;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerThread</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box = box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;取&quot;</span>+box.getContent()+<span class="string">&quot;个&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo2 - lock实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.homework_0811;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/11 18:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 生产者消费者问题 - 利用Lock和Condition解决</span></span><br><span class="line"><span class="comment"> * 假设盒子能容纳最大产品数量为10,生产者每次随机生产1-10个产品,并且只有在盒子为空时生产者才能生产产品.</span></span><br><span class="line"><span class="comment"> * 消费者只能在产品数目不为0时进行消费,并且必须有多少买多少.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndCustomer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有几个线程就创建几个Condition</span></span><br><span class="line">    <span class="keyword">private</span> Condition producer = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> content;    <span class="comment">//盒子里的产品个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 生产者只有在盒子中产品数目等于0时进行生产</span></span><br><span class="line">                <span class="comment">// 如果盒子里的数目不为0,那么让生产者进入阻塞状态</span></span><br><span class="line">                <span class="keyword">if</span>(content!=<span class="number">0</span>)&#123;</span><br><span class="line">                    producer.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则进行产品的生产</span></span><br><span class="line">                content = (<span class="keyword">int</span>) (Math.random()*<span class="number">10</span> + <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产了&quot;</span>+content+<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 唤醒消费者线程</span></span><br><span class="line">                consumer.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">// 如果盒子里的数目小于等于0表示盒子空了,消费者不能再消费啦</span></span><br><span class="line">                <span class="keyword">if</span>(content==<span class="number">0</span>)&#123;</span><br><span class="line">                    consumer.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消费</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费了&quot;</span>+content+<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">                content = <span class="number">0</span>;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 唤醒生产者线程</span></span><br><span class="line">                producer.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestProducerAndCustomer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerAndCustomer pc = <span class="keyword">new</span> ProducerAndCustomer();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            pc.produce();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            pc.consume();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三个线程循环打印abc-ABC-123"><a href="#三个线程循环打印abc-ABC-123" class="headerlink" title="三个线程循环打印abc ABC 123"></a>三个线程循环打印abc ABC 123</h3><p>打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/11 14:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> *  同程公司笔试题 - 循环打印abc ABC 123 abc  ABC 123</span></span><br><span class="line"><span class="comment"> *  *</span></span><br><span class="line"><span class="comment"> *  * 打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程</span></span><br><span class="line"><span class="comment"> *  *</span></span><br><span class="line"><span class="comment"> *  * 使用Lock中的同步队列 - 解决方案 - **唤醒指定的等待队列上的某个线程.**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicationLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有几个线程就创建几个队列</span></span><br><span class="line">    <span class="comment">// 打印小写字母的队列</span></span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 打印大写字母的队列</span></span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="comment">// 打印数字的队列</span></span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印小写字母的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLower</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               <span class="comment">// 首先判断状态</span></span><br><span class="line">               <span class="comment">// 如果count=0则运行,否则进入阻塞状态</span></span><br><span class="line">               <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                   c1.await();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 否则运行 打印小写的abc</span></span><br><span class="line">               System.out.print(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">               <span class="comment">// 打完后等一秒</span></span><br><span class="line">               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               <span class="comment">// 修改count的值</span></span><br><span class="line">               count = <span class="number">1</span>;</span><br><span class="line">               <span class="comment">// 唤醒打印大写字母的线程</span></span><br><span class="line">               c2.signal();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 关闭锁资源</span></span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印大写字母的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 首先判断 count = 1时打印大写字母</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">1</span>)&#123;</span><br><span class="line">                    c2.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则打印</span></span><br><span class="line">                System.out.print(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                count = <span class="number">2</span>;</span><br><span class="line">                c3.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">2</span>)&#123;</span><br><span class="line">                    c3.await();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="number">123</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                c1.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommunicationLockDemo demo = <span class="keyword">new</span> CommunicationLockDemo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printLower();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printUpper();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            demo.printNum();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面试题-常用方法区别"><a href="#面试题-常用方法区别" class="headerlink" title="面试题 - 常用方法区别"></a>面试题 - 常用方法区别</h3><p>wait方法和sleep方法的区别</p>
<ol>
<li>wait方法一定是出现字synchronized同步代码内部的,而sleep是可以放在同步代码中也可以放在不是同步代码的代码中.</li>
<li><strong>执行wait方法的线程会释放锁并释放cpu,而执行sleep方法只会释放cpu不会释放锁</strong>. - 核心区别</li>
<li>sleep方法线程会自动进入到其他阻塞状态,一旦睡眠结束,会自动从阻塞状态恢复到可就绪态,等待cpu的到来,然后到运行态.<br>wait方法线程会自动进入到等待阻塞状态,自己不会主动醒过来,必须是其他线程调用notify或者notifyAll,然后会进入到锁定状态,再次尝试去获取锁.</li>
</ol>
<p>官方答案</p>
<ol>
<li>sleep：Thread类的方法，必须带一个时间参数。<strong>会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段）</strong>，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。</li>
<li>yield：<strong>让出CPU调度</strong>，Thread类的方法，类似sleep只是<strong>不能由用户指定暂停多长时间 ，</strong>并且yield()方法<strong>只能让同优先级的线程</strong>有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入<strong>到可执行状态后</strong>马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</li>
<li>wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁</li>
<li>join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</li>
</ol>
<p>join方法的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.aistar.day15.thread02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> liuWenXiu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/8/11 9:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread mother = <span class="keyword">new</span> Mother();</span><br><span class="line">        mother.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈在烧饭&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈发现酱油没啦..&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈让儿子去打酱油&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            son.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈继续烧饭!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子去打酱油啦&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;还有&quot;</span>+i+<span class="string">&quot;分钟儿子就回来啦&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子回来啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>“哲学家就餐问题”</p>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程.</p>
<h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><ol>
<li><strong>互斥条件</strong>: 指进程对所分配到的资源进行排他性使用,即<strong>在一段时间内某资源只由一个进程占用</strong>.如果此时还有其他进程请求资源,则请求者只能等待,直到占有资源的进程使用完毕释放.</li>
<li><strong>请求和保护条件</strong>: 指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已经被其他进程占有,此时请求进程阻塞,但又对自己已经获得的其他资源保持不放.</li>
<li><strong>不剥夺条件</strong>: 指进程已获得的资源,在未使用完之前,不能被剥夺,只能使用完时自己释放.</li>
<li><strong>环路等待条件</strong>: 发生死锁时,必然存在一个进程–资源的环形链,即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ol>
<p><em><strong>只要打破四个条件的一个,就可以防止死锁.</strong></em></p>
<p><em><strong>死锁是不可避免,但是需要写程序的破坏四个条件中的一个.</strong></em></p>
<p><em><strong>静态域容易产生死锁.</strong></em></p>
<h2 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h2><p>线程池的返回值ExecutorService简介</p>
<p>ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：<strong>控制线程数量</strong>和<strong>重用线程</strong></p>
<ul>
<li>Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务</li>
<li>Executors.newFixedThreadPool(int n)：创建一个<strong>可重用</strong>固定个数的线程池，以共享的无界队列方式来运行这些线程。</li>
<li>Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行</li>
<li>Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:2294014200@qq.com">sakura</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://beautifulboyy/2021/08/09/java13/">http://beautifulboyy/2021/08/09/java13/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://beautifulboyy" target="_blank">今晚你会梦到电子羊吗</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><div class="post_share"><div class="social-share" data-image="/img/wlop012.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/10/java14/"><img class="prev-cover" src="/img/wlop012.jpg" onerror="onerror=null;src='/img/avatar.jpeg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">枚举类型</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/06/java12/"><img class="next-cover" src="/img/wlop012.jpg" onerror="onerror=null;src='/img/avatar.jpeg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">泛型</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">sakura</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.</span> <span class="toc-text">Java程序的启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">线程的创建[传统方式]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%9D%9E%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">线程安全的类和线程非安全的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">实例 - 使用类型安全的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">实例 - 使用类型不安全的类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.3.4.</span> <span class="toc-text">synchronized关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">基础方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">synchronized特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM"><span class="toc-number">1.3.5.</span> <span class="toc-text">JMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.6.</span> <span class="toc-text">原子性实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#i-%E8%BF%87%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">i++过程 - 多线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">如何解决问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E6%94%B9%E5%8F%98%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%90%8C%E6%AD%A5%E5%88%B0%E4%B8%BB%E5%AD%98"><span class="toc-number">1.3.7.</span> <span class="toc-text">工作内存的改变什么时候同步到主存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.8.</span> <span class="toc-text">可见性实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%86%99%E5%86%8D%E8%AF%BB"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">先写再读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%AF%BB%E5%86%8D%E5%86%99"><span class="toc-number">1.3.8.2.</span> <span class="toc-text">先读再写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.3.8.3.</span> <span class="toc-text">如何解决问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.9.</span> <span class="toc-text">volatile关键字的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%92%8Csynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.10.</span> <span class="toc-text">volatile和synchronized的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.11.</span> <span class="toc-text">synchronized的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.12.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.13.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.14.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.15.</span> <span class="toc-text">Lock - 同步代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.15.1.</span> <span class="toc-text">Lock提供的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.16.</span> <span class="toc-text">面试题 - synchronized和Lock的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.4.</span> <span class="toc-text">线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">重要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">生产者消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0abc-ABC-123"><span class="toc-number">1.4.3.</span> <span class="toc-text">三个线程循环打印abc ABC 123</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.</span> <span class="toc-text">面试题 - 常用方法区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.5.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">死锁产生的条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.6.</span> <span class="toc-text">四种常见的线程池</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/31/mysql-points/" title="mysql重要知识点"><img src="/img/wlop012.jpg" onerror="this.onerror=null;this.src='/img/avatar.jpeg'" alt="mysql重要知识点"/></a><div class="content"><a class="title" href="/2021/08/31/mysql-points/" title="mysql重要知识点">mysql重要知识点</a><time datetime="2021-08-31T11:45:12.000Z" title="发表于 2021-08-31 19:45:12">2021-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/31/mybatis01/" title="mybatis基础(一)"><img src="/img/wlop012.jpg" onerror="this.onerror=null;this.src='/img/avatar.jpeg'" alt="mybatis基础(一)"/></a><div class="content"><a class="title" href="/2021/08/31/mybatis01/" title="mybatis基础(一)">mybatis基础(一)</a><time datetime="2021-08-31T03:00:38.000Z" title="发表于 2021-08-31 11:00:38">2021-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/30/jdbc04/" title="jdbc拓展"><img src="/img/wlop012.jpg" onerror="this.onerror=null;this.src='/img/avatar.jpeg'" alt="jdbc拓展"/></a><div class="content"><a class="title" href="/2021/08/30/jdbc04/" title="jdbc拓展">jdbc拓展</a><time datetime="2021-08-30T08:32:14.000Z" title="发表于 2021-08-30 16:32:14">2021-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/25/jdbc03/" title="数据库连接池"><img src="/img/wlop012.jpg" onerror="this.onerror=null;this.src='/img/avatar.jpeg'" alt="数据库连接池"/></a><div class="content"><a class="title" href="/2021/08/25/jdbc03/" title="数据库连接池">数据库连接池</a><time datetime="2021-08-25T06:47:49.000Z" title="发表于 2021-08-25 14:47:49">2021-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/25/jdbc02/" title="jdbc基础(二)"><img src="/img/wlop012.jpg" onerror="this.onerror=null;this.src='/img/avatar.jpeg'" alt="jdbc基础(二)"/></a><div class="content"><a class="title" href="/2021/08/25/jdbc02/" title="jdbc基础(二)">jdbc基础(二)</a><time datetime="2021-08-25T06:47:36.000Z" title="发表于 2021-08-25 14:47:36">2021-08-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/wlop012.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By sakura</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://beautifulboyy.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>