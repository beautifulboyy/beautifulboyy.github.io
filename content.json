{"meta":{"title":"Welcome to my world.","subtitle":"","description":"","author":"sakura","url":"http://beautifulboyy","root":"/"},"pages":[{"title":"tags","date":"2021-07-30T03:15:20.000Z","updated":"2021-07-30T03:16:05.153Z","comments":true,"path":"tags/index.html","permalink":"http://beautifulboyy/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2021-07-30T03:16:59.000Z","updated":"2021-07-30T03:17:13.878Z","comments":true,"path":"link/index.html","permalink":"http://beautifulboyy/link/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-30T03:16:21.000Z","updated":"2021-07-30T03:16:40.094Z","comments":true,"path":"categories/index.html","permalink":"http://beautifulboyy/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"泛型","slug":"java12","date":"2021-08-06T08:11:53.000Z","updated":"2021-08-06T08:18:24.970Z","comments":true,"path":"2021/08/06/java12/","link":"","permalink":"http://beautifulboyy/2021/08/06/java12/","excerpt":"","text":"泛型Generic定义 java在1.5之后加入了泛型的概念.泛型,即”参数化类型”. 泛型的本质是为了参数化类型(将类型参数化传递),在不创建新的类型的情况下,通过泛型指定的不同类型来控制形参具体限制的类型. 也就是说在泛型使用过程中,操作的数据类型被指定为一个参数. 这种参数类型可以用在类,接口和方法中,分别被称为泛型类,泛型接口,泛型方法.","categories":[],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://beautifulboyy/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"输入输出流","slug":"java11","date":"2021-08-05T00:31:12.000Z","updated":"2021-08-06T08:10:39.576Z","comments":true,"path":"2021/08/05/java11/","link":"","permalink":"http://beautifulboyy/2021/08/05/java11/","excerpt":"","text":"输入输出流Filejava.io.File[C] - File包含文件或者文件夹[目录directory] 作用:用来操作File本身的元信息,比如支持File的创建,删除,获取File的名称,获取File的路径信息,但它并不支持文件里面的内容的读写操作.[文件内容的读写操作是交给IO流去实现的] 支持本地File以及远程File的操作 File对象 - Java程序将磁盘上的文件加载内存中然后映射到File对象上 - File是内存中的磁盘上的映射. 构造方法 File(String path); // 利用一个路径来构建一个File实例,这个路径可以是文件的路径,也可以是文件夹的路径 路径分为相对路径和绝对路径: 绝对路径 - windows操作系统是以盘符号开头的路径,Linux/max以/开头的路径 相对路径 - 不是以盘符号或者/开头的路径 File(File parent, String child); //child是文件名 常用方法 boolean createNewFile(); // 创建一个文件[该方法需要抓取异常] String getAbsolutePath(); // 获取该File的绝对路径 String getName(); // 获取File的名称 String getParent(); // 获取该File的父目录的路径[如果创建时是绝对路径,那么就是绝对路径,如果是相对路径,那么就是相对路径] String getPath(); // 获取File的路径[如果创建时是绝对路径,那么就是绝对路径,如果是相对路径,那么就是相对路径] boolean exists(); // 判断File是否存在 boolean delete(); // 删除文件或者文件夹 6-1. 文件是否可以直接被删除 6-1-1. 如果是空目录 - 直接删除 6-1-2 如果是非空目录 - 删除失败 - [可以通过递归算法来实现删除非空目录] boolean mkdir(); // 创建单层次的目录,一次只能创建一个目录 boolean mkdirs(); // 既可以创建单层次的目录,又可以同时创建多个不存在的目录 boolean isFile(); // 判断File实例是否为文件实例 boolean isDirectory(); // 判断File实例是否为文件夹实例 String[] list(); // 返回的是File的名称,返回的是传入的路径下的第一层内容弄 File[] listFiles(); // 返回第一层的File实例 File[] listFiles(FilenameFilter filter); // 找到指定后缀/前缀满足条件的这么一个File实例 创建文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package tech.aistar.day13;import java.io.File;import java.io.IOException;/** * @Author liuWenXiu * @Date 2021/8/5 16:33 * @description FileDemo */public class FileDemo &#123; public static void main(String[] args) &#123; createNewFile(&quot;src/tech/aistar/day13/temp.txt&quot;); &#125; /** * 创建新的文件 * @param path */ public static void createNewFile(String path)&#123; // 1. 构建File实例 File f = new File(path); // 2.判断f是否存在 if(f.exists())&#123; // 如果存在则打印提示并退出方法 System.out.println(f+&quot;已经存在啦&quot;); return; &#125; // 3.实现新的创建 // 调用createNewFile方法,需要抓取异常,并且调用该方法会返回一个布尔类型的值,表示是否创建成功 try &#123; if(f.createNewFile())&#123; // 1. 获取文件名称 System.out.println(&quot;文件名称:&quot;+f.getName()); // 2.获取名称绝对路径 System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath()); // 3.获取创建时的路径 System.out.println(&quot;创建时路径:&quot;+f.getPath()); // 4.获取文件的父目录 System.out.println(&quot;文件父目录:&quot;+f.getParent()); // 5.获取文件 System.out.println(&quot;文件:&quot;+f); &#125;else &#123; System.out.println(&quot;创建失败&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456结果:文件名称:temp.txt文件绝对路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\temp.txt创建时路径:src\\tech\\aistar\\day13\\temp.txt文件父目录:src\\tech\\aistar\\day13文件:src\\tech\\aistar\\day13\\temp.txt 123public static void main(String[] args) &#123; createNewFile(&quot;E:\\\\cxstudy\\\\workspace\\\\j03_student02\\\\src\\\\tech\\\\aistar\\\\day13\\\\qaq.txt&quot;);&#125; 123456结果:文件名称:qaq.txt文件绝对路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt创建时路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt文件父目录:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13文件:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt 删除文件/文件夹1234567891011121314151617181920public static void deleteFileOrFolder(String path)&#123; // 1.构建File实例 File f = new File(path); // 2.判断file是否存在 if(!f.exists())&#123; // 如果不存在则打印提示不存在 System.out.println(f+&quot;不存在!&quot;); return; &#125; // 3.删除文件 // 如果是空目录是可以直接删除的,如果是费空目录,则删除失败 // 调用delete方法 同样会返回一个布尔类型的结果 if(f.delete())&#123; System.out.println(f+&quot;删除成功!&quot;); &#125;else &#123; System.out.println(f+&quot;删除失败!&quot;); &#125;&#125; 创建文件夹版本一1234567891011121314151617public static void createFolder(String path)&#123; // 1.构建file实例 File f = new File(path); // 2.判断文件夹是否存在 if(f.exists())&#123; // 如果存在则打印实体并返回 System.out.println(f+&quot;已经存在啦!&quot;); return; &#125; // 3.创建文件夹 // 调用mkdir方法,返回一个布尔类型的值 if(f.mkdir())&#123; System.out.println(f+&quot;创建成功!&quot;); &#125;else&#123; System.out.println(f+&quot;创建失败&quot;); &#125;&#125; 版本二123456789101112131415public static void createFolder2(String path)&#123; // 1.构建File实例 File f = new File(path); // 2.判断是否存在 if(f.exists())&#123; System.out.println(f+&quot;已经存在啦&quot;); return; &#125; // 3.创建 if(f.mkdirs())&#123; System.out.println(f+&quot;创建成功&quot;); &#125;else&#123; System.out.println(f+&quot;创建失败&quot;); &#125;&#125; mkdir和mkdirs之间的区别是,mkdir只能创建一个目录,而mkdirs可以创建嵌套的目录. list方法 - 返回文件名称123456789101112131415161718public static void lists(String path)&#123; // 1.构建实例 File file = new File(path); // 2.判断是否存在 if(!file.exists())&#123; // 如果不存在则打印提示并返回 System.out.println(file+&quot;不存在!&quot;); return; &#125; // 3.list获取名称 String[] infos = file.list(); if(null!=infos &amp;&amp; infos.length&gt;0)&#123; // 需要进行判断,因为不能确保这个有数据 for (String s : infos) &#123; System.out.println(s); &#125; &#125;&#125; listFiles - 返回File对象12345678910111213141516File[] files = file.listFiles();if(null!= files &amp;&amp; files.length&gt;0)&#123; // 确保数据的有效性 // 遍历输出 for (File file1 : files) &#123; // System.out.println(file1); if(file1.isDirectory())&#123; // 如果是目录则输出绝对路径 System.out.println(file1.getAbsolutePath()); &#125; if(file1.isFile())&#123; // 如果是文件则输出文件名 System.out.println(file1.getName()); &#125; &#125;&#125; listFiles(FilenameFilter filter) - 返回指定后缀的文件步骤: 首先创建一个类实现FilenameFilter接口,该接口是一个函数式接口. 12345678910111213141516171819public class SuffixFilenameFilter implements FilenameFilter &#123; private String suffix; public SuffixFilenameFilter(String suffix) &#123; this.suffix = suffix; &#125; @Override public boolean accept(File dir, String name) &#123; // 在什么情况下返回true什么情况下返回false // dir表示的是父类的绝对路径 // name表示的是文件名 //System.out.println(dir+&quot;:&quot;+name); if (name.endsWith(suffix)) return true; return false; &#125;&#125; 面向接口编程,形参是FilenameFilter可以传入它的实现类 12345File[] files = f.listFiles(new SuffixFilenameFilter(&quot;.txt&quot;));// 获取以.txt为结尾的文件并打印其名称for (File file : files) &#123; System.out.println(file.getName());&#125; 练习 传入一个目录,输出这个目录下的所有内容.如果是文件,直接输出名称.如果是文件夹,输出绝对路径 12345678910111213141516171819202122232425262728/** * 递归获取某个路径下的所有文件 * @param path */public static void listAllFiles(String path)&#123; // 1.创建实例 File f = new File(path); // 指定出口 - 递归的出口是如果该路径是文件,则打印文件名称并返回 if(f.isFile())&#123; System.out.println(f.getName()); return; &#125; // 如果不是文件,那么就是目录,需要获取该目录的所有Files File[] files = f.listFiles(); // 判断合法性 if(null != files &amp;&amp; files.length&gt;0)&#123; // 遍历files,判断如果是文件则打印文件名,如果是目录则打印目录绝对路径并且递归调用 for (File file : files) &#123; if(file.isFile())&#123; System.out.println(file.getName()); &#125;else if(file.isDirectory())&#123; System.out.println(file.getAbsolutePath()); listAllFiles(file.getAbsolutePath()); &#125; &#125; &#125;&#125; 删除一个非空目录[递归] IO流流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式[数据在传输之前,需要进行转换,转换成无结构的字节/字符序列]进行有序的输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入(Input)输出(Output) 流可以想象成是数据传输的管道. 磁盘中数据加载/读入到内存中 - 输入 java内存中数据写出到磁盘中 - 输出 流的分类 按照流的方向 - 输入流和输出流 按照流的读取单位 字节流 - 按照单个字节单个字节进行读写文本文件或者二进制文件 字符流 - 按照单个字符进行读写,只能操作文本字符文件 按照流的功能 节点流 - 又称为基础流,具备真正操作文件的能力 拓展流 - 又称为过滤流或包装流,拓展流只能让流的功能更加强大而已,拓展流脱离了节点流的话,是不允许的.拓展流的使用必须要建立在节点流的基础之上. 字节流字节输入流java.io.InputStream[C] - 字符输入流的顶级的抽象的父类 java.io.FileInputStream[C] - 文件字节输入流,操作文件的读操作. - 典型的节点流 java.io.ObjectInputStream[C] - 操作对象类型的字节输入流 - 典型的包装流 java.io.FilterInputStream[C] - 过滤流 java.io.BufferedInputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DateInputStream[C] - 操作基本数据类型的字节输入流 InputStream常用方法 void close(); // 关闭流,流本身就是一个对象[占内存 - 昂贵的资源] abstract int read(); // 单个字节单个字节的读取,如果读不到,返回-1 int read(byte[] b); // 从输入流读取一些字节数,并将它们存储到缓冲区b 字节输出流java.io.OutputStream[C] - 字节输出流的顶级的抽象父类 java.io.FileOutputStream[C] - 文件字节输出流,操作文件的写操作 - 典型的节点流 java.io.ObjectOutputStream[C] - 操作对象类型的字节输出流 - 典型的包装流 java.io.FilterOutputStream[C] - 过滤流 java.io.BufferedOutputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DataOutputStream[C] - 操作基本数据类型的字节输出流 OutputStream常用方法 void close(); //关闭流 abstract void write(int b); // 将制定的字节写入此输出流 void write(byte[] b,int off,int len); IO流的编程步骤 确定流 - 选什么流 确定源头和目标 - 从哪里读,写到哪里去 循环读取,循环写出 - while 关闭流 缓冲流BufferedInputStream在它出来之前,可以单个单个字节进行读写操作,缺点是java程序和磁盘的IO交互比较频繁,性能就会低下. 采取了自定义的数组的方式,从磁盘文件中读取一定数量的字节先放入到缓冲数组中,然后再从缓冲数组中一次性写出道磁盘中,减少了java程序和磁盘IO的交互次数. - 性能提高 JDK中发现了这点,提供了缓冲流BufferedInputStream 123456789101112131415private static int DEFAULT_BUFFER_SIZE = 8192;//默认的容量8kbprotected volatile byte buf[];//内置的缓冲区public BufferedInputStream(InputStream in) &#123; this(in, DEFAULT_BUFFER_SIZE);&#125;public BufferedInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); &#125; buf = new byte[size];//初始化内置的缓冲区数组 - 大小是8kb&#125; 底层利用了”装饰器”思想,这个流属于包装流,拓展流,过滤流,本身不具备真正的文件的读写能力. 构建带缓冲功能的流,必须要以节点作为支持. 构建一个带缓冲功能的能够读取文件的字节输入流. 123BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;路径&quot;));BufferedOutputStream in = new BufferedOutputStream(new FileOutputStream(&quot;路径&quot;)); 缓冲数组BufferedInputStream本身已经在底层定义了8kb的字节数组,那么为什么程序中还自定义了一个3kb的字节数组[可以不定义,read()方法],自定义的byte[]和内置的byte[]各自的作用是什么? 内置的8kb的byte[] - 在一开始或者后面空闲的时候,由JVM去装载磁盘上的数据,提前放入到这个内置的byte[]中的. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/5 20:27 * @description 缓冲流 */public class BufferDemo &#123; public static void main(String[] args) &#123; BufferedInputStream in = null; BufferedOutputStream out = null;//out = new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy.gif&quot;); try &#123; in = new BufferedInputStream(new FileInputStream(&quot;src/tech/aistar/day13/fast.gif&quot;)); out = new BufferedOutputStream(new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy2.gif&quot;)); // 自定义一个byte[] byte[] buf = new byte[3*1024]; int len = -1; while (true)&#123; len = in.read(buf); if(len == -1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 读过程 当初始化好缓冲流之后,jvm会立刻读取磁盘中的数据到内置的缓冲数组中. 当程序循环读取到len = in.read(buf)时,程序是直接从内置的缓冲区[内置的缓冲数组中] 一旦内置的数组中的8kb数据被取完,那么jvm在空闲的时候,继续加载文件中下一个8kb的字节到内置的缓冲区. 语法糖jdk7.0提供的写法 - 把流的关闭交给jvm 12345try(资源对象的声明1;资源对象的声明2)&#123;&#125;catch(...)&#123; ...&#125; 123456789101112131415161718192021222324252627282930313233package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/5 20:37 * @description 语法糖 - jvm去关闭流 - 最终的版本 */public class StreamAutoCloseDemo &#123; public static void main(String[] args) &#123; try(BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;src/tech/aistar/day13/fast.gif&quot;)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy4.gif&quot;)))&#123; // 定义一个byte数组 byte[] buf = new byte[3*1024]; int len = -1; while (true)&#123; len = in.read(buf); if(len == -1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 证明语法糖是自动关闭对象12345678910111213141516public class ScannerDemo &#123; public static void main(String[] args) &#123; int result = get(); System.out.println(result); int x = get(); System.out.println(x); &#125; public static int get()&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.close(); return n; &#125;&#125; 12345public static int get()&#123; try(Scanner sc = new Scanner(System.in))&#123; return sc.nextInt(); &#125;&#125; 1234结果相同,都为如下:11Exception in thread &quot;main&quot; java.util.NoSuchElementException ObjectInputStream/ObjectOutputStream操作对象类型的字节输入流和字节输出流,拓展流,必须要以节点流作为支撑. 构建一个能够读写对象类型的文件字节输入流/输出流 12ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;path&quot;));ObjectOutputStream in = new ObjectOutputStream(new FileOutputStream(&quot;path&quot;)); 构建一个能够读写对象类型的并且带缓冲功能的文件字节输入流 12ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(&quot;path&quot;)));ObjectOutputStream in = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(&quot;path&quot;))); 利用”装饰器”思想,我们构建出功能更加强大的流,但是又不会对原来的流的结构产生任何影响. 序列化对象的序列化数据的持久化的过程,把内存中的java对象存储到磁盘的文件的过程. 注意点: 如果保存的是单个对象,这个对象的实体类必须要实现java.io.Serializable序列化接口. 如果没有实现这个接口,进行序列化的时候,抛出一个java.io.NotSerializableException不可被序列化的异常 保存的是数组/集合,那么集合中的每个对象对应的实体类也是需要实现这个序列化的接口. 关于追加写入,设置FileOutputStream(String path,boolean append);//append设置true,但是不支持分批次读取. 对象的反序列化java对象已经存储到磁盘的文件中,希望再从文件中将这些对象数据加载到内存中[映射到java对象上]. 字符流它和字节流的区别是读取的单位是不同的,字节流是按照单个字节进行读写操作. 字符流是按照单个字符的单位进行读写操作,字符流专门用来处理文本字符文件的,字节流用来处理文本文件或者二进制文件的. 字符输入流 java.io.Reader[C] - 顶级的字符输入流 - 抽象类 BufferedReader[C] - 带缓冲功能的字符流 123public BufferedReader(Reader in)&#123; this(in,defaultCharBufferSize);&#125; 提供的方法:String readLine(); // 每次读取文本文件一整行的数据 FileReader[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作 12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.day13;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * @Author liuWenXiu * @Date 2021/8/6 13:50 * @description 字符输入流 */public class ReaderHelloDemo &#123; public static void main(String[] args) &#123; /** * 步骤: * 1. 确定流 * 2. 确定源头 * 3. 循环读取 * 4. 关闭流 - 可以采用语法糖 - jvm自动关闭 */ try(BufferedReader in = new BufferedReader(new FileReader(&quot;src/tech/aistar/day13/book.java&quot;)))&#123; // 一行一行地读取 String line = null; // 循环读取 while (true)&#123; line = in.readLine(); // 读取一整行的数据,如果读取不到了,就返回null if(line == null) break; System.out.println(line); //注意这里不要忘记换行 &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字符输出流 java.io.Writer[C] - 顶级的字符输出流 - 抽象类 PrintWriter[C] - 自带缓存功能 构造方法: 12PrintWriter(Writer out);PrintWriter(Writer out,boolean autoFlush); 第二个参数是是否自动刷新缓存.缓存里面的数据被同步到磁盘上一般有两种情况,第一种是缓存中的数据满的时候回自动刷新,第二种是缓存中的数据还不足以撑满这个缓存但是使用了close方法或者flush方法手动刷新. FileWriter[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作的 构造方法: 12FileWriter(String path);FileWriter(String path,boolean append); 第二个参数代表的是是否追加写入.如果append设置为true,则可以支持分批次的写和分批次的读.而字节流不行,字节流可以追加写入,但不能读出来. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package tech.aistar.day13;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;/** * @Author liuWenXiu * @Date 2021/8/6 14:16 * @description 字符输出流 */public class WriteHelloDemo &#123; public static void main(String[] args) &#123; //test01(); test02(); &#125; /** * 构建一个不自动刷新,不能够追加写入的字符输出流 * 每次都会覆盖原来的文件,兵器而在第一次写入的时候,会自动创建这个文件 */ public static void test01()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;)))&#123; /** * 因为语法糖 - close操作 - 底层就是关闭流之前,会强制刷新缓存 */ /** * print方法以及println方法 * print方法写入之后,后面是没有加一个\\n * println方法写入之后,后面有一个\\n */ out.print(&quot;java很好玩&quot;); //out.println(&quot;python和好玩&quot;); //out.print(&quot;php很好玩!&quot;); // 把内存的数据持久化到硬盘的文件中 out.flush(); //可以不写,但是保险起见可以写一下 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 构建一个不能自动刷新,但是能够追加写入的字符流 */ public static void test02()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;,true)))&#123; out.print(&quot;hello&quot;); out.print(&quot;nice to meet&quot;); out.println(&quot;you&quot;); out.print(&quot;!&quot;); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void test03()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;,true),true))&#123; out.print(&quot;hello&quot;); out.print(&quot;nice to meet&quot;); out.println(&quot;you&quot;); out.print(&quot;!&quot;); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 文件的拷贝12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/6 14:58 * @description */public class FileCopyReaderDemo &#123; public static void main(String[] args) &#123; copyFile(&quot;src/tech/aistar/day13/hello.txt&quot;,&quot;src/tech/aistar/day13/hello_copy.txt&quot;); &#125; public static void copyFile(String src,String target)&#123; try(BufferedReader in = new BufferedReader(new FileReader(src)); PrintWriter out = new PrintWriter(new FileWriter(target),true))&#123; String line = null; while (true)&#123; line = in.readLine(); if(line == null) break; out.print(line); &#125; out.flush(); System.out.println(&quot;文件拷贝成功!&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结笔试 常见的字节流和字符流 装饰器的设计模式 难一点的知识点 - 同步[打电话]IO/异步[发短信]IO区别,阻塞IO/非阻塞IO区别 BufferedInputStream - 内置的缓冲数组 - 8kb 补充 - 破坏单例单例设计模式 - 保证在整个应用程序中,某个类的具体的实例永远只有1个 - 多线程下也是一个 - 双重锁检测 对象的序列化和反序列化可以破坏这种单例,如何破坏? 解决方案: 单例的第四个版本 - 枚举类型来实现单例模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.day13;import tech.aistar.design.singleton.version03.Singleton03;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/6 15:22 * @description 对象的序列化和反序列化会破坏单例 */public class ObjectSingletonDemo &#123; public static void main(String[] args) &#123; Singleton03 s1 = Singleton03.getInstance(); writeObject(s1,&quot;src/tech/aistar/day13/temp.txt&quot;); Singleton03 s2 = readObject(&quot;src/tech/aistar/day13/temp.txt&quot;); System.out.println(s1 == s2); &#125; public static void writeObject(Singleton03 s,String path)&#123; try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; // 写 out.writeObject(s); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Singleton03 readObject(String path)&#123; Singleton03 s = null; try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) &#123; // 读 s = (Singleton03) in.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://beautifulboyy/tags/IO%E6%B5%81/"},{"name":"序列化","slug":"序列化","permalink":"http://beautifulboyy/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"异常的处理","slug":"java10","date":"2021-08-04T06:20:14.000Z","updated":"2021-08-04T10:35:25.465Z","comments":true,"path":"2021/08/04/java10/","link":"","permalink":"http://beautifulboyy/2021/08/04/java10/","excerpt":"","text":"Throwablejava.lang.Throwable - 异常和错误的顶级的类 123456两个分支: 1. java.lang.Error - 错误 - 错误一旦发生,程序员是没有办法进行扭转的,不需要在代码中进行处理. 1-1. 子类VirtualMachineError虚拟机级别的错误 1-1-1. 子类java.lang.StackOverflowError 堆栈溢出 - 应用程序因为递归太深没有指定出口的时候. 1-1-2. 子类java.lang.OutOfMemoryError 内存泄露 - [GC垃圾回收机制 - 后台自动回收垃圾对象] 2. java.lang.Exception - 异常 - 程序在运行的过程中发生了不正常的情况 异常的分类运行时异常[RuntimeException]都是非运行时异常的子类[Exception] 运行时异常 - 未检测异常 顶级的父类java.lang.RuntimeException java.lang.NullPointerException - 空指针异常 12String str = null;System.out.println(str.length()); java.util.InputMismatchException - 输入不匹配异常 12Scanner sc = new Scanner(System.in);int n = sc.nextInt(); //只能获取整数,但是输入了一个字符串&quot;abc&quot; java.lang.ArithmeticException: - 分母为0 1System.out.println(10/0); java.lang.IllegalArgumentException - 非法参数异常 1SimpleDateFormat sdf = new SimpleDateFormat(&quot;ff&quot;); java.lang.IndexOutOfBoundsException - 下标越界异常 12List&lt;String&gt; list = new ArrayList&lt;&gt;();System.out.println(list.get(3)); 5.1 java.lang.StringIndexOutOfBoundsException - 字符串下标越界异常 12String str = &quot;faflfsfe&quot;;System.out.println(str.charAt(10)); 5.2 java.lang.ArrayIndexOutOfBoundsException - 数组下标越界异常 12int[] arr = &#123;1,3,5,7,9&#125;;System.out.println(arr[10]); java.util.NoSuchElementException - 不存在此元素 12LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;();System.out.println(list.getFirst()); java.lang.ClassCastException - 类型转换失败异常 12Animal c = new Cat(&quot;小喵&quot;,300.d);Dog dog = (Dog) c; 父类转换子类类型之前,推荐使用instanceof关键字进行类型的判断 非运行时异常 - 已检测异常 非运行时异常在编译时就能发现问题,需要用try…catch语句包裹. java.text.ParseException - 解析失败异常 - 字符串的模板和pattern不匹配 1234567SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);String str = &quot;2021-02-28&quot;;try &#123; Date date = sdf.parse(str);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125; InterruptedException - 中断异常 12345try &#123; Thread.sleep(3000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; java.lang.CloneNotSupportedException - 不支持clone 12345try &#123; Product copy = (Product) p1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 当Product实体类没有实现cloneable接口时就会出现这样的异常 java.io.IOException - IO流异常 4-1. java.io.EOFException - 已经读到文件的末尾了 4-2. java.io.FileNotFoundException - 文件找不到异常 java.sql.SQLException - SQL异常,比如程序中的sql语句写错了. 异常的处理方式 运行时异常不需要处理(也是可以处理的),只需要在编程的时候,注意一下验证/判断,稍微谨慎一点 非运行时异常,在编译期间就需要立即对其进行处理.处理的方式有两种,一种是积极处理,使用try…catch包围可能出现异常的语句,还有一种是消极处理. 积极处理方式 语法: try…catch…catch… 12345678try&#123; //code... //code...&#125;catch(异常类型1 e1)&#123; // code...&#125;cathc(异常类型2 e2)&#123; // code..&#125; 注意:上方的异常类型不能是下方的异常类型的父类 语法 - jdk7.0提供的新的写法 123456try&#123; //code... //code...&#125;catch(异常类型1 | 异常类型2)&#123; // code...&#125; 注意一下这里是非短路或. 语法 12345try&#123; //code..&#125;catch(异常总父类)&#123; //code..&#125; 消极处理比如在某个方法中某些代码出现了非运行时异常,那么在自己方法的内部”不着急”去积极处理.而是把这个异常抛出去了. 为了自己不处理,而是抛出去? - 因为这个方法有可能会被反复在其他地方调用 - 原则:谁调用,谁负责最终处理. 原则谨记 - 不要把异常抛给main方法,等同于把异常抛给jvm,等同于一旦出现异常,程序就会崩溃. 一个简单的实例 12345public void b() throws FileNotFoundException, ParseException &#123; InputStream in = new FileInputStream(&quot;d:\\\\sss&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date strDate = sdf.parse(&quot;2021-02-28&quot;);&#125; 直接在方法的签名[声明]上使用throws关键字+异常类型1,异常类型2 在方法体中使用throw+异常对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class NegativeHandlerException &#123; // 不要把异常抛给main方法 public static void main(String[] args) &#123; d(0); &#125; // c是最终的调用者 public void c()&#123; // 谁最终调用,谁最终进行处理 try &#123; a(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // 可以一直向上抛 public void a() throws FileNotFoundException&#123; try &#123; b(); //先处理一部分的异常,没有处理的可以继续抛出 &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; public void b() throws FileNotFoundException, ParseException &#123; InputStream in = new FileInputStream(&quot;d:\\\\sss&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date strDate = sdf.parse(&quot;2021-02-28&quot;); &#125; public static void d(int n)&#123; if(n==0)&#123; //System.out.println(&quot;异常...&quot;); /* throw + 运行时异常,不需要在方法的签名上抛出异常 因为本身运行时异常就不需要进行处理 */ throw new RuntimeException(&quot;发生异常啦&quot;); &#125; System.out.println(&quot;n:&quot;+n); &#125; public static void e(int n) throws FileNotFoundException &#123; if(n==0)&#123; /* throw + 非运行时异常 必须要在方法的签名上throws+非运行时异常类型 */ throw new FileNotFoundException(&quot;文件不存在!&quot;); &#125; System.out.println(&quot;n:&quot;+n); &#125;&#125; 自定义异常项目中存在一个exception包,专门定义自己的异常[大量的] jdk内置的异常不够用,不符合实际的业务场景 步骤 写一个异常类继承java.lang.Exception 提供父类的5个构造方法即可. 自定义异常的意义123System.out.println(&quot;余额小于0&quot;); throw new BalanceLtZeroException(&quot;余额小于0!&quot;); 场景:有的时候访问某些网站的时候 - 跳转到一个友好的页面 - 显示比如服务器正在维护/升级… 我们应该提供一个异常处理器 - 会监控软件程序在整个项目运行的过程中发生的一切异常. 一旦它发现了某个地方产生了异常,那么它就会对这些异常进行一个日志记录,然后再让程序跳转到一个友好的界面. SpringMVC/SpringBoot - 异常处理器 - 只认识异常. 相关笔试题1.笔试题1 123456789101112131415try&#123; // code // code return; // 结束整个方法&#125;catch(异常类型 e)&#123; // code&#125;catch(异常类型 e)&#123; // code&#125;finally&#123; // 无论是否出现异常,都会执行&#125;提问:假设try&#123;&#125;中没有任何异常发生,所有的code都会顺利执行.1.finally中的代码是否执行? - 一定会执行2.return语句是在finally块之前执行还是之后执行? - 之后执行 123456789String str = &quot;str&quot;;try &#123; System.out.println(str.length()); return;&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; System.out.println(&quot;-----end-----&quot;);&#125; 123结果:3-----end----- 2.笔试题2 123456789101112131415public class FinallyDemo &#123; public static void main(String[] args) &#123; System.out.println(test()); &#125; public static int test()&#123; int i = 0; // try可以直接和finally一起使用... try&#123; return ++i; &#125;finally &#123; ++i; System.out.println(&quot;i:&quot;+i); &#125; &#125;&#125; 结果: i:2 1 对待基本数据类型:在执行到return语句时,将i自增后的结果缓存起来了,并且这个缓存的结果就是作为最终返回出去的一个结果.然后执行finally中的语句,这时候finally中的修改不影响缓存中的数据,最后执行return语句. 123456789101112131415161718192021222324252627public class FinallyDemo &#123; public static void main(String[] args) &#123; System.out.println(change()); &#125; public static A change()&#123; A a = new A(); try&#123; a.age = 100; return a; &#125;finally &#123; a.age = 200; &#125; &#125;&#125;class A&#123; public int age = 19; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;A&#123;&quot;); sb.append(&quot;age=&quot;).append(age); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 结果:A{age=200} 对待对象类型:finally语句中修改对象的属性值时会影响return的结果 3.笔试题3 final和finally和finalize三者之间的区别? - 一点关系都没有 final a. 修饰的局部变量一旦赋值成功,不可改变. b.修饰的属性一旦赋值成功,不可改变 c.修饰的类不可被继承 d.修饰的方法不可被重写 finally a. 一般是和try.catch搭配使用的,try块中无论是否出现异常,finally块中的代码都会执行 b. finally块中一般写的是释放或者关闭资源的代码 finalize - Object类中提供的方法 a. 当GC想要去回收一个垃圾对象之前,会调用这个对象的finalize方法.这个是由jvm进行调用的. b. 该方法未必一定会调用得到. 4.throw和throws的区别 throw: 表示方法内抛出某种异常对象 如果异常对象是非RuntimeException则需要在方法申明时加上该异常的抛出,即需要加上throws语句或者在方法体内try…catch处理该异常,否则编译报错. 执行到throw语句则后面的语句块不再执行. throws: 方法的定义上使用throws表示这个方法可能抛出某种异常. 需要由方法的调用者进行异常处理.","categories":[],"tags":[{"name":"异常","slug":"异常","permalink":"http://beautifulboyy/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"零碎的知识点","slug":"java09","date":"2021-08-02T01:21:39.000Z","updated":"2021-08-06T03:28:48.155Z","comments":true,"path":"2021/08/02/java09/","link":"","permalink":"http://beautifulboyy/2021/08/02/java09/","excerpt":"","text":"SimpleDateFormat java.text.SimpleDateFormat - 日期格式处理类 它是一个线程不安全的类. 模板 Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, …, 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00 目标 Date类型转换成String类型 - 按照指定的日期格式 1234Date d = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss E&quot;);String strDate = sdf.format(d);System.out.println(strDate); 结果:2021-08-02 09:44:01 星期一 1234Date d = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;ff&quot;);String strDate = sdf.format(d);System.out.println(strDate); 结果:Exception in thread “main” java.lang.IllegalArgumentException: Illegal pattern character ‘f’ pattern必须是一个有效的格式化模板,如果传入了一个非法模板,就会抛出一个非法参数异常. String类型转成Date类型 12345678String birthday = &quot;2021-09-21&quot;;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);try &#123; Date dt = format.parse(birthday); System.out.println(&quot;Date:&quot;+dt);&#125; catch (ParseException e) &#123; e.printStackTrace(); //打印堆栈中的异常信息&#125; 结果:Date:Tue Sep 21 00:00:00 CST 2021 12345678String birthday = &quot;2021-09-21&quot;;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);try &#123; Date dt = format.parse(birthday); System.out.println(&quot;Date:&quot;+dt);&#125; catch (ParseException e) &#123; e.printStackTrace(); //打印堆栈中的异常信息&#125; 结果:java.text.ParseException: Unparseable date: “2021-09-21” 如果构造中的pattern的格式和日期的字符串格式不一致,在调用的时候回抛出解析失败异常. BigDecimalapi:java.math 构造方法 BigDecimal(double val); BigDecimal(String val); 常用方法 方法 含义 BigDecimal add(BigDecimal augend) 加 BigDecimal substract(BigDecimal subtrahend) 减 BigDecimal multiply(BigDecimal multiplicand) 乘 BigDecimal divide(BigDecimal divisor) 除 12345678910111213141516public class BigDecimalDemo &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal(9); BigDecimal d2 = new BigDecimal(3); // 加法运算 System.out.println(d1.add(d2)); //12 // 减法运算 System.out.println(d1.subtract(d2)); //6 // 乘法运算 System.out.println(d1.multiply(d2)); //27 // 除法运算 System.out.println(d1.divide(d2)); //3 &#125;&#125; 笔试题 - 在java开发中如何处理小数精度123456789101112public class BigDecimalHandleFloatDemo &#123; public static void main(String[] args) &#123; // BigDecimal的构造方法中有new BigDecimal(String) BigDecimal d1 = new BigDecimal(&quot;0.1&quot;); BigDecimal d2 = new BigDecimal(String.valueOf(&quot;0.2&quot;)); // 获取两个数相加的结果 BigDecimal result = d1.add(d2); // 相加的结果仍然是BigDecimal. 利用doubleValue获取result的double值 double resultDouble = result.doubleValue(); System.out.println(resultDouble); &#125;&#125; BigInteger笔试题 - 递归算法求阶层12345678public static BigInteger test(int n)&#123; if(n == 1) //return new BigInteger(&quot;1&quot;); return BigInteger.ONE; // 这个是上面那行代码的简写 BigInteger current = new BigInteger(String.valueOf(n)); return current.multiply(test(n-1));&#125; 四种内部类看懂别人写的内部类语法即可. 成员内部类 - 把内部类看成是外部类的一个成员 a. 成员内部类不能定义静态成员 b. 成员内部类中可以通过Outer.this.非静态属性名来访问外部类的非静态方法 c. 外部类.内部类 对象名 = 外部类对象.new 内部类(); 12345678910111213141516171819202122232425262728public class Outer &#123; private int id = 10; // 普通属性 private static int sid = 100; // 静态属性 // 1.成员内部类 - 把内部类看做成外部类的一个成员 public class MemberInner&#123; // 定义非静态属性 private int id = 20; private int age = 18; // 成员内部类不允许定义静态成员 // private static int sid = 200; public MemberInner()&#123; System.out.println(&quot;MemberInner...&quot;); &#125; // 自定义方法 public void test()&#123; System.out.println(&quot;内部类age:&quot;+age); System.out.println(&quot;内部类id:&quot;+id); System.out.println(&quot;外部类id:&quot;+Outer.this.id); System.out.println(&quot;外部类sid:&quot;+Outer.sid); &#125; &#125;&#125; 1234public static void main(String[] args) &#123; // 创建对象 Outer.MemberInner m = new Outer().new MemberInner();&#125; 静态内部类 - 把内部类看成是外部类的一个静态成员 a. 内部可以定义静态和非静态属性 b. 内部的普通方法中是不允许访问外部类的非静态属性的 c. 内部的普通方法中允许访问外部类的静态属性 d. 外部类.内部类 变量名 = new 外部类.静态类(); 1234567891011121314151617181920212223public class Outer &#123; private int id = 10; // 普通属性 private static int sid = 100; // 静态属性 public static class StaticMemberInner&#123; // 定义一个非静态属性 private int id = 20; // 定义一个静态属性 private static int sid = 299; public StaticMemberInner()&#123; System.out.println(&quot;StaticMemberInner&quot;); &#125; public void test()&#123; System.out.println(&quot;内部类-id:&quot;+this.id); System.out.println(&quot;内部类-sid:&quot;+sid); System.out.println(&quot;外部类-sid:&quot;+Outer.sid); // 静态类中访问不到外部类的非静态属性 &#125; &#125;&#125; 1Outer.StaticMemberInner s = new Outer.StaticMemberInner(); 局部内部类 - 内部类是出现在外部类的方法中 a. 内部类不允许使用访问修饰符,比如不能使用public b. 不能定义静态属性 c. 可以访问外部类的静态和非静态成员 d. 生命只在所在的方法中,方法外部是没有办法拿到这个对象的(不能直接在外部new) 123456789101112131415public void testLocalInner()&#123; class LocalInner&#123; public LocalInner()&#123; System.out.println(&quot;LocalInner()...&quot;); &#125; private int id = 10; public void test()&#123; System.out.println(&quot;内部类id:&quot;+id); System.out.println(&quot;外部类id:&quot;+id); System.out.println(&quot;外部类sid:&quot;+sid); &#125; &#125; LocalInner localInner = new LocalInner(); localInner.test();&#125; 匿名内部类 - 必须掌握 好处 - 我们可以在程序中少写实现类 jdk8.x中如果遇到函数式接口.推荐使用lambda表达式来替代匿名内部类的写法的. UMLUnified Modeling Language - 统一建模语言 BA - 需求分析师 powerndesigner starUML 掌握目标:看懂箭头即可 类与类之间由弱到强的关系是:没关系&lt;依赖&lt;关联&lt;聚合&lt;组合 依赖虚线 + 箭头 &lt;—– 简单理解:一个类A使用到了另一个类B.这种使用关系是具有偶然性的,临时性的,非常弱的. 12345678910public class A&#123; public void test(B b)&#123; // 自己的功能 // B类中的功能 b.test(); &#125;&#125;public class B&#123; &#125; 关联实线 + 箭头 &lt;- A类关联了B,A依赖于B 123456public class A&#123; private B b;&#125;public class B&#123; &#125; 组合属于关联的一种,强调的是整体和局部之间的关系,这种关系非常紧密,整体是可以决定局部的生命周期的. 箭头 + 实线 + 实心菱形 1234567891011public class Baby&#123; private Eye eye; private Hand hand; public Baby()&#123; this.eye = new Eye(); this.hand = new Hand(); &#125; public static void main(String[] args)&#123; Baby b = new Baby(); &#125;&#125; 聚合关系属于关联的一种 - 强调的是整体和局部的关系,这种关系较紧密.整体是可以不用决定局部的生命周期的 - 局部单独存在的 箭头 - 实线+空心菱形 123456public class Computer&#123; private Cpu cpu; public Computer(Cpu cpu)&#123; this.cpu = cpu; &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"DateFormat","slug":"DateFormat","permalink":"http://beautifulboyy/tags/DateFormat/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"http://beautifulboyy/tags/BigDecimal/"},{"name":"BigInteger","slug":"BigInteger","permalink":"http://beautifulboyy/tags/BigInteger/"},{"name":"内部类","slug":"内部类","permalink":"http://beautifulboyy/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"UML","slug":"UML","permalink":"http://beautifulboyy/tags/UML/"}]},{"title":"static关键字","slug":"java08","date":"2021-07-31T06:18:40.000Z","updated":"2021-08-02T02:14:57.322Z","comments":true,"path":"2021/07/31/java08/","link":"","permalink":"http://beautifulboyy/2021/07/31/java08/","excerpt":"","text":"static关键字 Static修饰的成员是在JVM加载类的时候就会被立刻分配空间以及初始化,这个过程只有一次,并且内存的实例也只有一份. 非静态的成员是在每次创建对象的时候才会被分配空间以及初始化. Static的作用 static修饰类 - 静态内部类[过] static修饰属性 - 静态属性 static修饰方法 - 静态方法 static修饰代码块 - 静态代码块 JVM加载类进入内存的活动顺序 JVM加载类进入内存 给所有的静态属性分配空间以及初始化 给所有的静态方法分配空间以及初始化 执行静态代码块 如果创建了对象 5-1.给这个对象的所有非静态属性分配空间以及初始化 5-2.给这个对象的所有非静态方法分配空间以及初始化 5-3.执行普通代码块 5-4.执行构造块 static关键字的应用设计模式 - 单例模式 static练习123456789101112131415161718192021222324public class StaticDemo &#123; // 普通属性 - 每次创建对象的时候才会被分配空间以及初始化 private int id = 10; // 静态属性 - static修饰的成员是在jvm加载类的时候就会被立即分配空间以及初始化 private static int sid = 100; // 构造方法 public StaticDemo()&#123; this.id = sid++; &#125; public int getId() &#123; return id; &#125; public static void main(String[] args) &#123; StaticDemo s1 = new StaticDemo(); System.out.println(s1.getId()); StaticDemo s2 = new StaticDemo(); System.out.println(s2.getId()); &#125;&#125; 结果: 100 101 12345678910111213141516171819202122232425262728293031public class StaticBlockDemo &#123; private int id = 10; private static int sid = 100; public StaticBlockDemo()&#123; System.out.println(&quot;构造方法&quot;); System.out.println(&quot;con-id:&quot;+id); System.out.println(&quot;con-sid&quot;+sid); &#125; // 普通代码块 - 每次创建对象的时候,都会执行 - 并且它的时机高于构造块 &#123; System.out.println(&quot;普通代码块&quot;); System.out.println(&quot;b-id&quot;+id); System.out.println(&quot;b-sid&quot;+sid); &#125; // 静态代码块 - jvm加载类进入内存的时候,立即调用静态代码 // 仅仅会执行一次,执行效率最高 static &#123; System.out.println(&quot;静态代码块&quot;); System.out.println(&quot;s-sid:&quot;+sid); &#125; public static void main(String[] args) &#123; StaticBlockDemo s1 = new StaticBlockDemo(); System.out.println(); StaticBlockDemo s2 = new StaticBlockDemo(); &#125;&#125; 结果: 静态代码块s-sid:100普通代码块b-id10b-sid100构造方法con-id:10con-sid100 普通代码块b-id10b-sid100构造方法con-id:10con-sid100 12345678910111213public class Cygnus&#123; static int value = 9; private void printValue()&#123; //局部变量不能使用对象去获取 int value = 69; System.out.println(this.value); &#125; public static void main(String[] args) throws Exception&#123; new Cygnus().printValue(); &#125;&#125; 这个程序会有下面哪种结果？A. 编译错误B. 打印9C. 打印69D. 运行时抛出异常 结果:B 1234567891011121314151617181920212223242526class Base&#123; static&#123; System.out.println(&quot;base static&quot;); &#125; public Base()&#123; System.out.println(&quot;base constructor&quot;); &#125;&#125;public class Test extends Base&#123; static&#123; System.out.println(&quot;test static&quot;); &#125; public Test()&#123; super(); System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 结果 base statictest staticbase constructortest constructor 12345678910111213public class Test &#123; static&#123; System.out.println(&quot;test static 1&quot;); &#125; public static void main(String[] args) &#123; &#125; static&#123; System.out.println(&quot;test static 2&quot;); &#125;&#125; 结果 test static 1test static 2 123456789101112131415public class test&#123; static&#123; int x=5; &#125; static int x,y; public static void main(String args[])&#123; x--; myMethod( ); System.out.println(x+y+ ++x); &#125; public static void myMethod( )&#123; y=x++ + ++x; &#125;&#125; A. 编译错误B. 输出：1C. 输出：2D. 输出：3E. 输出：7F. 输出：8 结果:D 12345678910111213141516171819202122class HelloA&#123; public HelloA() &#123; System.out.println(&quot;I’m A class &quot;); &#125; static&#123; System.out.println(&quot;static A&quot;); &#125;&#125;public class HelloB extends HelloA&#123; public HelloB()&#123; System.out.println(&quot;I’m B class&quot;); &#125; static&#123; System.out.println(&quot;static B&quot;); &#125; public static void main (String[] args)&#123; new HelloB(); &#125;&#125; A. static A I’m A class static B I’m B classB. I’m A class I’m B class static A static BC. static A static B I’m A class I’m B classD. I’m A class static A I’m B class static B 结果:C 12345678910111213141516public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println(&quot;构造块&quot;); &#125; static&#123; System.out.println(&quot;静态块&quot;); &#125; public static void main(String[] args)&#123; B t = new B(); &#125;&#125; A. 静态块 构造块 构造块 构造块B. 构造块 静态块 构造块 构造块C. 构造块 构造块 静态块 构造块D. 构造块 构造块 构造块 静态块 结果:D 12345678910111213141516171819class A &#123; public int func1(int a, int b) &#123; return a - b; &#125;&#125;class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125;&#125;public class ChildClass &#123; public static void main(String[] args) &#123; A a = new B(); B b = new B(); System.out.println(&quot;Result=&quot; + a.func1(100, 50)); System.out.println(&quot;Result=&quot; + b.func1(100, 50)); &#125;&#125; A. Result=150Result=150B. Result=100Result=100C. Result=100Result=150D. Result=150Result=100 结果:A 123456789101112131415public class Test&#123; public static Test t1 = new Test(); &#123; System.out.println(&quot;blockA&quot;); &#125; static&#123; System.out.println(&quot;blockB&quot;); &#125; public static void main(String[] args)&#123; Test t2 = new Test(); &#125; &#125; A. blockAblockBblockAB. blockAblockAblockBC. blockBblockBblockAD. blockBblockAblockB 结果:A","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"static","slug":"static","permalink":"http://beautifulboyy/tags/static/"}]},{"title":"String和StringBuilder的使用","slug":"java05","date":"2021-07-31T03:10:47.000Z","updated":"2021-07-31T12:11:25.569Z","comments":true,"path":"2021/07/31/java05/","link":"","permalink":"http://beautifulboyy/2021/07/31/java05/","excerpt":"","text":"Stringjava中提供的处理字符串的类 - java.lang.String 特点 字符串是不可变的 123String str = &quot;abc&quot;;str = &quot;eef&quot;;// 这里字符串&quot;abc&quot;是没有改变的,将str指向了&quot;eef&quot;,导致&quot;abc&quot;成了垃圾对象. 字符串的本质上就是一个字符数组 123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ //String s = &quot;abc&quot;; 会将&quot;abc&quot;打散,保存到value[]数组中. private final char value[];&#125; 1.String被final修饰,被final修饰的类不可以被继承-&gt;String不能被继承 2.final char value[],表示这个String维护的是不可变的字符数组 构建方式 通过new关键字来构建 1String s = new String(&quot;abc&quot;); 通过这个步骤,可能创建一个或两个对象. ①通过new关键字在堆里面创建了一个字符串对象”abc” ②同时查看”串池”里面有没有”abc”,如果没有,还需要在”串池”中再创建一个”abc”对象. 直接通过”串池”/“字符串常量池”的方法来构建 123String s2 = &quot;abc&quot;;String s3 = &quot;abc&quot;;System.out.println(s1 == s2); 构建s2这个字符串时,会在”串池”中创建一个”abc”对象,然后将地址给s2,构建s3字符串时,发现串池中已经有了”abc”对象,则直接将”abc”的地址返回给s3,所以上面判断的结果为true. 串池的特点:利用串池创建对象时优先到串池中查找是否已经存在该对象,如果有则直接返回地址,如果没有则在串池中创建对象. 拼接字符串的拼接使用的是”+”,它的拼接效率非常低 测试”+”和StringBuilder的append耗费时间的对比 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.day09;/** * @Author liuWenXiu * @Date 2021/7/27 17:45 * @description */public class StringPlusDemo &#123; public static void main(String[] args) &#123; test01(); test02(); &#125; public static void test01()&#123; // 获取当前时间的毫秒数 long t1 = System.currentTimeMillis(); String str = &quot;&quot;; for (int i = 0; i &lt; 100000; i++) &#123; str += i; &#125; // 获取拼接之后的时间的毫秒数 long t2 = System.currentTimeMillis(); System.out.println(&quot;str拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125; public static void test02()&#123; StringBuilder builder = new StringBuilder(); // 获取当前时间的毫秒数 long t1 = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; builder.append(i); //StringBuilder利用append()方法进行拼接 &#125; // 获取拼接之后的时间的毫秒数 long t2 = System.currentTimeMillis(); System.out.println(&quot;StringBuilder拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125; &#125; 123结果str拼接时间:39618msStringBuilder拼接时间:3ms 对比发现”+”的效率特别低. 拼接效率低的原因 “+”底层实现时每次拼接都会创建一个StringBuilder对象,每次创建需要耗费大量的时间. “+”底层仍然是调用StringBuilder的append方法. 关于字符串的测试12String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); 1&gt; javap -c HelloStr 1234567891011121314151617181920212223242526272829303132public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 2: astore_1 3: new #3 // class java/lang/String 6: dup 7: ldc #4 // String def 9: invokespecial #5 // Method java/lang/String.&quot;&lt;init&gt;&quot;: //(Ljava/lang/String;)V 12: astore_2 13: new #6 // class java/lang/StringBuilder //字符串每次拼接+,都会产生一个新的StringBuilder对象 16: dup 17: invokespecial #7 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V //StringBuilder builder = new StringBuilder(); 20: aload_1 21: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; //字符串的+,底层仍然是去调用StringBuilder类中提供的append方法 24: aload_2 25: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #9 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_1 32: return&#125; 在这个代码中,新创建的字符串是”def”,串池中没有,所以要新建,并且是#4.在代码中使用了”+”,对应上面的第13行,创建了StringBuilder对象,在17行进行初始化,21行调用StringBuilder的append方法实现字符串拼接. 比较 s1指向的是”abc”在堆中的地址,s2指向的是”abc”在串池中的地址. intern()强制让s1指向串池中的对象 1234String s1 = new String(&quot;abc&quot;);String s2 = &quot;abc&quot;;System.out.println(s1 == s2); //falseSystem.out.println(s1.intern() == s2); //true s3是一个变量,所以在拼接时,会创建StringBuilder对象,拼接后的结果是String对象,放在堆中,s5则是常量,放在串池中,因此不相等. 12345String s3 = &quot;b&quot;;String s4 = &quot;a&quot; + s3;String s5 = &quot;a&quot; + &quot;b&quot;;System.out.println(s4 == s5); //falseSystem.out.println(s4.intern() == s5); //true s6被final修饰,表示一个常量,所以结果和s5是一致的,都是变量池中的”ab” 123final String s6 = &quot;b&quot;;String s7 = &quot;a&quot; + s6;System.out.println(s5 == s7); //true 这个应该是最容易理解的,每次都新建了一个对象,这个对象和它的值是没有关系的,所以是false. 而**x1.equals(x2)**是用来判断两个字符串值是否相等. 1234String x1 = new String(&quot;abc&quot;);String x2 = new String(&quot;abc&quot;);System.out.println(x1 == x2); //falseSystem.out.println(x1.equals(x2)); //true 常用方法 方法 解释 str.charAt(index); 获取字符串中下标为index的字符 str.length 获取字符串的长度 str.concat(str1) 在原来字符串str的末尾添加新的字符串str1 str.contains(s) 判断字符串str中是否包含子串s str.endsWith(s) 判断字符串str是否以s字符串为结尾 str.startsWith(s) 判断字符串str是否以s字符串为开头 str.equals(str1) 判断字符串str与字符串str1的值是否相等 str.equalsIgnoreCase(str1) 判断字符串str与字符串str1的值是否相等[忽略大小写] str.toUpperCase() 将字符串str中的字符转换为大写 str.toLowerCase() 将字符串str中的字符转换为小写 str.indexOf(s) 返回字符串str中指定字符串s第一次出现的索引 str.lastIndexOf(s) 返回字符串str中指定字符串s最后一次出现的索引 str.isEmpty() 判断字符串是否为空 str.replace(s1,s2) 将字符串str中的所有s1字符串替换为s2字符串 String[] arr = str.split(i) 将字符串str按字符i分割成一个String数组 char[] arr = str.toCharArray() 将字符串转换为字符类型数组 str.substring(a,b) 截取字符串str中下标a到b-1的字符串[a,b) str.substring(a) 截取字符串str中下标a到最后一个字符 str.trim() 去除字符串str左右两边的空格 String s = String.valueOf(n) 将一个整型数n转换成String类型 StringBuilderjava.lang.StringBuilder - 一个可变的字符串 - final修饰,它是性能最高的,默认的容量16,线程不安全 构造方法 1StringBuilder s = new StringBuilder(); 1StringBuilder s2 = new StringBuilder(String str); 扩容机制研究append方法 - 底层代码 每次扩容都为原来长度*2+2 常用方法 方法 解释 str.delete(a,b) 删除字符串str中[a,b)的字符串 str.deleteCharAt(index) 删除字符串str下标为index的字符 str.insert(index,str1) 在字符串str指定下标index位置插入字符串str1 str.reverse() 将字符串str进行反转 注意:StringBuilder是可变的,所以在调用上述方法时不需要进行重新赋值也会改变. 总结类型转换 StringBuilder-&gt;String类型 java.lang.StringBuilder中提供的String toString(); java.lang.String类中提供的构造方法String(StringBuilder builder); java.lang.String类中提供的static String valueOf(Object obj); 面向父类编程 String-&gt;StringBuilder类型 java.lang.StringBuilder中提供的构造StringBuilder(String val); String,StringBuilder,StringBuffer的区别 三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点 不同点 2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的. 2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的. 2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String 方面 区别 可变与不可变 String类是不可变类,StringBuffer和StringBuilder是可变类 线程是否安全 String线程安全,StringBuffer线程安全,StringBuilder线程不安全 效率 String&lt;StringBuffer&lt;StringBuilder","categories":[{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://beautifulboyy/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"贪吃蛇的简单实现","slug":"java-project01","date":"2021-07-30T07:06:08.000Z","updated":"2021-08-01T10:45:26.578Z","comments":true,"path":"2021/07/30/java-project01/","link":"","permalink":"http://beautifulboyy/2021/07/30/java-project01/","excerpt":"","text":"贪吃蛇的简单实现 123456789101112131415161718思路:Point实体类,用于记录点对象.Snake实体类:用于记录这条蛇 定义四个静态常量用于记录蛇头前进的方向[增加代码可读性] 定义一个集合来存储蛇身体的每一个点对象,因为LinkedList集合可以快速找到头节点和尾节点,所以采用LinkedList集合. 定义一个属性,用来记录这个蛇下一次要向哪个方向行动[上下左右]. contains(x,y)方法:判断蛇的身体是否包含(x,y) judgeStep(int dir)方法:判断用户的输入方向是否正确,如果不正确[蛇下一次前进的方向不能与上一次前进的方向相反]抛出异常,正确的话为属性的方向进行赋值.SnakeGames实体类:用于实现这个游戏 定义两个静态常量属性表示游戏边界. 定义一个集合属性来存储食物的坐标,因为坐标是不可重复的,所以用Set集合. 定义一个Snake对象属性. init方法():随机生成食物的点 构造方法:调用init方法初始化集合属性,同时初始化Snake属性 step()方法:实现真正的前进功能.首先要获取蛇的头结点点对象,然后根据方向获得下一个要去的点的位置.判断下一个位置是不是合理的,如果这个位置是墙,则游戏结束,否则将这个位置设置成头结点,再判断这个节点是不是食物,如果是食物就不需要改变了,如果不是食物还需要删除蛇的尾节点. start方法():打印游戏界面,包括判断什么时候打印*[墙],0[食物],#[蛇身]StartGames类:测试类 主方法中接收用户输入并且调用SnakeGames中的start方法. Point实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package day11.snake;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/30 18:48 * @description */public class Point &#123; private int x; private int y; public Point() &#123; &#125; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Point point = (Point) o; return x == point.x &amp;&amp; y == point.y; &#125; @Override public int hashCode() &#123; return Objects.hash(x, y); &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Point&#123;&quot;); sb.append(&quot;x=&quot;).append(x); sb.append(&quot;, y=&quot;).append(y); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 泪目了!!!!忘记重写equals方法,找了半个多小时问题出在哪里,心痛. Snake实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package day11.snake;import java.util.LinkedList;/** * @Author liuWenXiu * @Date 2021/7/30 18:50 * @description 蛇 - 实体类 */public class Snake &#123; public static final int UP = -1; public static final int DOWN = 1; public static final int LEFT = -2; public static final int RIGHT = 2; private LinkedList&lt;Point&gt; snakes = new LinkedList&lt;&gt;(); private int dir; public Snake() &#123; snakes.add(new Point(5,8)); snakes.add(new Point(5,9)); snakes.add(new Point(5,10)); snakes.add(new Point(5,11)); dir = LEFT; &#125; public LinkedList&lt;Point&gt; getSnake() &#123; return snakes; &#125; public void setSnake(LinkedList&lt;Point&gt; snake) &#123; this.snakes = snake; &#125; public int getDir() &#123; return dir; &#125; public void setDir(int dir) &#123; this.dir = dir; &#125; /** * 判断LinkedList集合中是否包含(x,y)点对应的Point对象 * @param x * @param y * @return */ public boolean contains(int x,int y)&#123; return this.snakes.contains(new Point(x,y)); &#125; /** * 判断用户输入的方向是否合法 * @param dir */ public void judgeStep(int dir)&#123; if(this.dir + dir == 0)&#123; // 相加等于0表示前一次的方向和下一次的正好相反 // 抛出异常 throw new RuntimeException(&quot;对不起,方向相反,游戏结束.&quot;); &#125; // 否则给dir赋值 this.dir = dir; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Snake&#123;&quot;); sb.append(&quot;snake=&quot;).append(snakes); sb.append(&quot;, dir=&quot;).append(dir); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; SnakeGames实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package day11.snake;import java.util.HashSet;import java.util.LinkedList;import java.util.Set;/** * @Author liuWenXiu * @Date 2021/7/30 18:55 * @description 游戏实体类 */public class SnakeGames &#123; // 游戏的边界 public static final int ROWS = 20; public static final int COLS = 20; // 存储食物坐标的集合 private Set&lt;Point&gt; foods = new HashSet&lt;&gt;(); private Snake snake; public SnakeGames()&#123; snake = new Snake(); init(5); &#125; /** * 初始化set集合 * @param n 食物的个数 */ public void init(int n)&#123; while (true)&#123; // 随机数 int x = (int) (Math.random()*(ROWS-2)+1); int y = (int) (Math.random()*(COLS-2)+1); foods.add(new Point(x,y)); // 如果食物的坐标在蛇身上也是不可以的. if(snake.contains(x,y))&#123; continue; &#125; if(foods.size()==n) return; &#125; &#125; public void step(int dir)&#123; snake.judgeStep(dir); //1.获取蛇的头结点 Point header = snake.getSnake().getFirst(); int x = header.getX(); int y = header.getY(); //2.根据方向获得下一个点对象的坐标 switch (snake.getDir())&#123; case Snake.UP: x--; break; case Snake.DOWN: x++; break; case Snake.LEFT: y--; break; case Snake.RIGHT: y++; break; &#125; // 3.判断坐标是否合法 if(x==0 || y==0 || x==ROWS-1 || y==COLS-1) throw new RuntimeException(&quot;对不起,撞墙了,游戏结束&quot;); // 4.创建新的点对象 Point p = new Point(x,y); // 5.将新的点对象设置为snake的头结点 snake.getSnake().addFirst(p); // 6.判断吃掉的这个是不是食物 if(foods.remove(p))&#123; // 如果可以删除,则表示吃的是食物 return; &#125; // 如果不能删除,表示吃的不是食物,需要将蛇的尾节点去掉. snake.getSnake().removeLast(); &#125; public void start()&#123; for (int i = 0; i &lt; ROWS ; i++) &#123; for (int j = 0; j &lt; COLS ; j++) &#123; if(i==0 || j==0 || i==ROWS-1 || j==COLS-1)&#123; // 打印游戏的边界 System.out.printf(&quot;%2s&quot;,&quot;*&quot;); &#125;else if(snake.contains(i,j))&#123; // 打印蛇的身体 System.out.printf(&quot;%2s&quot;,&quot;#&quot;); &#125;else if(foods.contains(new Point(i,j)))&#123; // 打印食物 System.out.printf(&quot;%2s&quot;,&quot;0&quot;); &#125;else &#123; // 打印空白 System.out.printf(&quot;%2s&quot;,&quot;&quot;); &#125; &#125; System.out.println(); &#125; &#125;&#125; StartGames123456789101112131415161718192021222324252627282930313233343536373839package day11.snake;import java.util.Scanner;/** * @Author liuWenXiu * @Date 2021/7/30 19:21 * @description 测试类 */public class StartGames &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); SnakeGames games = new SnakeGames(); while (true)&#123; games.start(); System.out.print(&quot;上w下s左a右d-&gt;&quot;); String dir = sc.nextLine(); switch (dir)&#123; case &quot;w&quot;: games.step(Snake.UP); break; case &quot;s&quot;: games.step(Snake.DOWN); break; case &quot;a&quot;: games.step(Snake.LEFT); break; case &quot;d&quot;: games.step(Snake.RIGHT); break; default: System.out.println(&quot;输入错误,请重试!&quot;); break; &#125; &#125; &#125;&#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://beautifulboyy/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://beautifulboyy/tags/java/"}]},{"title":"集合框架","slug":"java04","date":"2021-07-29T02:36:18.000Z","updated":"2021-08-02T02:14:22.198Z","comments":true,"path":"2021/07/29/java04/","link":"","permalink":"http://beautifulboyy/2021/07/29/java04/","excerpt":"","text":"集合框架内存中的”容器对象” - 存储数据的,开发中来替代数组的使用. 结构123456789101112131415api:java.utilCollection[I] - List[I] - 有序可重复 - ArrayList[C] - LinkedList[C] - Vector[C] - Set[I] - 无序不可重复 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复的. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I]特点 - 有序并且是可以重复的. E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray();//将集合转换成数组. ArrayList[C]特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低. 分析源码 123456789101112private static final int DEFAULT_CAPACITY = 10; //默认的初始容量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //一个空数组transient Object[] elementData; // 真正存储数据的数组private int size; // 集合的大小// 构造public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //构造时初始化elementData &#125; add方法 123456789101112public boolean add(E e) &#123; //第一次:size=0; 执行ensureCapacityInternal(1); //第二次:size=1; 执行ensureCapacityInternal(2); //第十一次:size=10; 执行ensureCapacityInternal(11); ensureCapacityInternal(size + 1); //第一次:elementData[0++] = e; size=1 //第二次:elementData[1++] = e; size=2 //第十一次:elementData[10++] = e; size=11 elementData[size++] = e; return true;&#125; ensureCapacityInternal(); 123456789101112131415private void ensureCapacityInternal(int minCapacity) &#123; //第一次:在构造时进行了初始化,所以if之后的判断为true //第二次:在grow方法中elementData已经重新指向了新的数组,所以结果是false,跳过该if //第十一次:仍旧是跳过 //这个if只有在第一次add的时候是true if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 第一次:minCapacity = Math.max(10,1); =&gt; minCapacity=10 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //第一次:ensureExplicitCapacity(10); //第二次:ensureExplicitCapacity(2); //第十一次:ensureExplicitCapacity(11); ensureExplicitCapacity(minCapacity);&#125; ensureExplicitCapacity(minCapacity); 1234567891011private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 第一次:minCapacity = 10,elementData.length=0;10-0&gt;0的结果是true // 第二次:minCapacity = 2,elementData.length=10;2-10&gt;0的结果是false,跳过该if,返回add方法 // 第十一次:minCapacity = 11,elementData.length=10;11-0&gt;0的结果是true if (minCapacity - elementData.length &gt; 0) // 第一次:执行grow(10); // 第十一次:执行grow(11); grow(minCapacity);&#125; grow(minCapacity);每次扩容都增加原来长度的一半 12345678910111213141516private void grow(int minCapacity) &#123; // 第一次:oldCapacity=0,newCapacity=0; // 第十一次:oldCapacity=10,newCapacity=15; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5倍 // 第一次:0-10&lt;0 true // 第十一次:15-11&lt;0 false if (newCapacity - minCapacity &lt; 0) // 第一次:newCapacity = 10; newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 第一次:进行扩容,新的数组长度为newCapacity=10; // 第十一次:进行扩容,新的数组长度为newCapacity=15; elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历12345ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Hello&quot;);list.add(&quot;Java&quot;);list.add(&quot;oracle&quot;);list.add(&quot;php&quot;); 直接输出 123for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i)+&quot;\\t&quot;);&#125; 增强for循环 - 只读 1只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常 123for (String s : list) &#123; System.out.print(s+&quot;\\t&quot;);&#125; 迭代器 - 很重要 12345Iterator&lt;String&gt; iter = list.iterator();while(iter.hasNext())&#123; String s = iter.next(); System.out.print(s+&quot;\\t&quot;);&#125; 匿名内部类 123456list.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.print(s+&quot;\\t&quot;); &#125;&#125;); lambda表达式 1list.forEach(s -&gt; System.out.print(s+&quot;\\t&quot;)); LinkedList的遍历方法和ArrayList一样. 常用方法 方法 含义 list.add() 添加元素 list.clear() 清空元素 list.remove(index) 按下标删除集合中的元素 list.remove(o) 按元素删除集合中的元素 list.isEmpty() 判断集合是否为空 list.contains(o) 判断集合中是否包含某个元素 list.indexOf(o) 返回某个元素在集合中第一次出现的位置,如果不存在返回-1 list.size() 获取集合的大小 list.get(index) 获取集合中指定下标的值 适用于ArrayList和LinkedList. LinkedList[C]有序的序列,底层的数据双向链表,jdk6以及之前是双向循环链表 链表结构的特点:查询效率很低,每次都会从头节点开始遍历.但是增删效率高,只会涉及到相邻节点的移动. 链表结构相对于数组这种数据结构,需要占用更多的内存.每个节点除了保存具体的数据,还需要保存相邻节点的地址. 单向链表 head - 头节点 tail - 尾节点 element - 节点中真正的保存的数据 next - 下一个节点的地址 单向循环链表 尾节点的next又指向了头节点. 双向链表 - LinkedList底层数据结构 增加了一个pre - 保存的是上一个节点的地址. 双向循环链表 剖析源码1234567891011121314151617//节点类 -&gt; 有三个属性:分别元素,上一个节点对象以及下一个节点对象private static class Node&lt;E&gt; &#123; E item; //元素 Node&lt;E&gt; next; //next的值是下一个节点对象的地址 Node&lt;E&gt; prev; //prev的值是上一个节点对象的地址 // 构造方法 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;transient Node&lt;E&gt; first; //定义了头节点transient Node&lt;E&gt; last; //定义了尾节点 add方法1234public boolean add(E e) &#123; linkLast(e); return true;&#125; 12345678910111213141516void linkLast(E e) &#123; //1.创建节点对象l指向尾节点 final Node&lt;E&gt; l = last; //2.创建节点对象newNode,这个是新创建的节点对象 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //3.将尾节点指向新的节点对象[每次创建新的节点对象,尾节点都变成新的对象] last = newNode; if (l == null) //如果l为空-&gt;之前的尾节点为空-&gt;是第一次创建-&gt;表示链表之前没有任何的元素 first = newNode; // 于是把新的节点作为头节点 else // 如果l不为空-&gt;表示链表不为空,则将之前链表中的尾节点的next指向新的节点 l.next = newNode; size++; //长度++ modCount++;&#125; get方法1234public E get(int index) &#123; checkElementIndex(index); //用于检测元素下标-&gt;可以暂时不用在意 return node(index).item;&#125; 1234567891011121314151617181920212223242526// 获取指定下标的节点Node&lt;E&gt; node(int index) &#123; // size&gt;&gt;1 的含义就是size/2 // 判断index是在[0,size/2)之间还是在[size/2,size)之间 if (index &lt; (size &gt;&gt; 1)) &#123; // 如果index在[0,size/2)之间,则从头节点开始查询 Node&lt;E&gt; x = first; // 获取头节点 // 查找的步骤是从头节点开始一个一个向后取 for (int i = 0; i &lt; index; i++) x = x.next; //假设index=3; //i=0时,x = first.next -&gt; 第二个节点 i++ //i=1时,x -&gt; 第三个节点 i++ //i=2时,x -&gt; 第四个节点 i++(不符合条件,退出) return x; //这时候就返回第四个节点 &#125; else &#123; // 如果index在[size/2,size)之间,则从尾节点开始查询 Node&lt;E&gt; x = last; // 获取尾节点 for (int i = size - 1; i &gt; index; i--) x = x.prev; // 假设index = 7,size = 10 // i = 9时,x = last.prev -&gt; 倒数第二个节点(第九个节点) i-- // i = 8时,x -&gt; 倒数第三个节点(第八个节点) i-- 此时i=7,不符合循环条件,退出循环 return x; //返回第八个节点 &#125;&#125; remove方法123456public E remove(int index) &#123; checkElementIndex(index); // 这里首先node(index)找到下标对应的Node对象 // 然后通过unlink(Node对象)删除对象 return unlink(node(index));&#125; 1234567891011121314151617181920212223242526E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 常用方法 方法 含义 list.addFirst(o) 在头部添加某个元素 list.addLast(o) 在尾部添加某个元素 list.push(o) 把元素压入栈顶[即添加到头部] list.pop() 弹出栈顶元素并返回. list.removeFirst() 删除第一个元素 list.removeLast() 删除最后一个元素 list.getFirst() 获取第一个元素 list.getLast() 获取最后一个元素 offer,offerFirst,offerLast方法和add方法一样. 一个小题目括号匹配,如果是{[()]},{}等匹配成功,{[)}匹配失败. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package day11.homework;import java.util.LinkedList;/** * @Author liuWenXiu * @Date 2021/7/29 10:57 * @description 括号匹配 */public class BracketMatching &#123; /** * 括号的匹配 * @param c1 * @param c2 * @return */ public static boolean match(char c1,char c2)&#123; boolean flag = false; if(c1 == &#x27;&#123;&#x27; &amp;&amp; c2 == &#x27;&#125;&#x27;) flag = true; else if(c1 == &#x27;[&#x27; &amp;&amp; c2 == &#x27;]&#x27;) flag = true; else if(c1 == &#x27;(&#x27; &amp;&amp; c2 == &#x27;)&#x27;) flag = true; return flag; &#125; /** * * @param str * @return */ public static boolean bracketMatching(String str)&#123; char[] arr = str.toCharArray(); LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); list.push(arr[0]); for (int i = 1; i &lt; arr.length; i++) &#123; //!!!!!!!!这里真的要注意一下!!!!!!!!!!!!!-&gt;没有考虑到这种情况 // 为了避免在栈顶已经没有元素的情况下还去获取栈顶元素,非空判断 if(list.isEmpty())&#123; list.push(arr[i]); continue; &#125; if(match(list.getFirst(),arr[i]))&#123; // 匹配就出栈 list.pop(); &#125;else&#123; // 不匹配就入栈 list.push(arr[i]); &#125; &#125; return list.isEmpty(); &#125; public static void main(String[] args) &#123; String str = &quot;&#123;&#125;[]()&quot;; System.out.println(bracketMatching(str)); &#125;&#125; 这里一定要注意在取出栈顶元素的时候,首先需要判断这个集合中是否还有元素. Map[I]HashMap[C]数据存储的形式是key-value,针对key是无序不可重复的. jdk8.x之前,底层的数据结构是桶数组+链表 jd8.0开始,底层的数据结构是桶数组+链表+红黑树 桶(哈希桶)数组 - 里面的元素放在数组的这个位置是通过一个哈希算法计算得到的. 图示 剖析put方法 put方法 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; putVal方法 12345678910111213141516171819202122232425262728293031323334353637383940414243final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 常用方法 方法 含义 map.size() 获取集合大小 map.put(k,v) 添加元素,键为k,值为v map.get(k) 获取键key对应的值 map.clear() 清空集合 map.isEmpty() 判断集合是否为空 map.containsKey(k) 判断集合中是否包含某个key map.keySet() 将map集合中所有的key全部取出来放到一个set集合中 map.entrySet() 将map集合中的每对key-value封装到内置的Entry对象中 map.containsValue(v) 判断集合中是否包含某个value Map集合的迭代方式1234567891011121314151617181920212223// 第一种方式:将map集合中所有的key全部取出来放入到set集合中Set&lt;Integer&gt; sets = maps.keySet();// 遍历set集合Iterator&lt;Integer&gt; inter = sets.iterator();while(inter.hasNext())&#123; Integer key = inter.next(); String value = maps.get(key); System.out.println(key+&quot;:&quot;+value);&#125;System.out.println();// 第二种方式// 将map集合中的每对key-value封装到内置的entry对象中// 然后将每个entry对象放到set集合中Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter = entries.iterator();while(iter.hasNext())&#123; Map.Entry&lt;Integer,String&gt; entry = iter.next(); Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+&quot;-&gt;&quot;+value);&#125; HashSetSet[I]接口下的实现类 - 存储的数据是无序,不可重复的. 添加数据到容器的原理 当把对象添加到容器中之前,会调用对象的hashCode方法,得到一个哈希值. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用,那么就可以直接将这个对象放入到这个容器中的这个位置. 如果这个哈希值在这之前出现过了,产生了哈希碰撞或哈希冲突.但这个时候还不能确定哈希碰撞的两个对象是同一个对象 继续调用对象的equals方法,如果返回true,说明是同一个对象,则拒绝添加. 底层数据结构桶数组 + 链表 + 红黑树 查看HashSet源码 Set sets = new HashSet&lt;&gt;(); 1234public HashSet() &#123;//HashSet的底层是HashMapmap = new HashMap&lt;&gt;();&#125; add方法底层 123456789private static final Object PRESENT = new Object();//此处的e是添加到容器中的对象public boolean add(E e) &#123;//实际上还是在调用map的put方法//HashSet中添加的对象是作为了Map集合的key//Map的key具有什么特点 = HashSet中的数据有何特点.return map.put(e, PRESENT)==null;&#125; TreeSetSet[I] - SortedSet[I] - TreeSet[C] - 不可重复的,但是可以排序. 特点TreeSet在添加元素时,假设排序的规则定好,比如根据price进行排序,那么被添加到容器的这些对象的price就不能一样,一旦存在price相同的对象,就会拒绝添加. 123456789101112131415161718public class ComparatorFactory &#123; public static final int ISBN = 0; public static final int PRICE = 1; public static Comparator&lt;Book&gt; getInstance(int type)&#123; Comparator&lt;Book&gt; c = null; switch (type)&#123; case ISBN: c = (b1,b2)-&gt;b2.getIsbn().compareTo(b1.getIsbn()); break; case PRICE: c = (b1,b2)-&gt; (int) (b2.getPrice()-b1.getPrice()); break; &#125; return c; &#125;&#125; 123456789101112131415// 获取按照price进行排序的比较器Comparator c = CompareFactoryDemo.getInstance(CompareFactoryDemo.PRICE);TreeSet&lt;Book&gt; books = new TreeSet&lt;&gt;(c); //注意一下这里的构造Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d);Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d);Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d);Book b4 = new Book(2,&quot;1004&quot;,&quot;python&quot;,300.0d);books.add(b1);books.add(b2);books.add(b3);books.add(b4);books.forEach(e-&gt; System.out.println(e)); 1234结果Book&#123;id=2, isbn=&#x27;1004&#x27;, name=&#x27;python&#x27;, price=300.0&#125;Book&#123;id=2, isbn=&#x27;1002&#x27;, name=&#x27;java&#x27;, price=200.0&#125;Book&#123;id=1, isbn=&#x27;1001&#x27;, name=&#x27;java&#x27;, price=100.0&#125; 如果构造中没有指明Comparator,就会报java.lang.ClassCastException异常. 排序比较器接口Comparatorjdk8.0开始,在List接口中已经定义了排序的方法 void sort(Comparator&lt;? superE&gt; c) Book实体类 - 省略构造,getter/setter方法/toString方法 123456public class Book &#123; private int id; private String isBn; private String name; private double price;&#125; 测试类 12345678910Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d);Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d);Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d);Book b4 = new Book(4,&quot;1004&quot;,&quot;python&quot;,300.0d);List&lt;Book&gt; bookList = new ArrayList&lt;&gt;();bookList.add(b1);bookList.add(b2);bookList.add(b3);bookList.add(b4); 根据价格降序排序,使用匿名内部类方式 12345678910bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; if(o1.getPrice()&gt;o2.getPrice()) return -1; else if(o1.getPrice()&lt;o2.getPrice()) return 1; return 0; &#125;&#125;); 简化一下 123456bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; return (int) o2.getPrice() - o1.getPrice(); &#125;&#125;); 在排序时,如果符合要求则返回-1,不符合就返回1,相等返回0. 根据价格升序排序,使用lambda表达式 1234567bookList.sort((o1,o2) -&gt; &#123; if(o1.getPrice()&gt;o2.getPrice()) return 1; else if(o1.getPrice()&lt;o2.getPrice()) return -1; return 0;&#125;); 简化 1bookList.sort((o1,o2) -&gt; (int) (o1.getPrice()-o2.getPrice())); 根据编号降序排序,使用lambda表达式 1bookList.sort((o1,o2) -&gt; o2.getIsBn().compareTo(o1.getIsBn())); 因为String类中重写了compareTo方法,所以字符串可以通过compareTo进行比较 根据价格升排序,如果价格一样,按照编号升序继续排序,使用匿名内部类. 12345678910bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; if(o1.getPrice()&gt;o2.getPrice()) return 1; else if(o1.getPrice()&lt;o2.getPrice()) return -1; else return o1.getIsBn().compareTo(o2.getIsBn()); &#125;&#125;); Collectionsjava.util.Collections[C] - 集合工具类 面试题 - Collection和Collections有什么区别? Teacher类 - 省略构造,getter/setter方法/toString方法 12345public class Teacher &#123; private int id; private String name; private int age;&#125; Teacher测试类 12345678910Teacher t1 = new Teacher(1,&quot;tom&quot;,23);Teacher t2 = new Teacher(2,&quot;jack&quot;,25);Teacher t3 = new Teacher(3,&quot;james&quot;,18);Teacher t4 = new Teacher(4,&quot;rose&quot;,17);List&lt;Teacher&gt; list = new ArrayList&lt;&gt;();list.add(t1);list.add(t2);list.add(t3);list.add(t4); 要求:按照老师的年龄增序排序 static void sort(List list, Comparator&lt;? super T&gt; c)根据指定的比较器引起的顺序对指定的列表进行排序。 123456789// 匿名内部类Collections.sort(list, new Comparator&lt;Teacher&gt;() &#123; @Override public int compare(Teacher o1, Teacher o2) &#123; return o1.getAge()-o2.getAge(); &#125;&#125;);// lambda表达式Collections.sort(list,(o1,o2) -&gt; o1.getAge()-o2.getAge()); static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list) ;//集合中的对象必须要实现java.lang.Comparable可比较接口 修改Teacher类,实现Comparable接口,并重写compareTo方法 12345678910public class Teacher implements Comparable&lt;Teacher&gt;&#123; private int id; private String name; private int age; @Override public int compareTo(Teacher o) &#123; return this.getAge()-o.getAge(); &#125;&#125; 测试类 1Collections.sort(list); 如果在Teacher类中没有实现接口,这里的语法就会报错. 面试题HashMap 和 HashTable 区别 HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下: HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。","categories":[{"name":"框架","slug":"框架","permalink":"http://beautifulboyy/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"集合框架","slug":"集合框架","permalink":"http://beautifulboyy/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"设计模式","slug":"java-design","date":"2021-07-27T12:46:54.000Z","updated":"2021-08-04T13:28:19.658Z","comments":true,"path":"2021/07/27/java-design/","link":"","permalink":"http://beautifulboyy/2021/07/27/java-design/","excerpt":"","text":"模板方法设计模式抽象类应用 - 模板方法设计模式 模板方法模式很常用,其目的是在一个方法中定义一个算法骨架,而将一些步骤延迟到子类中.模板方法使得子类可以在不改变算法接口的情况下,重新定义算法的某些步骤. 在标准的模板方法模式实现中,主要是使用继承的方式,来让父类在运行期间可以调用到子类的方法. -&gt;处理某个流程的代码已经都具备,但是其中某个节点的代码暂时不能确定.处理步骤在父类中定义好,具体实现延迟到子类中定义 模板类中只负责定义: 需要做的事情 - 不需要具体的实现,具体的实现留给各个子类去实现. 做事情的流程[步骤] 一个小实例,可以参考理解 TemplateDemo.java 1234567891011121314public abstract class TemplateDemo &#123; //规定了需要完成的事情 public abstract void start(); //演员登台 public abstract void play(); //演员表演 public abstract void end(); //落幕 //提供一个不可变的方法,用来控制事情执行的顺序 public final void execute()&#123; this.start(); this.play(); this.end(); &#125;&#125; YueYueImpl.java 1234567891011121314151617181920212223package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:17 * @description 继承TemplateDemo类并且实现里面的抽象方法 */public class YueYueImpl extends TemplateDemo &#123; @Override public void start() &#123; System.out.println(&quot;小岳岳登场!&quot;); &#125; @Override public void play() &#123; System.out.println(&quot;小岳岳讲相声&quot;); &#125; @Override public void end() &#123; System.out.println(&quot;小岳岳离场&quot;); &#125;&#125; DeGangImpl.java 123456789101112131415161718192021222324package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:58 * @description 继承TemplateDemo类并且实现里面的抽象方法 */public class DeGangImpl extends TemplateDemo &#123; @Override public void start() &#123; System.out.println(&quot;郭德纲登场..&quot;); &#125; @Override public void play() &#123; System.out.println(&quot;郭德纲在讲相声&quot;); &#125; @Override public void end() &#123; System.out.println(&quot;郭德纲退场...&quot;); &#125;&#125; TestTemplate 12345678910111213141516171819202122232425262728package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:18 * @description 测试 */public class TestTemplate &#123; public static void main(String[] args) &#123; TemplateDemo t = new YueYueImpl(); //t.execute(); TemplateDemo t2 = new DeGangImpl(); TemplateDemo[] ts = &#123;t,t2&#125;; for (TemplateDemo demo : ts) &#123; demo.execute(); &#125; &#125;&#125;结果:小岳岳登场!小岳岳讲相声小岳岳离场郭德纲登场..郭德纲在讲相声郭德纲退场... 这个就是模板方法设计模式,不管是DeGangImpl还是YueYueImpl都是遵循一个顺序,分别是start()-&gt;play()-&gt;end();但是这些方法的具体实现是在子类中实现的. 模板方法设计模式的优缺点 优点 模板方法提供了一个很好的代码复用平台. 实现了反向控制,通过一个父类调用其子类的操作,通过对子类的具体实现扩展不同的行为,实现了反向控制,符合”开闭原则”. 缺点 每一个不同的实现都需要一个子类来实现,导致类的个数增加,使得系统更加庞大.结合实例来理解,每一个相声演员都需要一个新的子类来实现,这样就会导致类的数量很多. 单例模式如何保证某个类的对象在内存中永远只有一份,某些类的创建和销毁的时间成本比较高,这些类有必要设计成单例的.比如jdbc中的连接池对象[重量级的对象] 饿汉模式 - 多线程安全 私有化构造方法 初始化一个静态变量,该变量就是该类唯一的一个实例. 提供一个公开的静态方法来返回这个实例 123456789public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉模式 - 多线程不安全 私有化构造方法 创建一个静态变量,但不进行初始化,该变量就是该类唯一的实例 提供一个公开的静态方法,在方法中初始化该实例并返回. 1234567891011public static Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null) instance = new Singleton(); return instance; &#125;&#125; 双重检查锁 - 多线程安全 私有化构造方法 创建一个静态变量,但不进行初始化,该变量就是该类唯一的实例 123456789101112131415161718192021222324252627public static Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; //因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁,所以此处也要进行非空判断. if(instance == null)&#123; //跑得快的线程都会进入此处A,B //A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入 //同步代码块去执行里面的代码 //假设A线程抢到了,B就会在等待 synchronized (Singleton03.class)&#123; //A进入判断instance==null //只要抢到&quot;锁&quot;的线程,如果此处没有非null判断 //那么进入到这的线程都会去执行instance = new Singleton03(); if(instance == null)&#123; //由A线程进行实例的初始化 //A继续执行,等A执行完毕之后,那么A就会释放锁资源 //其他线程继续争抢锁资源. instance = new Singleton03(); &#125; &#125; &#125; return instance;&#125; volatile 可见性[忽略] 禁止JVM的指令重排 123456789101112int i = 10; //这是一个原子性的操作Student s = new Student(); //这不是一个原则性的操作 /*它需要经过三个过程:①给s对象分配内存空间②调用构造块,执行构造函数 - 初始化③将引用s指向内存中的那个对象但是JVM内部会对这些指令进行一个优化操作.本来顺序是①-&gt;②-&gt;③,经过JVM指令重排之后,顺序有可能变成①-&gt;③-&gt;②*/ 12345678910111213public class Singleton&#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; &#125;&#125; 工厂模式简单工厂模式 123456789101112131415public class interface Sender&#123; void send();&#125;public class QQSender implements Sender&#123; @override public void send()&#123; System.out.println(&quot;QQSend...&quot;) &#125;&#125; public class WXSender implements Sender&#123; @override public void send()&#123; System.out.println(&quot;WXSend...&quot;) &#125;&#125; 简单工厂模式必须要脱手写出来 123456789101112131415161718public class ProductFactory&#123; public static final int QQ = 1; public static final int WX = 2; public static Sender getInstance(int type)&#123; swtich(type)&#123; case 1: return new QQSender(); break; case 2: return new WXSender(); break; default: System.out.println(&quot;输入错误!&quot;); break; &#125; &#125;&#125; 多方法简单工厂 12345678public class ProductFactory&#123; public Sender produceQQ()&#123; return new QQSender(); &#125; public Sender produceWX()&#123; return new WXSender(); &#125;&#125; 静态方法简单工厂12345678public class ProductFactory&#123; public static Sender produceQQ()&#123; return new QQSender(); &#125; public static Sender produceWX()&#123; return new WXSender(); &#125;&#125; 简单工厂优缺点优点： 很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。所以简单工厂有一个别名：上帝类。 缺点： 任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大 在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。 工厂方法模式 123456789101112131415161718192021222324public interface ProductFactory&#123; Sender createSender();&#125;public class QQProductFactory implements PrductFactory&#123; @Override public Sender createSender() &#123; return new QQSender(); &#125;&#125;public class WXProductFactory implements ProductFactory&#123; @Override public Sender createSender() &#123; return new WXSender(); &#125;&#125;public class TestProductFactory &#123; public static void main(String[] args) &#123; Sender qq = new QQProductFactory().createSender(); Sender wx = new WXProductFactory().createSender(); qq.send(); wx.send(); &#125;&#125; 工厂方法模式优缺点优点： 工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产；（对应简单工厂的缺点1） 同时增加某一类”东西“并不需要修改工厂类，只需要添加生产这类”东西“的工厂即可，使得工厂类符合开闭原则。 缺点： 相比简单工厂，实现略复杂。 对于某些可以形成产品族的情况处理比较复杂（相对抽象工厂）。 抽象工厂模式 123456789101112131415161718192021222324252627282930public interface Cpu &#123; void info();&#125;public interface Net &#123; void info();&#125;public class IBMCpu implements Cpu&#123; @Override public void info() &#123; System.out.println(&quot;IBMPCpu...&quot;); &#125;&#125;public class IntelCpu implements Cpu&#123; @Override public void info() &#123; System.out.println(&quot;IntelCpu...&quot;); &#125;&#125;public class InternetNet implements Net&#123; @Override public void info() &#123; System.out.println(&quot;InternetNet...&quot;); &#125;&#125;public class GaoTongNet implements Net&#123; @Override public void info() &#123; System.out.println(&quot;GaoTongNet...&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public interface ProductFactory &#123; Cpu createCpu(); Net createNet();&#125;public class XiaoMiFactory implements ProductFactory&#123; @Override public Cpu createCpu() &#123; return new IBMCpu(); &#125; @Override public Net createNet() &#123; return new InternetNet(); &#125;&#125;public class PhoneXFactory implements ProductFactory&#123; @Override public Cpu createCpu() &#123; return new IntelCpu(); &#125; @Override public Net createNet() &#123; return new GaoTongNet(); &#125;&#125;public class TestFactory &#123; public static void main(String[] args) &#123; ProductFactory pf = new XiaoMiFactory(); Cpu cpu = pf.createCpu(); Net net = pf.createNet(); cpu.info(); net.info(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"包装类型","slug":"java03","date":"2021-07-27T08:50:47.000Z","updated":"2021-08-02T02:13:28.900Z","comments":true,"path":"2021/07/27/java03/","link":"","permalink":"http://beautifulboyy/2021/07/27/java03/","excerpt":"","text":"包装类型每个基本类型都有其对应的包装类型[对象类型] 基本类型 包装类型[对象类型] byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 学习掌握目标 包装类型的api常用方法 包装类型和基本数据类型以及String类型三者之间的相互转换问题 Numberjava.lang.Number - 所有关于上面包装类型[数字]的共同的抽象的父类 byte byteValue()返回指定号码作为值 byte ，这可能涉及舍入或截断。 abstract double doubleValue()返回指定数字的值为 double ，可能涉及四舍五入。 abstract float floatValue()返回指定数字的值为 float ，可能涉及四舍五入。 abstract int intValue()返回指定号码作为值 int ，这可能涉及舍入或截断。 abstract long longValue()返回指定数字的值为 long ，可能涉及四舍五入或截断。 short shortValue()返回指定号码作为值 short ，这可能涉及舍入或截断。 提供的这些方法都是关于包装类型转换成对应的基本类型的方法 Integer构造 Integer(int i);//利用int类型的整数来构建一个Integer对象 - int类型-&gt;Integer类型 Integer(String s);//此处的字符串一定是数字形式的字符串 - String类型-&gt;Integer类型 如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 自动解封箱jdk5.x开始支持的新的功能 封箱 - 基本数据类型可以自动转换成对应的包装类型 解箱 - 包装类型可以自动转换成对应的基本的数据类型 常用方法 static Integer valueOf(int i); int类型-&gt;Integer类型 如果int类型的数在**[-128,127]**之间,就直接返回内部的缓冲数组中的数据,如果不在这个范围,会返回一个新的Integer对象.因为在Integer类中有一个个静态内部类IntegerCache,在它里面有一个缓冲区,提供了缓冲数组,数组在静态代码块中进行预初始化,提前赋值了. 1234567891011121314151617181920212223//如果[-128,127]之间,那么直接返回内部的缓冲数组中的数据//如果不在这个范围,返回一个新的Integer对象public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;Integer类内部有一个静态内部类private static class IntegerCache &#123; static final int low = -128; static final int high; //缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了. static final Integer cache[]; static&#123; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; &#125; 关于进制的转换 2-1. static String toBinaryString(int n);//十进制n转换成对应的二进制 2-2. static String toHexString(int n);//十进制n转换成对应的十六进制 2-3. static String toOctalString(int n);//十进制n转换成对应的八进制 static int parseInt(String s);//将数字形式的字符串转换成int类型,如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 static Integer valueOf(String s);//String-&gt;Integer 包装类型和基本数据类型以及String类型三者之间的相互转换问题 int-&gt;Integer 123456//1.构造方法new Integer(int n)Integer t1 = new Integer(12);//2.Integer提供的静态方法valueOfInteger t2 = Integer.valueOf(12);//3.自动封箱Integer t3 = 12; Integer-&gt;int 1234//1.Number提供的方法intValueint n1 = t1.intValue();//2.自动解箱int n2 = t1; int-&gt;String 12//String提供的静态方法valueOfString str = String.valueOf(n1); String-&gt;int 12//Integer提供的静态方法paseIntint n3 = Integer.pareInt(str); String-&gt;Integer 1234//1.构造方法Integer t4 = new Integer(str);//2.Integer的静态方法valueOfInteger t5 = Integer.valueOf(str); Integer-&gt;String 1234//1.String提供的toString方法String str1 = t4.toString();//2.String提供的静态valueOfString str2 = String.valueOf(t4); 总结 Integer.valueOf()可以将int/String转换为Integer对象 String.valueOf()可以将int/Integer转换为String对象 new Integer()可以将int/String转换为Integer对象 int和Integer之间的区别 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。 泛型不支持int，但是支持Integer int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。 判断题123456789101112131415161718192021222324Integer i = new Integer(12);Integer j = new Integer(&quot;12&quot;);Integer o = new Integer(12);System.out.println(i==o);System.out.println(i==j);Integer i1 = Integer.valueOf(12);Integer i2 = Integer.valueOf(&quot;12&quot;);System.out.println(i1==i2);Integer i3 = Integer.valueOf(300);Integer i4 = Integer.valueOf(&quot;300&quot;);System.out.println(i3 == i4);Integer i5 = Integer.valueOf(128);Integer i6 = Integer.valueOf(128);System.out.println(i5 == i6);Integer i7 = new Integer(&quot;10&quot;);Integer i8 = Integer.valueOf(10);int i9 = 10;System.out.println(i7 == i9);System.out.println(i8 == i9);System.out.println(i7 == i8); Objectjava.lang.Object类是所有的类的基类,根类,超类 所有的类如果没有明确指定父类,都会默认继承Object类. equal方法页内认可的一种说法 - 基本类型用==比较的是值,对象类型用==比较的是地址 boolean equals(Object obj); 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 默认的比较方式不符合实际的业务需要,因此需要重写equals方法 一个小实例[注意观察equal方法的重写] Product.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package tech.aistar.day10.obj;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/28 11:01 * @description */public class Product &#123; private Integer id; private String name; private Double price; private ProductInfo info; public Product() &#123; &#125; public Product(Integer id, String name, Double price) &#123; this.id = id; this.name = name; this.price = price; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; public ProductInfo getInfo() &#123; return info; &#125; public void setInfo(ProductInfo info) &#123; this.info = info; &#125; @Override public boolean equals(Object obj)&#123; //1.非空性 if(obj == null) return false; //2.自反性 if(this == obj) return true; //3.一致类型,判断具体的哪个属性是一致的,才认为返回true if(obj instanceof Product)&#123; Product p = (Product) obj; return this.id == p.id &amp;&amp; this.getInfo().equals(p.getInfo()); &#125; return false; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Product&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&quot;, price=&quot;).append(price); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; ProductInfo.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 11:06 * @description */public class ProductInfo &#123; private Integer id; private String info; public ProductInfo() &#123; &#125; public ProductInfo(Integer id, String info) &#123; this.id = id; this.info = info; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; /** * 重写父类的equals方法,判断id相等时equals为真 * @param obj * @return */ @Override public boolean equals(Object obj)&#123; // 1.非空性 if(null == obj) return false; // 2.自反性 if(this == obj) return true; // 3.一致性判断,判断具体的哪个属性是一致的,才认为是返回true if(obj instanceof ProductInfo)&#123; // 强制转换 ProductInfo pf = (ProductInfo) obj; return this.id == pf.id; &#125; return false; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;ProductInfo&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, info=&#x27;&quot;).append(info).append(&#x27;\\&#x27;&#x27;); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; TestProduct.java 1234567891011121314151617181920212223package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 11:11 * @description equals方法的测试类 */public class TestProduct &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac2&quot;,10000.0d); ProductInfo info1 = new ProductInfo(1,&quot;好产品&quot;); p1.setInfo(info1); Product p2 = new Product(1,&quot;mac&quot;,20000.0d); ProductInfo info2 = new ProductInfo(1,&quot;坏产品&quot;); p2.setInfo(info2); boolean flag = p1.equals(p2); System.out.println(p1.equals(p2));//true System.out.println(p1 == p2);//false &#125;&#125; hashCode方法int hashCode(); 用于返回对象的哈希值,一般是和equals方法成对出现的,目的是为了提高效率 容器应用中 - 在什么时候才会去调用equals方法? - 当哈希碰撞的时候,只要哈希不冲突,不会调用equals方法 而调用equals方法执行的时机肯定会慢一点的.因为它需要比较属性值[需要更多的时间] 一个小实例 Course.java 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.day10.hashcodes;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/28 19:58 * @description */public class Course &#123; private Integer id; private String name; @Override public boolean equals(Object o) &#123; System.out.println(&quot;equals..&quot;); if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Course course = (Course) o; return Objects.equals(id, course.id); &#125; @Override public int hashCode() &#123; System.out.println(&quot;hash...&quot;); return Objects.hash(id); &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Course&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; TestCourse.java 123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.day10.hashcodes;import java.util.HashSet;import java.util.Objects;import java.util.Set;/** * @Author liuWenXiu * @Date 2021/7/28 19:58 * @description */public class TestCourse &#123; public static void main(String[] args) &#123; Course c1 = new Course(1,&quot;java&quot;); Course c2 = new Course(2,&quot;mysql&quot;); Course c3 = new Course(3,&quot;php&quot;); Course c4 = new Course(4,&quot;c#&quot;); Course c5 = new Course(5,&quot;c++&quot;); Course c6 = new Course(6,&quot;python&quot;); Course c7 = new Course(1,&quot;oracle&quot;);// System.out.println(c1==c2); //false;// System.out.println(c1.equals(c7));//true // 集合 - &quot;容器&quot; 比数组更加强大 Set&lt;Course&gt; sets = new HashSet&lt;&gt;(); sets.add(c1); sets.add(c2); sets.add(c3); sets.add(c4); sets.add(c7); for (Course c : sets) &#123; System.out.println(c); &#125; &#125;&#125; 运行结果 12345678910hash...hash...hash...hash...hash...equals..Course&#123;id=1, name=&#x27;java&#x27;&#125;Course&#123;id=2, name=&#x27;mysql&#x27;&#125;Course&#123;id=3, name=&#x27;php&#x27;&#125;Course&#123;id=4, name=&#x27;c#&#x27;&#125; 总结 如果两个对象hashcode值一样,将会使用equals进行比较,不一定返回true 如果两个对象equals返回true,那么这两个对象的哈希值一定是一样的. - 数据的完整性 笔试题 == 和equals的区别 ==基本类型使用,比较的就是基本类型的数值 equals对象类型使用,如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true. clone方法protected Object clone(); //默认的克隆方法是浅克隆 浅克隆浅拷贝,浅层复制,浅复制 - 默认的 直接生成的clone方法 1234@Overrideprotected Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; 要对其进行修改,将protected修改成public 123456@Overridepublic Object clone() throws CloneNotSupportedException &#123;return super.clone();&#125;Object中的clone方法 - native修饰的方法 - 本地方法栈中的方法 - C写的 - Java语言本地调用C程序.protected native Object clone() throws CloneNotSupportedException; clone方法的使用**:只有实现了java.lang.Cloneable接口[标记接口]的对象才能够调用clone方法,否则会抛出java.lang.CloneNotSupportedException不支持克隆的异常.** 12345try &#123; Product copy = (Product) p1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 关于clone的测试实例 1234567891011121314151617181920212223242526272829303132package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 20:14 * @description */public class TestCloneDemo &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac&quot;,1000.0d); ProductInfo info = new ProductInfo(1,&quot;good&quot;); p1.setInfo(info); // 浅拷贝 try &#123; Product copy = (Product) p1.clone(); // 1. 修改基本类型/String类型 p1.setId(2); p1.setName(&quot;Sakura&quot;); // 2.修改对象类型 p1.getInfo().setId(3); p1.getInfo().setInfo(&quot;bad&quot;); System.out.println(copy); System.out.println(copy.getInfo()); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果: 12Product&#123;id=1, name=&#x27;mac&#x27;, price=1000.0&#125;ProductInfo&#123;id=3, info=&#x27;bad&#x27;&#125; 浅拷贝:修改原来对象的基本数据类型以及字符串不会对拷贝的新对象产生影响,修改原来对象的对象类型数据会对拷贝的新对象产生影响 深克隆深层复制,深拷贝,深复制 - 需要自己重写clone里面的具体的代码的 12345678910111213141516171819 @Override public Object clone() throws CloneNotSupportedException &#123;// return super.clone(); // 手动创建一个Product对象 Product pf = new Product(); pf.setId(this.id); pf.setName(this.name); pf.setPrice(this.price); ProductInfo info = pf.getInfo(); //! 注意这里首先要判断info是否为空,因为info有可能还没有被赋值 if(info!=null)&#123; ProductInfo pi = new ProductInfo(); pi.setId(info.getId()); pi.setInfo(info.getInfo()); // 最后为pf设置 pf.setInfo(pi); &#125; return pf; &#125; 深拷贝每次都创建一个新的对象,所以是很消耗时间的.","categories":[],"tags":[{"name":"Integer","slug":"Integer","permalink":"http://beautifulboyy/tags/Integer/"},{"name":"深拷贝浅拷贝","slug":"深拷贝浅拷贝","permalink":"http://beautifulboyy/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"Date和Calendar的使用","slug":"java02","date":"2021-07-25T08:50:47.000Z","updated":"2021-08-02T02:12:35.376Z","comments":true,"path":"2021/07/25/java02/","link":"","permalink":"http://beautifulboyy/2021/07/25/java02/","excerpt":"","text":"Date api:java.util.Date[C] - 使用这个类之前,必须要导包import 这是java中提供的关于日期的处理,内置的对象类型.它本身是一个过时的类 里面提供了很多已经过时的方法. 目标:掌握这个类中提供的方法 构造方法构造方法 - 创建这个类的对象的方式 在使用api时首先观察该类提供的方法是静态的还是动态的,发现Date类中提供的方法几乎都是非静态的,所以必须创建该类的对象从而调用方法. 构造方法通过new关键字调用 1234567891011121314151617// 方法1:空参构造函数Date d = new Date(); //这个Date指的是当前的时间// 打印这个日期对象System.out.println(d); //结果:Wed Jul 21 18:50:26 CST 2021// 方法2:重载的构造方法[有参构造方法] - 已经过时,不再使用// 以下代码表示创建日期为2021年7月21日// 年份需要减去1900 月份需要-1Date d2 = new Date(2021-1900,6,21);System.out.println(d2); //结果:Wed Jul 21 00:00:00 CST 2021// 方法3:利用毫秒数[时间戳]来构建一个Date对象// 毫秒数表示距离1970经过那么多毫秒到现在的时间// 注意:毫秒数的类型是long型的Date d3 = new Date(1626828910303L);System.out.println(d3); //结果:Wed Jul 21 08:55:10 CST 2021 一个小练习:计算三天之后的此时此刻 1234567// 首先获取当前时间Date date = new Date();// 获取当前毫秒数并且加上三天的毫秒数long time = date.getTime() + 3L*24*60*60*1000;Date threeDayAfter = new Date(time);System.out.println(date); //结果:Wed Jul 21 19:00:03 CST 2021System.out.println(threeDayAfter); //结果:Sat Jul 24 19:00:03 CST 2021 常用方法由api知方法几乎都是非静态方法,需要**日期对象.方法名()**进行调用 long getTime();返回当前日期的毫秒数的表现形式 获取当前系统时间的毫秒数.距离1970年1月1日 123// 我们可以通过设置毫秒数来构建Date对象,当然也可以通过Date对象获取毫秒数long nowTime = d.getTime(); //获取当前时间的时间戳System.out.println(nowTime); //结果:1626865041991 get/set方法 - 过时的 void setYear(int year); //year-1900 void setMonth(int month); //month的范围[0,11] void setDate(int date); //设置今天是几号 void setHours(int hours); //设置小时 void setMinutes(int minutes); //设置分钟 void setSeconds(int seconds); //设置秒钟 12345678910111213System.out.println(&quot;------------Date对象的set方法---------------&quot;);Date now = new Date();now.setYear(2020-1900); //设置年份为2020年now.setMonth(5); //设置月份为6月now.setDate(25); //设置日期为25日System.out.println(now); //结果:Thu Jun 25 19:02:19 CST 2020System.out.println(&quot;------------Date对象的get方法---------------&quot;);System.out.println(&quot;year:&quot;+(now.getYear()+1900));System.out.println(&quot;month:&quot;+(now.getMonth()+1));System.out.println(&quot;date:&quot;+now.getDate());System.out.println(&quot;day:&quot;+now.getDay()); //星期几 [周一,周六]=[1,6] 周日为0System.out.println(&quot;hours:&quot;+now.getHours()); setTime()方法,通过设置毫秒数重新设置Date 1234// 利用setTime(毫秒数)设置DateDate dd = new Date();dd.setTime(1726830007794L);System.out.println(dd); //结果为:Fri Sep 20 19:00:07 CST 2024 Calendarjava.util.Calendar是一个抽象类,它不能被new 常用方法 static Calendar getInstance(); 12// 获取当前系统的日历对象Calendar cal = Calendar.getInstance(); //底层使用到了简单工厂的设计模式 设置日历字段 12345678void set(int year, int month, int date)设置日历字段中的值 YEAR ， MONTH和 DAY_OF_MONTH 。void set(int year, int month, int date, int hourOfDay, int minute)设置日历字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY和 MINUTE 。void set(int year, int month, int date, int hourOfDay, int minute, int second)设置字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY ， MINUTE和 SECOND 。 单独针对单个字段一一进行赋值 12345void set(int field,int value);只要看到field//公开的静态的常量属性public static final int YEAR = 1; 获取日历字段 123Date getTime();//获取日历信息中关于日期部分的信息 - Calendar转成Date类型int get(int field);//关于获取日历指定字段的值 123456789101112131415//Calendar.YEAR -&gt; 年份System.out.println(cal.get(Calendar.YEAR));// 这样就可以获取到年份是2021年// 增加程序的可读性// Calendar.DATE -&gt; 获取日期System.out.println(cal.get(Calendar.DATE));// Calendar.DAY_OF_MONTH -&gt; 获取日期[一个月之中的第几天]System.out.println(cal.get(Calendar.DAY_OF_MONTH));// 上面两个域都是一样的,都是5,所以他俩表示的是同一个意思// Calendar.DAY_OF_WEEK -&gt; 一周中的第几天 [周日,周六]-[1,7]System.out.println(cal.get(Calendar.DAY_OF_WEEK));// Calendar.MONTH -&gt; 获取月份 [0,11]System.out.println(cal.get(Calendar.MONTH)); 总结 毫米数 -&gt; Date Date提供的构造方法 1Date d1 = new Date(1626869108538L); Date提供的setTime(long 毫秒数)方法 1d1.setTime(1726869108538L); Date -&gt; 毫米数 Date提供的getTime()方法 1long l = d1.getTime(); Calendar -&gt; Date Calendar提供的getTime()方法 12Calendar cal = Calendar.getInstance();Date d2 = cal.getTime(); Date -&gt; Calendar Calendar提供的setTime(Date d)方法 1cal.setTime(d1); 一个综合练习题给定一个年份和月份,在idea控制台输出该日历,形式如下 相关api:java.util.Date和java.util.Calendar 123456789请您输入年份:2021请您输入月份:7 2021年7月日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package tech.aistar.day05;import tech.aistar.util.DateUtil;import java.util.Calendar;import java.util.Scanner;/** * @Author liuWenXiu * @Date 2021/7/21 19:07 * @description 打印日历 */public class PrintCalendar &#123; public static void main(String[] args) &#123; // 根据题意分析: // 1.首先获取键盘输入的年份和月份 Scanner sc = new Scanner(System.in); System.out.print(&quot;请您输入年份:&quot;); int year = sc.nextInt(); System.out.print(&quot;请您输入月份:&quot;); int month = sc.nextInt(); // 2.根据年份和月份打印日历 print(year,month); &#125; /** * 根据年份和月份打印日历 * @param year * @param month */ public static void print(int year,int month)&#123; // 1.判断键盘输入的合法性 // 1.1 year是否合法,如果year&lt;0,则不合法 if(year&lt;0)&#123; System.out.println(&quot;年份不合法!&quot;); return; &#125; // 1.2 month是否合法,如果month&lt;0或month&gt;12,则不合法 if(month&lt;0 || month&gt;12)&#123; System.out.println(&quot;月份不合法!&quot;); return; &#125; // 2.打印日历中的标题 例如2021年7月 System.out.println(&quot;\\t\\t&quot;+year+&quot;年&quot;+month+&quot;月&quot;); // 3.打印日历中的星期 System.out.println(&quot;日\\t一\\t二\\t三\\t四\\t五\\t六&quot;); // 4.确定某年某月的1号是周几 int week = DateUtil.getWeek(year,month,1); // 5.确定某年某月的最大天数 int maxDays = DateUtil.getMaxDay(year, month); // 6.确定今天是几号 int date = Calendar.getInstance().get(Calendar.DATE); // 7.打印结果 // 7.1 先根据某年某月的1号是星期几先打印出一号 // 假设1号是星期三 那么星期日星期一星期二的位置都打\\t // 还需要定义一个计数器,当计数器=7时换行,不管打&quot;\\t&quot;还是具体时间都要++ int count = 0; for(int i=0;i&lt;week;i++)&#123; System.out.print(&quot;\\t&quot;); count++; &#125; //经过了这个for循环以后我们找到了1号所在的位置 // 然后开始逐个打印日期,从1~最大天数,每当count=7时换行 for(int i=1;i&lt;=maxDays;i++)&#123; System.out.print(i+&quot;\\t&quot;); count++; if(count==7)&#123; System.out.println(); count=0; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.util;import java.util.Calendar;/** * 本类用来演示:自定义的日期工具类 - 推荐定义成static */public class DateUtil &#123; /** * 判断某年某月的最大天数 * @param year * @param month * @return */ public static int getMaxDay(int year,int month)&#123; int days = 31; if(month==4 || month==6 || month==9 || month==11)&#123; days = 30; &#125;else if(month ==2)&#123;// if(isLearYear(year))&#123;// days = 29;// &#125;else&#123;// days = 28;// &#125; days = isLeapYear(year)?29:28; &#125; return days; &#125; /** * 根据年份月份和日期返回星期 * @param year 年 * @param month 月 * @param date 日 * @return 星期几 */ public static int getWeek(int year,int month,int date)&#123; // 1. 首先构建Calendar对象 Calendar cal = Calendar.getInstance(); // 2. 设置年份和月份 // 注意一下这个月份:用户输入的是6表示要6月 而在程序中必须-1 cal.set(year,month-1,date); // 3. 返回星期 // 注意一下这个星期:[周日,周六] -&gt; [1,7] return cal.get(Calendar.DAY_OF_WEEK)-1; &#125;&#125;","categories":[{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Date","slug":"Date","permalink":"http://beautifulboyy/tags/Date/"},{"name":"Calendar","slug":"Calendar","permalink":"http://beautifulboyy/tags/Calendar/"}]},{"title":"抽象类和接口","slug":"java07","date":"2021-07-23T12:18:40.000Z","updated":"2021-08-02T06:04:12.535Z","comments":true,"path":"2021/07/23/java07/","link":"","permalink":"http://beautifulboyy/2021/07/23/java07/","excerpt":"","text":"抽象类抽象类的特点 抽象类天生就是用来被子类继承的,抽象类天生就是不能够被外部进行实例化的. 抽象类使用abstract来进行修饰 普通类是没有子类去定义抽象方法的,换句话说,只有抽象类能定义抽象方法 抽象方法也是使用abstract修饰的,抽象方法是指没有方法体的方法.抽象的方法天生也是被子类用来重写的. 抽象类是一种抽象的数据类型 抽象类继承的特点 如果某个普通的子类继承了抽象类,那么这个子类必须要重写这个抽象父类中所有的抽象方法. 如果某个子类继承了抽象类,不想重写抽象父类中所有的抽象方法,那么需要将这个子类也定义成抽象类. 不能一起混用的修饰符 final和abstract不能一起使用 private和abstract不能一起修饰方法 static和abstract不能一起修饰方法. static不存在多态 接口接口的特点 属于抽象的数据类型,也会不能够被实例化的. 接口中不允许定义普通属性也不允许出现构造方法. jdk8.x允许在接口中使用default关键字来定义普通方法 接口也是用来定义抽象的方法的,接口中的方法都是抽象的方法.[不准确] 接口的属性都是公开的静态的常量属性 定义接口的关键字是interface,编译之后也是.class字节码文件. 接口也可以定义静态方法. 接口的命名规则通常以I开头或者able结尾 一个接口的使用实例 123456789101112131415161718192021public interface Userable &#123; // 接口的属性都是公开的静态的常量属性 //public static final int YEAR = 1; // 简写 //public int YEAR = 1; // 再简写 int YEAR =1; //jdk8.x之前不允许定义普通方法 // 之后可以通过default方法来定义普通方法 public default void test()&#123; System.out.println(&quot;test..&quot;); &#125; // 接口中的方法应该都是抽象的方法 //public abstract void add(); // 简写 //public void add(); // 再简写 void add();&#125; 12345678910111213public class UserableImpl implements Userable&#123; @Override public void add() &#123; System.out.println(&quot;impl1...&quot;); &#125;&#125;public class UserableImpl2 implements Userable&#123; @Override public void add() &#123; System.out.println(&quot;impl2...&quot;); &#125;&#125; 12345678public class TestUserable &#123; public static void main(String[] args) &#123; Userable u1 = new UserableImpl(); u1.add(); Userable u2 = new UserableImpl2(); u2.add(); &#125;&#125; 结果 impl1… impl2… 接口的规则 接口和类 接口天生是用实现类来实现的 - implements 普通的类去实现某个接口的话,必须要实现这个接口中所有的抽象方法 如果抽象的类去实现某个接口的话,可以选择实现或者不实现.[如果不实现的话就让子类去实现] 一个接口可以拥有多个实现类. 一个类可以同时实现多个接口,接口之间用逗号隔开,需要实现这些接口中所有的抽象方法. 接口和接口 一个接口可以继承多个接口,接口是支持多重继承的. 接口的应用提供了一种”契约机制”,屏蔽了底层的具体实现,为了程序的拓展 - 在开发中会体会到. 作用 - 指定开发的这个软件的功能 - “业务方法” 接口的分类 业务接口 - 该接口中只定义抽象方法 常量接口 - 该接口中只定义了常量属性,用于管理系统中所有的常量属性.jdk5.x使用了枚举类型来替代常量接口. 标记接口 - 什么都没有,用来做标记的. 1234567public interface IA&#123;&#125;public class Aimpl implements IA&#123; ...&#125;Aimpl a = new Aimpl();System.out.println(a instanceof IA); //true 函数式接口 - jdk8.x - lambda表达式 里面只有一个抽象方法的接口 - @FunctionnallInterface 1234@FunctionalInterfacepublic interface Funable &#123; int add(int a,int b);&#125; 123456class FunableImpl implements Funable&#123; @Override public int add(int a, int b) &#123; return a+b; &#125;&#125; 匿名内部类 123456Funable f = new Funable()&#123; @Override public int add(int a, int b) &#123; return a+b; &#125;&#125;; lambda表达式 123Funable f = (a,b)-&gt;&#123;return a+b;&#125;;// lambda表达式看起来真的很简单 可是真的有点难理解System.out.println(f.add(10,20)); 抽象类和接口的异同 相同点 接口和抽象类都不能被实例化,他们都位于继承树顶端,用于被其他类继承或实现 接口和抽象类都可以包含抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法,但若是该子类是抽象的,则可以选择实现也可以选择不实现. 不同点 接口中只能包含抽象方法,静态方法,和默认方法,不能定义普通方法,而抽象类中可以包含普通方法. 接口中只能定义静态常量,而抽象类中可以定义普通成员变量,也可以定义静态常量 接口中不能有构造器,而抽象类中可以有. 接口里不能包含初始化块,而抽象类可以包含初始化块. 一个子类中最多只能继承一个抽象类,而一个实现类可以同时实现多个接口.","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"http://beautifulboyy/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"接口","slug":"接口","permalink":"http://beautifulboyy/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"面向对象程序设计","slug":"java06","date":"2021-07-21T12:18:40.000Z","updated":"2021-08-04T13:03:49.387Z","comments":true,"path":"2021/07/21/java06/","link":"","permalink":"http://beautifulboyy/2021/07/21/java06/","excerpt":"","text":"面向对象程序设计 java语言属于面向对象的语言 面向对象本身不是一门具体的技术,符合人类思维的思想. 宗旨:把一个复杂的大型的业务,利用面向对象的思想进行面向对象的分析, 接着面向对象的设计,最终进行面向对象的编程. 对象是数据在内存中的”载体” 类和对象 类是抽象的概念,对象是具体的概念 类是构建对象的蓝图/模板,对象是类的具体的实例化[表现] 类是用来描述对象的. 面向对象的思想核心:”一切皆对象” ①分析出系统中业务的关键对象 - “找对象” - 未来页面上显示的数据 ②找出对象的**”属性”** - “对象拥有什么” ③分析出对象的”方法” - “对象可以干什么,对象的功能” ④找出对象与对象之间的关系. 12345671:1 - 一个丈夫对应一个妻子,一个妻子对应一个丈夫.1:N - 一个客户拥有多个订单.一个订单只能属于一个客户 - 70%N:N - 一个学生可以选择多门课程,一门课程可以被多个学生来选择.自关联 - 自己关联自己. ⑤最后一步才会去考虑具体怎么编码实现.可能也会考虑数据结构或者算法. “相亲业务” - 媒婆帮你找一个”对象” 你要查看”对象”的属性 询问”对象”的功能 分析你和”对象”是否来道🌩 考虑 - 追 - 彩礼 - 结婚 - 具体怎么实现! 面向过程的思想C是典型的面向过程的思想 ①优先考虑的就是算法和数据结构 - 考虑的就是具体怎么实现. 实体类实体类就是用来描述对象的. 实体类中包含属性,构造方法,getter/setter方法,toString方法. 如何定义属性语法:修饰符 数据类型 属性名 [=初始值]; 修饰符 public 公开的 private 私有的 数据类型 八种基本数据类型 内置对象类型以及自定义对象类型. 属性名参考变量的命名 - “小驼峰” this关键字this是自身的一个对象,代表对象本身,可以理解为:指向对象本身的一个指针. 普通的直接引用 this相当于指向当前对象本身 形参与成员名字重名,用this进行区分 12345678910class Person&#123; private int age = 10; public Person()&#123; System.out.println(&quot;初始化年龄:&quot;+age); &#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; 调用本类中另一种形式的构造函数(应该为构造函数中的第一条语句) super关键字super可以理解为指向自己最近父类对象的指针. 普通的直接引用 通过super.xxx来引用父类中的非私有成员 子类中的成员变量或方法与父类中的成员变量或方法同名时进行区分 123456789101112131415class Country&#123; String name; void value()&#123; name = &quot;China&quot;; &#125;&#125;class City extends Country&#123; String name; void value()&#123; name = &quot;Shanghai&quot;; super.value(); //调用父类中的方法啊 System.out.println(name); System.out.println(super.name); &#125;&#125; 调用父类中的某一个构造函数(应该为构造函数中的第一条语句) toString方法 当我们直接输出对象的时候,默认一定会去调用toString方法 - 如果这个对象是null,那么不会调用toString方法的 当自定义的实体类中没有手动提供toString方法,那么这个对象会自动去调用java.lang.Object类中的toString方法 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; java.lang.Object - 它是所有的类的根类,基类,超类,父类. 如果某个类没有明确指定它的父类,那么这个类默认会直接继承java.lang.Object类 “User类是Object类的儿子” - 规定 - “子类可以调用父类中所有的公开的成员“ Object类中提供的toString方法只能用来返回对象的内存地址 - 不满足实际的打印需求 所以需要在实体类中重新重写这个toString方法. 当子类User类一旦重写了toString方法之后,那么就会采取”就近原则”,直接调用自己重写之后的toString方法. 构造方法-constructor作用:创建对象的时候调用构造方法,通过new关键字 可以在创建对象的同时进行赋值操作,赋值的方式只有1次,setter赋值,可以多次赋值 特点 当实体类中如果没有手动提供任何一个构造方法的时候,那么系统会自动分配一个空参构造.如果实体类中一旦手动提供了带参构造之后,那么系统将不会再分配一个空参构造了. 定义的时候,不需要返回类型的 123public 类名([参数列表])&#123; //构造体&#125; 构造允许重载的 实体类中推荐只用提供空参,全参 OO练习业务类和实体类合二为一将业务方法放在实体类中 - 违背了设计原则 - “单一职责原则”. 不要给一个类增加太多的负担. 实体类 - 主要描述的对象,数据在内存中的载体,注重的应该是数据的存储. 业务类 - 存放的是业务的方法 - 在于操作这些数据 实例:设计一个员工类[编号id,姓名name,工资salary],业务方法[crud增删改查]放在实体类中,这是不合理的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package tech.aistar.day06;import java.util.Arrays;/** * @Author liuWenXiu * @Date 2021/7/22 9:22 * @description 员工类 * * 在这个实例中学习到:在进行功能的实现时一定要先判断参数的合法性等 */public class Emp &#123; private int id; private String name; private double salary; //一个上司拥有多个下属 //一个下属对应一个上司 //自关联 private Emp[] emps; //构造,getter/setter,toString public Emp() &#123; &#125; public Emp(int id, String name, double salary, Emp[] emps) &#123; this.id = id; this.name = name; this.salary = salary; this.emps = emps; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Emp[] getEmps() &#123; return emps; &#125; public void setEmps(Emp[] emps) &#123; this.emps = emps; &#125; //给上司添加一个下属 public void addEmp(Emp e)&#123; // 同样需要判断 if(null != this.emps)&#123; //数组的扩容Arrays.copyOf(数组对象,新的长度); this.emps = Arrays.copyOf(this.emps,this.emps.length+1); this.emps[emps.length-1] = e; &#125;else&#123; System.out.println(&quot;对不起,您没有资格添加员工.&quot;); &#125; &#125; //输出下属的个数 public void printEmpCount()&#123; // 防止下属调用这个方法 if(null == this.emps)&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); return; &#125; System.out.println(&quot;员工个数:&quot;+this.emps.length); &#125; //输出某个上司所有的下属信息 public void printEmp()&#123; //同样需要进行判断 if(null != this.emps &amp;&amp; this.emps.length&gt;0)&#123; System.out.println(&quot;下属信息如下:&quot;); for (int i = 0; i &lt; this.emps.length; i++) &#123; System.out.println(this.emps[i]); &#125; &#125;else&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); &#125; &#125; /** * 根据id删除员工 * @param id */ public void delById(int id)&#123; // 又忘了判断合法性!!!! if(this.emps!=null &amp;&amp; emps.length&gt;0)&#123; // 员工的编号是唯一的,因此新的员工列表的长度是原来长度-1 Emp[] temp = new Emp[this.emps.length-1]; int post = 0; for (int i = 0; i &lt; this.emps.length; i++) &#123; if(this.emps[i].getId() == id) continue; temp[post++] = this.emps[i]; &#125; this.emps = temp; &#125;else&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125;&#125; 业务类和实体类分开业务方法应该专门抽取出来放到一个业务类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package tech.aistar.day06.biz;/** * @Author liuWenXiu * @Date 2021/7/22 10:25 * @description Emp实体类 - 数据的存储 */public class Emp &#123; private int id; private String name; private double salary; private Emp[] emps; public Emp() &#123; &#125; public Emp(int id, String name, double salary, Emp[] emps) &#123; this.id = id; this.name = name; this.salary = salary; this.emps = emps; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Emp[] getEmps() &#123; return emps; &#125; public void setEmps(Emp[] emps) &#123; this.emps = emps; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package tech.aistar.day06.biz;import java.util.Arrays;/** * @Author liuWenXiu * @Date 2021/7/22 10:28 * @description 业务类 - 业务方法 */public class EmpBiz &#123; /** * 将新的员工添加上司的下属数组中 * @param boss 上司 * @param e 员工 */ public void addEmp(Emp boss,Emp e)&#123; // 1. 判断 Emp[] emps = boss.getEmps(); if(emps!=null)&#123; emps = Arrays.copyOf(emps,emps.length+1); emps[emps.length-1] = e; // 注意一下这里的set 很重要 boss.setEmps(emps); &#125;else&#123; System.out.println(&quot;对不起,您没有资格添加下属.&quot;); &#125; &#125; /** * 打印下属 * @param boss */ public void printEmp(Emp boss)&#123; Emp[] emps = boss.getEmps(); if(emps!=null &amp;&amp; emps.length&gt;0)&#123; System.out.println(&quot;下属信息:&quot;); for (Emp emp : emps) &#123; System.out.println(emp); &#125; &#125;else&#123; System.out.println(&quot;对不起,您没有下属&quot;); &#125; &#125; /** * 删除工资高于salary的员工 * @param boss * @param salary */ public void delBySalary(Emp boss,double salary)&#123; // 1. 首先需要获取boss的所有员工 Emp[] emps = boss.getEmps(); if(emps!=null)&#123; // 2.遍历员工信息,记录需要删除的个数 // 定义一个计数器 int count = 0; for (Emp emp : emps) &#123; if(emp.getSalary()&gt;salary)&#123; count++; &#125; &#125; // 3.此时我们就已经知道了需要删除的个数,可以创建新的数组 Emp[] temp = new Emp[emps.length-count]; // 4.遍历旧的数组 // 定义新的数组下标 int post = 0; for (Emp emp : emps) &#123; if(emp.getSalary()&lt;=salary)&#123; temp[post++] = emp; &#125; &#125; // 5.得到的temp就是删除后的数组,再将它赋值给boss.emps boss.setEmps(temp); &#125;else&#123; System.out.println(&quot;对不起,您没有下属&quot;); &#125; &#125;&#125; 封装性- Encapsulation封装 - Encapsulation - 屏蔽底层的细节,数据提供保护的机制 属性私有化 提供getter/setter方法 setter方法 - set属性名[首字母变大写] - 推荐的命名规则 setter方法这种设置值的好处 2-1. setter方法中是可以进行参数有效性判断的. 2-2. 业务需求改变了 - 属性名称改变了,使用到这个属性的具体的地方都要发生改变 - “可维护性” 2-3. 并不是所有的属性的值都是通过那么太简单的计算得到的. 12345678910111213141516171819202122232425public class Orders&#123; private int id; private double price; private int count; private double total; //getter/setter - 提供好了 public double getTotal()&#123; double result = this.price * this.count; return result; &#125;&#125;Orders o = new Orders();o.setPrice(100.0);o.setCount(10);//o.setTotal(o.getPrice()*o.getCount());System.out.println(o.getTotal()); 2-4. 并不是所有的属性都需要对外进行公开的. 继承 - Inheritance将多个具有共同特点的对象抽象出一个”父类” 父类中存储的是各个子类共同的特点[属性]或者功能[方法] 继承的好处 - 提高了代码的复用性,使用多态的前提,为了代码的可拓展新 继承的缺点 - 增加了类与类之间的关系,不太符合软件的设计原则”高内聚,低耦合 ​ 低耦合 - 模块与模块之间/类与类之间的关系应该越弱越好 - 最好是没有关系 ​ 高内聚 - 单个模块/类能够独立完成某个业务功能的能力比较强 ​ 实际开发中,可以采用设计原则”合成复用原则 “- 来替代继承的使用 使用extends关键字来表示某个类继承某个父类 123456public class A&#123; &#125;public class B extends A&#123; //B继承于A&#125; B是A的子类,A是B的父类,基类,超类 A的父类就是java.lang.Object - 当某个类如果没有明确指定它的父亲是谁,那么这个类默认继承于Object. 子类可以访问到父类中所有的非私有成员 java的类只支持单继承,一个类只能继承一个父类,避免出现网状结构,保证类的层次性. java的接口支持多重继承,一个接口可以继承多个接口. 继承具有传播性 C extends B B extends A C间接继承于A,C也可以访问到A中所有的非私有成员 不要滥用继承,在使用继承时首先要确保B is A,比如说猫是动物等. super关键字必须放在构造方法的首行 调用父类的构造 在子类的构造方法中,如果没有出现任何的super语句,那么系统默认会给定super();调用父类的空参构造. 当在子类中调用了一个和父类中同名的成员的时候,需要通过super关键字来加以区分[强制调用父类中那个同名的成员] 多态 - polymorphism对象有多种形态,发生前提是具有继承关系 相同的消息可能会送给多个不同的类别之对象. 系统可以根据所属类别,引发对应类别的方法,而有不同的行为.简单来说,所谓多态意指相同的消息给予不同的对象会引发不同的动作. instanceof-&gt; 进行类型的判断,只有为true的时候才能够进行类型的强制转换. 在没有进行类型的判断,随便进行了一个强制类型转换,可能会抛出java.lang.ClassCastException类型转换失败异常. Animal父类 12345678910public class Animal &#123; private String name; public Animal()&#123;&#125; public Animal(String name)&#123; this.name = name; &#125; public void spark()&#123; System.out.println(&quot;动物在叫&quot;); &#125;&#125; Dog子类 123456789101112131415161718192021222324252627public class Dog extends Animal&#123; //子类定义各个子类特有的成员 private double loyalty; //忠诚度 public Dog()&#123; super(); //在子类的构造中,如果没有出现任何的super语句 // 那么系统默认会给定super(); // 调用父类的空参构造 System.out.println(&quot;Dog...&quot;); &#125; public Dog(String name,double loyalty)&#123; // 如果一旦提供了super(name),系统不会分配一个super() super(name); // 调用父类的一参 System.out.println(&quot;Dog全参构造&quot;); this.loyalty = loyalty; &#125; // 子类特有的方法 public void watchDoor()&#123; System.out.println(&quot;狗可以看门&quot;); &#125; // 重写父类中的spark()方法 @Override public void spark() &#123; System.out.println(&quot;汪汪&quot;); &#125;&#125; Cat子类 1234567891011121314151617181920public class Cat extends Animal &#123; private double cute; //萌度 public Cat()&#123; &#125; public Cat(String name,double cute)&#123; super(name); this.cute = cute; &#125; // 子类特有的方法 public void catMouse()&#123; System.out.println(&quot;猫猫会抓鼠鼠...&quot;); &#125; // 重写父类的方法 @Override public void spark() &#123; System.out.println(&quot;喵喵喵&quot;); &#125;&#125; Test类 123456789101112131415public static void main(String[] args) &#123; Animal d = new Dog(&quot;小可&quot;,200.0d); Animal c = new Cat(&quot;小喵&quot;,300.d); Animal[] animals = &#123;d,c&#125;; for (Animal animal : animals) &#123; animal.spark(); if(animal instanceof Dog)&#123; ((Dog) animal).watchDoor(); &#125; if(animal instanceof Cat)&#123; ((Cat)animal).catMouse(); &#125; &#125;&#125; 12345结果:汪汪狗可以看门喵喵喵猫猫会抓鼠鼠... final关键字不可更改,不可变 final修饰的变量/属性 - 不能够重新赋值 final修饰的类 - 不能够被继承 final修饰的方法 - 不能被重写 修饰符访问修饰符 - 决定了这个成员可以在哪里能够被访问. 所有包 子类[同/不同包] 同包 本类 public √ √ √ √ protected × √ √ √ 默认的 × × √ √ private × × × √ 安全级别:private&gt;默认的&gt;protected&gt;public 可见区域:public&gt;protected&gt;默认的&gt;private 方法的重写方法的重写的特点:发生的前提是要有继承关系 重写有一个特殊的场景 - 子类重写之后的方法的修饰符,返回类型,方法名,参数列表和父类中高度保持一致. - 重构 方法名必须一致. 参数列表要高度保持一致. 子类重写的方法的访问修饰符可以小于或者等于父类.[按照安全级别]比如说父类是protected,子类可以是protected或者public,不能是private或缺省. 子类重写的方法的返回类型可以小于[可以是父类方法的返回类型的子类类型]或者等于父类的那个方法 笔试题 - 方法的重载和方法的重写有什么区别? 方法的重载 重载的前提是在同一个类中. 重载的方法方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 方法的重写 重写的前提是要有继承关系 重写的方法名必须相同 重写的参数列表要高度保持一致 重写的方法访问修饰符的安全性可以小于或等于父类 重写的返回类型可以小于或等于父类 三种场景应用 面向父类编程 对象的编译时类型写成父类,对象的运行时类型写成子类. 编译时类型 对象名 = new 运行时类型(); 对象的编译时类型决定对象的访问能力 - “对象名只能访问到编译时类型中定义的成员” 对象的运行时类型决定了对象的行为能力 - “子类中如果一旦重写了父类中的方法,那么运行期间调用的是子类重写之后的方法” 方法的参数类型写成父类,调用这个方法的时候,可以传入这个父类的任意一个子类对象 方法的返回类型写成父类,方法的返回结果可以是这个父类的任意一个子类对象 - “简单工厂设计模式” 面向接口编程 对象的编译时类型写成接口,对象的运行时类型写成实现类 方法的参数类型写成接口,调用方法时可以传入这个接口的任意一个实现类. 方法的返回类型写成接口,方法的返回结果的类型可以是这个接口的任意一个实现类. 练习一12345678910111213141516171819202122232425262728293031323334public class Animal &#123; private String desc; public Animal() &#123; this.desc = getDesc(); &#125; public String getDesc() &#123; return &quot;Animal&quot;; &#125; public String toString() &#123; return desc; &#125;&#125;public class Worf extends Animal &#123; private String name; private double weight; public Worf(String name, double weight) &#123; this.name = name; this.weight = weight; &#125; public String getDesc() &#123; return &quot;Worf:&quot; + name + &quot;体重:&quot; + weight; &#125; public static void main(String[] args) &#123; System.out.println( new Worf(&quot;羊&quot;, 10)); &#125;&#125; 运行结果: Worf:null体重:0.0 练习二12345678910111213141516171819202122232425262728public class Super &#123; int i = 10; public Super() &#123; print(); i = 20; &#125; public void print() &#123; System.out.println(i); &#125;&#125;public class Sub extends Super &#123; int j = 30; public Sub() &#123; print(); j = 40; &#125; public void print() &#123; System.out.println(j); &#125; public static void main(String[] args) &#123; System.out.println(new Sub().j); &#125;&#125; 结果: 0 30 40","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Java入门","slug":"java01","date":"2021-07-21T11:33:04.000Z","updated":"2021-08-04T07:16:22.095Z","comments":true,"path":"2021/07/21/java01/","link":"","permalink":"http://beautifulboyy/2021/07/21/java01/","excerpt":"","text":"Java入门Java语言特点 简单 可移植性 面向对象 - 核心 跨平台性 安全性 - 本身是强类型语言,在编译期间就需要确定数据的类型 JDK和JRE和JVM 三者之间的区别 - 笔试简单题 JDK - Java Development Kit - Java开发工具包,针对开发者的,包含了很多的开发工具,比如java.exe,javac.exe,javadoc.exe,jar.exe等. JDK中是包含JRE的 JRE - Java Runtime Environment- Java运行时环境,包含了很多核心的内库.针对于使用Java语言开发出来软件的用户,如果一个用户仅仅想运行一个java程序的话,那么计算机中只需要安装jre即可. JRE中包含JVM JVM - Java Virtual Machine - Java虚拟机 [笔试的大头 - 内存模型] jvm本身是用C语言编写的 Java程序并不是直接在计算机中跑的,而是在虚拟机上执行的,虚拟机是安装在操作系统上的. java语言具有跨平台性[使用java语言编写的程序可以运行在不同的os上],但是jvm不具有跨平台性,不同的操作系统需要安装不同的jvm. HelloWorld程序java的基础单元是类class 标识符的命名 只能由字母,数字,下划线,$符号组成,但是不能以数字开头. 推荐使用”大驼峰”命名规则,单词首字母必须要大写,其余字母小写. 不能是jdk中内置的对象类型[String,System] 不能是java中的一些关键字,关键字-&gt;java语言赋予了这些单词具备一定的语法含义 byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue等等 不能是java中的保留关键词 - goto[汇编] const 不推荐使用中文,防止出现乱码问题 推荐见名知意 不能是以下三个字面量 - true,false,null 代码 首先在某目录下新建一个文件HelloWorld.java java的源文件就是以.java为后缀的文件 打开HelloWorld.java文件[记事本打开或Notepad++],输入以下代码 1234567public class HelloWorld&#123; // 规范 - 缩进四个空格 public static void main(String[] args)&#123; //方法体:现阶段代码一定是放在方法体内部的 System.out.println(&quot;HelloWorld&quot;); &#125;&#125; 在编程语言中,只要出现了符号,一定必须都是英文输入法下的. java以类作为基础的单位,关键字是class,并且类的名称要和文件的名称高度保持一致. 一对{}表示一个block - 块 - 代码块 main方法是程序的”大门”,运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main方法中执行 jdk中提供了内置的对象[拥有一些功能],开发者可以直接使用,例如java.lang.System类,向控制台输出一句话. java源代码不能够直接被执行,因为计算机不识别java语言程序. 需要对.java为后缀的源文件进行 一个编译操作,一旦语法发生了问题,编译就会失败 编译命令如下所示 1javac HelloWorld.java javac.exe工具其实就是在调用jdk中的编译器,将**.java源文件编译成.class字节码文件** 运行java程序命令如下所示 1java HelloWorld 过程首先编写.java源代码,再使用javac.exe进行编译,最后使用java.exe执行. 原理:.java源文件经过jdk中的编译器生成.class字节码文件,经过jvm中的解释器翻译成机器能够识别的符号. 注:java属于解释型的语言 可能会有题目说java属于半编译型半解释型语言,这是错误的.编译型语言比如C语言,它编写的程序字节编译成计算机能够执行的程序-&gt;xx.exe Java每次执行都会经过jvm解释器进行解释,因此C语言执行的性能高于java语言. Java中的包-package 包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用. 包的命名规则 2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录 2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号 com.baidu.car tech.aistar 2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中. 一旦创建了package,需要在类文件的首行采用package关键字来声明包. Java中的三种注释 单行注释// Ctrl+/ 添加/取消注释 多行注释 123/* 多行注释的内容 - 注释的内容是不会经过jdk的编译器的*/ 文档注释 可以生成文档树,一般放在类或方法上面 1234/***** 文档注释的内容*/ 注释的内容不会经过jdk的编译器,利用javac命令编译.java源文件生成.class文件,再进行反编译得到的.java文件不包含注释. main方法的细节123456//修饰符在使用的时候,之间是没有顺序的.public static void main(String[] args)&#123;...&#125; //okstatic public void main(String[] args)&#123;...&#125; //ok//jdk8中方法的参数支持可变长参数public static void main(String... args)&#123;...&#125; //ok//args是我们传给虚拟机的参数 输出语句12System.out.println();System.out.print(&quot;\\n&quot;); 特殊字符 \\代表转义字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day01;/** * 用来演示转义字符 */public class NrDemo &#123; public static void main(String[] args) &#123; // \\n换行 - 当输出完毕后,光标停在下一行的起始位置 System.out.println(&quot;hello\\n&quot;); System.out.println(&quot;world&quot;); /*结果 hello world * */ // \\r - 当输出完毕后,光标停在下一行的起始位置 System.out.println(&quot;LoveBoy\\r88&quot;); /*结果 88veBoy * */ // \\b - 退格 System.out.println(&quot;Hello\\bever&quot;); /*结果 Hellever * */ // \\t - 制表符,相当于tab键,默认是空4格 System.out.println(&quot;hello\\tworld&quot;); /*结果 hello world * */ // 双引号 \\&quot; System.out.println(&quot;james:\\&quot;sakura is a good girl\\&quot;&quot;); // 单引号 \\&#x27; // 单个\\ \\\\ System.out.println(&quot;D:\\\\temp\\\\news&quot;); // 输出\\\\ System.out.println(&quot;\\\\\\\\&quot;); &#125;&#125; 变量编程的核心就是从定义变量开始,java语言是一个强类型的语言,在编译期间必须要确定好数据的类型 变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作 但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库)] - JVM内存 “JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据” java中是如何定义和存储简单的这些数据呢? 就是通过数据类型以及变量来定义和存储的. 数据类型java的数据类型有两大块 基本数据类型(8种) - 编程思想中将void归纳为第9种 对象类型(无数种) 2.1内置对象类型 - System,String - JDK中提供的类 2.2自定义对象类型 - 自己定义的那些类 八种基本数据类型 名称 大小 范围 默认值 byte 字节 占1个字节8bit -128~127 0 short 短整型 占2个字节16bit -2^15~2^15-1 0 int 整型 占4个字节32bit -2^31~2^31-1 0 long 长整型 占8个字节64bit -2^63~2^63-1 0 float 单精度浮点数 占4个字节32bit +-(3.4*10^38) 0.0 double 双精度浮点数 占8个字节64bit +-(1.798*10^308) 0.0 char 字符 占2个字节16bit 0~65535 ‘\\u0000’空格 boolean 布尔类型 占1个字节8bit true/false false 这些都要记下来 变量的定义变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰” “小驼峰” - 首字母小写,其余每个单词的首字母大写.比如studentAge 1数据类型 变量名 [= 变量值]; 123456789101112131415161718192021222324252627282930313233package tech.aistar.day01;public class VarDemo &#123; public static void main(String[] args) &#123; //数据存储在JVM的内存当中 //定义在方法内部的变量 - 局部变量[JVM的栈区] // 局部变量的生命周期是伴随着方法(main)的调用的开始和结束 //1.JVM加载VarDemo.class到内存 //2.JVM找到main方法想要去执行里面的程序 //3.此时需要申请一块区域来保存数据10 // 3-1.区域的大小是由前面的数据类型来决定的 比如:int类型需要申请4个字节32bit的大小的区域 // 3-2.栈里面的区域大小一旦被确定了,就不能改变,这样有时就会导致内存的浪费 // 3-3.虽然控件浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot; 这也是为什么说栈的时间效率很高 //4.只要是内存中的空间,这个控件就必然会有一个地址,所以变量的存在是为了给这个区域取一个名字 // 比如说这个存储数据10的空间有一个地址,并且给它取了一个名字为a // 变量是为了方便用户来通过它访问到这个空间总存储的具体的那个值的. int a = 10; byte b = 10; short c = 20; long d = 10000; boolean e = true; float f = 13.14f; //注意一下float的定义喔! double g = 233.13; char h = &#x27;a&#x27;; System.out.println(a == b); &#125;&#125; 数据类型的转换一些小常识: a. java中看到一个整数,默认就是int类型 b.java中看到一个小数,默认就是double类型 c.大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方. 自动转换 小的数据类型可以自动转换成大的数据类型 123byte -&gt; short -&gt; int -&gt; longchar -&gt; intint -&gt; double 强制类型转换 大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作 123MaxType 变量1 = 值1;MinType 变量2 = (MinType)变量1; 1234567891011121314151617181920212223242526272829303132package tech.aistar.day01;/** * 数据类型的转换基础 */public class TypeChangeDemo &#123; public static void main(String[] args) &#123; //定义一个byte类型的数据[-128~127] byte b = 127; // 127 - 字面量,数字常量 - 不可改变的量 System.out.println(b); //变量 - 允许多次进行赋值 byte x = 126; //alt+enter可以自动进行强制转换 x = (byte) (x + 1); //注意一下:JVM看待字面量和变量是不同的. byte b2 = 127; //JVM判断出127是字面量,认为它是不可改变的. //JVM再次判断出127正好在byte类型的范围之内,所以精确判断出127可以存储在byte类型定义的变量中 //x = x + 1 这样就会报错 //jvm对待变量的方式,不关心这个变量中具体的数据到底是多大 //只要能够识别出x是byte类型,得出一个结论byte类型+int类型 = int类型 // 所以会报错 &#125;&#125; 一个小实例 12345boolean flag = true;while(flag)&#123; System.out.println(&quot;ddd&quot;);&#125;System.out.println(); 1234while(true)&#123; System.out.println(&quot;ddd&quot;);&#125;System.out.println(&quot;ddd&quot;); 在例子1中可以正常编译,例子2中会报错,就是因为JVM在对象常量和变量时的不同. 隐式转换 1234567int-&gt;long整数后面添加l/L double-&gt;float小数后面加上f/F 推荐在double后面加上d/D - 提高语义 变量的定义和使用八种数据类型的定义和使用 byte类型 1byte b = 127; short类型 - short很少使用 1short s = 155; int类型 - 存在多种情况 - java中的int类型表示的是十进制的数据 12345678//1.整数int a1 = 10;//2.二进制数:在定义二进制数时使用 0b二进制int a2 = 0b1010; //存储的是1010对应的十进制数10//3.字符int a3 = &#x27;a&#x27;; //存储的是字符&#x27;a&#x27;对应的ascii码(97)//4.八进制数:在定义八进制数时使用0八进制[以0开头]int a4 = 032; //存储的是032对应的十进制数26 long类型 - int类型可以自动转换为long类型 12long l1 = 145;long l2 = 1240L; //推荐此种定义方式,隐式转换法 补充:整型数再定义时可以用下划线将数字隔开,增加数字的可读性. 1234int x = 12_3_4_5;System.out.println(x); //结果为12345long l = 3_14_15_936L;System.out.println(l); //结果为31415936 float类型 - 两种方式 12345//1.强制类型转换float f1 = (float)1.34;//2.隐式转换float f2 = 1.34f;//以上两种结果都是一样滴 double类型 12double d1 = 1.25;double d2 = 1.25D; boolean类型 12boolean bl1 = true;boolean bl2 = false; char类型 java中使用单引号表示char类型,使用双引号来表示字符串 java的底层编码是unicode编码,char类型也是采用unicode编码 而unicode编码是双字节[16bit],所以可以用来存储汉字 12345678//1. 字符char c1 = &#x27;c&#x27;;//2. unicode码char c2 = &#x27;\\u5218&#x27;; //结果是刘//3. 汉字char c3 = &#x27;文&#x27;;//4. 数值char c4 = 48; //结果是0 char类型数的计算 - char类型在进行计算的时候会转换成ascii码来进行计算 123456789101112char n1 = &#x27;a&#x27; + 1; //结果是b// 过程: &#x27;a&#x27;-&gt;97 97+1=98 ascii码为98对应的字符是&#x27;b&#x27;char cc = &#x27;a&#x27;;//char nn = cc + 1;//这个会报错!因为cc是变量,并且是char类型的,char+int所以结果应该是int,不能赋值到char// 因此要进行强制转换char nn = (char)(cc + 1);//char--&gt;intint result = &#x27;a&#x27; + &#x27;b&#x27;; //ok//结果是97+98=195 变量的赋值 单个赋值:int a = 10; 通过表达式赋值 123int a = 10;int b = 20;int result = a + b; 链式赋值 1int a=19,b=20,c=39; //同时定义三个变量并进行初始化 先定义变量然后进行赋值 12int a;a = 10; 通过方法赋值 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用范围在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 12345678910111213141516171819202122package tech.aistar.day02;public class LocalVarAndGlobalDemo &#123; //定义全局变量 static int c = 100; public static void main(String[] args) &#123; //&#123;&#125;表示的是代码块 //局部变量 - 定义在方法体内部 int a = 10; &#123; //局部变量使用的范围就在它的最近的&#123;&#125;中 int b = 29; System.out.println(b); //ok System.out.println(a); //ok &#125; //System.out.println(b); //error 跳出&#123;&#125;以后b就无效了 System.out.println(c); //ok &#125;&#125; 常量使用final修饰的变量 - 常量 - 不可改变的量 语法: final 数据类型 变量 [= 初始值] 123456final int s = 100;// s = 200; //error 常量不可以改变final byte b = 100;byte result = b+1; //ok//如果不加final就会报错 运算符算术运算符12345678910111213141516171819201. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] + 123// + 在数值之间表示数值相加// + 在字符串之间表示连接System.out.println(1+2+3+&quot;&quot;+4+5); //结果为645 / 123System.out.println(9.0/2);//4.5System.out.println(9/2);//取整 4 % - 求模/余 1234567// 计算一个多位数每个位数的值int year = 2089;// 原则:任意数字%10 = 最末尾的数字System.out.println(year/1000); //千位数-2System.out.println(year/100%10); //百位数-0System.out.println(year/10%10); //十位数-8System.out.println(year%10); //个位数-9 ++ 和 – 123456789101112131415161718192021222324//现象//前++ 变量和表达式都会自增1int x1 = 1;int result1 = ++x1;System.out.println(&quot;result1:&quot;+result1);//2System.out.println(&quot;x1:&quot;+x1); //2//后++ , 变量仍然自增1,但是x2++的结果是这个x2变量自增之前的值// 表达式的结果是变量自增之前的值int x2 = 1;int result2 = x2++;System.out.println(&quot;result2:&quot;+result2);//1System.out.println(&quot;x2:&quot;+x2);//2System.out.println(&quot;========练习=========&quot;);int o1 = 1;int o2 = 1;//o1=2 o1=3 o2=0//o3 = 1 + 3 + 0 = 4int o3 = o1++ + ++o1 + --o2;//4 + 0int o4 = o3-- + o2++;System.out.println(&quot;o4:&quot;+o4); 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 1234567891011121314151617181920//条件表达式//逻辑与 - 短路与System.out.println(10&gt;3 &amp;&amp; 5&lt;3);//true//短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行.System.out.println(2&gt;3 &amp;&amp; 5&lt;3);//false//证明短路的特性int s1 = 1;System.out.println(5&gt;3 &amp;&amp; (++s1)&gt;10);System.out.println(s1);System.out.println(3&gt;2 || 2&lt;3);//trueSystem.out.println(!(2&gt;3));//trueSystem.out.println(10&gt;3 &amp; 3&gt;2);//trueSystem.out.println(10 &amp; 8); 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 连接条件:为true - 所有的条件表达式都是返回true 123456710 &amp; 8 = 810 对应的二进制数 - 1010 1 0 1 0 &amp;1 0 0 0-------------------- 1 0 0 0 -&gt; 对应的十进制8 | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:只要存在一个1,结果就是1 连接条件:为true - 只要存在一个条件表达式为true. 12345610 | 8 = 1 0 1 0 | 1 0 0 0-------------------- 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 12345678910111210 ^ 8 = 2 1 0 1 0 ^ 1 0 0 0-------------------- 0 0 1 0 -&gt; 对应的十进制2 10 ^ 8 ^ 8 = 10 0 0 1 0 ^ 1 0 0 0-------------------- 1 0 1 0 -&gt; 对应的十进制10 结论:一个数字连续异或同一个数字两次结果是它本身,可以进行加密和解密的操作 一个小实例:交换两个变量的值,不允许出现第三方变量 1234567891011121314151617public static void main(String[] args) &#123; // 方法一:一个数字连续异或同一个数字两次结果是它本身 int m = 100; int n = 200; m = m ^ n; n = m ^ n; m = m ^ n; System.out.println(&quot;m:&quot;+m); System.out.println(&quot;n:&quot;+n); // 方法二:管老师自创写法 int x = 100; int y = 200; y = x ^ (x = y) ^ y; System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y);&#125; 取反~,1变成0,0变成1 123 ~1 0 0 0-------------------- 0 1 1 1 补码 - 负数在计算机中的变现形式就是以补码的形式存在的 1234补码 = 反码 + 1反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位=&gt;1代表的是负数,0代表的是正数反码本身是没有意义的,它的存在就是为了计算补码 题目:-10的二进制是多少?-10的补码是多少? 1234567-10的原码:10000000 00000000 00000000 00001010-10的反码:11111111 11111111 11111111 11110101-10的补码 = 反码 + 111111111 11111111 11111111 11110110最后这个就是-10的补码,也是-10的二进制 题目:计算~9 12300000000 00000000 00000000 0000100111111111 11111111 11111111 11110110最后这个是~9 发现~9 = -10 结论:-(x+1) = ~x 移位操作 笔试题 - 计算机性能最高的操作,jdk源码里面很多都是移位操作 12345678910111213141516171819202122232425&lt;&lt; 向左移动 2&lt;&lt;2 =&gt; 0010&lt;&lt;2 =&gt; 1000=8 原题:请你用最高性能的方式计算出2的3次方 &gt;&gt; 带符号的向右移动,向右移动多少位,那么就在最高位补符号位 -10 &gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 1111111111 11111111 11111111 111101 -&gt; 负数的二进制,最高位是1 要对这个负数进行求解可以参考结论-(x+1)=~x,因此对它取反 00000000 00000000 00000000 00000010 -&gt; 结果是3 表示那个数是~3 =&gt; 该数为-2 10 &gt;&gt; 2 00000000 00000000 00000000 00001010 &gt;&gt; 2 0000000000 00000000 00000000 000010 -&gt; 结果是2 &gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算这个十进制(这个就是结果) 为了更好的计算,补齐后面的数,该十进制就等于如下式子 01000000 00000000 00000000 00000000 - 3 ------------------------------------ 1073741821 练习-15&gt;&gt;2 和-15&gt;&gt;&gt;2 123456789101112131415-15 = ~1411111111 111111111 11111111 11110001 &gt;&gt; 21111111111 111111111 11111111 11110011111111 111111111 11111111 11111100 这个就是结果,取反00000000 000000000 00000000 00000011 -&gt; ~3故结果为-411111111 111111111 11111111 11110001 &gt;&gt;&gt; 20011111111 111111111 11111111 11110000111111 111111111 11111111 11111100 这个就是结果,为了配好,所以+401000000 00000000 00000000 00000000- 4-----------------------------------1073741820 方法方法相当于其他语言中的函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性 语法1234修饰符 返回类型 方法名([参数列表]) [throw 可抛出的异常列表]&#123;...方法体...&#125;现阶段修饰符 返回类型 方法名([参数列表]) &#123;...方法体...&#125; 修饰符访问修饰符决定了这个方法可以被调用的范围 public - 公开的,公共的,如果一个方法被public进行修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的 默认的 受保护的 特殊修饰符 static - 静态的 静态方法 - 使用static修饰的方法 非静态方法 - 没有使用static修饰的方法 是否为静态的方法决定了这个方法被调用的方式 返回类型 有返回类型 - 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自动以对象类型] 方法体的最终的出口一定有return返回值 12345678return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法 正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果 方法的返回类型是什么,就用什么类型去定义,当然也支持类型的转换 无返回类型 - void 不需要使用return + 返回值; 应该如何选择 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型,如果一个方法仅仅是为了输出,只要定义void 123456789public static int test01(int m,int n)&#123; //code... return m和n的最大公约数&#125;public static int test02(int m,int n)&#123; int 公约数 = test01(m,n); return m*n/公约数;&#125;int n = test02(20,12); 方法名参考变量名的命名规则 - 一模一样 参数列表 无参列表 带参列表 1234//此处的age和name就是形参public static void add(int age,String name)&#123; System.out.println(age+&quot;:&quot;+name);&#125; 可变长列表 12345public static void sub(int...arr)&#123; //这里的arr表示数组 for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]); &#125;&#125; 参数的分类 形参 - 定义在方法的参数列表中的参数,目的是告诉这个方法的调用者在调用这个方法时需要传入的参数[个数以及类型],没有实际的值. 实参 - 方法的调用者在调用这个方法的时候传入的真正的参数 - 有真正的值. 如何定义方法 方法体的内部不能够再去定义方法了 main方法仍然是程序的主入口 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 方法的调用方式取决这个方法是静态的还是非静态的 - static 1234567891011121314151617181920212223242526272829303132333435package tech.aistar.day02.method;public class MethodHelloDemo &#123; public static void main(String[] args) &#123; //1.调用公开的静态方法add MethodHelloDemo.add(); //2.调用公开的非静态方法sub //2.1首先创建对象 MethodHelloDemo m = new MethodHelloDemo(); //2.2利用对象调用方法 m.sub(); //整理笔记 //静态方法是属于类的,由类调用,它在JVM加载类进入内存时就分配空间并进行初始化 //非静态方法是属于对象的,只能由类的对象进行调用,每次创建对象的时候,给各自的非静态成员分配空间并进行初始化. &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 1.静态方法只能够直接调用静态方法 2.非静态方法中可以直接调用非静态方法以及静态方法 3.通用的原则 - 类名.静态方法或者对象.非静态方法 4.静态方法属于类拥有的,非静态方法属于对象拥有的 5.静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且仅有一次机会,而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package tech.aistar.day02.method;public class StaticDetailDemo &#123; // 在类中,属性和方法都属于类的成员 //定义全局变量 // 非静态的属性 int n = 19; //等创建对象的时候,才会分配空间和初始化 //静态属性 - 静态属性的初始化的时机优于静态方法 static int m = 199; public static void main(String[] args) &#123; //定义的全局变量n是非静态的,所以此时n还没有初始化,不能直接输出n //System.out.println(n); //error //但是可以直接输出m,因为m是静态的,在JVM加载内存的时候就已经分配了空间并且进行了初始化 System.out.println(m); //要输出n首先需要创建对象 StaticDetailDemo s1 = new StaticDetailDemo(); System.out.println(s1.n); &#125; //非静态方法 public void test01()&#123; System.out.println(&quot;test01...&quot;); &#125; //静态方法 public static void test02()&#123; //在静态方法中可以创建非静态局部变量 int n = 10; //这里可以想象一下 在main方法中可以创建非静态局部变量 System.out.println(&quot;test02...&quot;); // 静态方法中可以调用自定义的静态方法 // 1. 通过类.方法名 StaticDetailDemo.test04(); // 2. 省略类 test04(); // 静态方法中也可以调用非静态方法 // 通过对象.方法 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; //非静态方法 public void test03()&#123; System.out.println(&quot;test03...&quot;); //非静态方法中不允许定义静态的局部变量 根本就没有静态的局部变量这种东西! //static int n = 20; //error // 想象一下static都是JVM一开始加载的 但是非静态的必须要创建对象才可以 这样是不合理的 //非静态方法中调用静态方法 // 1.类名.方法 StaticDetailDemo.test04(); // 2.省略类 因为这个时候静态方法早已经加载好了 test04(); //非静态方法中调用非静态方法 this.方法 this.test01(); // 在实际写代码时可以省略this关键字,this表示的是当前对象 test01(); &#125; //静态方法 public static void test04()&#123; System.out.println(&quot;test04...&quot;); &#125;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或对象.非静态方法 方法的调用者和方法的定义者是存在不同包的不同类中 必须先通过import关键字进行导包操作 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 方法的重载(@overload)重载的要求: 重载的方法存在同一个类中 重载的方法方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 12345678910111213141516171819public static void main(String[] args) &#123; add(); //调用无参add方法 add(12,&quot;Tom&quot;); //调用有参add方法1 add(&quot;Lisa&quot;,10); //调用有参add方法2 &#125; public static void add()&#123; System.out.println(&quot;调用无参add方法&quot;); &#125; public static int add(int age,String n)&#123; System.out.println(n+&quot;:&quot;+age); System.out.println(&quot;调用有参add方法1&quot;); return age; &#125; public static int add(String n,int age)&#123; System.out.println(age+&quot;:&quot;+n); System.out.println(&quot;调用有参add方法2&quot;); return age; &#125; 方法重载的优点-&gt;简化api-方便调用 学会用api通过学习java.lang.Math - 数学工具类 - 提供了很多关于数学计算的方式 abs - 求绝对值 random - 随机数 - [0,1.0)之间 - double类型 注意在求随机整数时需要强制转换 floor -&gt; 返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。 结合例子理解,注意负数的时候的使用 round -&gt; 返回参数中最接近的 long ，其中 long四舍五入为正无穷大。-&gt; round = floor(a+1/2) 同样结合例子理解,注意返回值是long 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; //绝对值 System.out.println(Math.abs(-12)); //12 //随机数 [0,1.0) System.out.println(Math.random()); //[1,100]之间随机的整数 int n1 = (int) (Math.random()*100+1); System.out.println(n1); //[3,5]之间的随机整数 //这里要注意分析 int n2 = (int) (Math.random()*3 + 3); System.out.println(n2); //两个数中的最大值/最小值 System.out.println(Math.max(10,15)); System.out.println(Math.max(10,15)); //floor方法 小于或等于 System.out.println(Math.floor(3.5)); //结果为3.0 System.out.println(Math.floor(3.0)); //结果为3.0 System.out.println(Math.floor(-3.5)); //结果为-4.0 System.out.println(Math.floor(-3.0)); //结果为-3.0 //round方法 四舍五入 这个需要注意一下:!!!返回值是long!!! //round = floor(a+1/2) System.out.println(Math.round(3.5)); //结果为4 System.out.println(Math.round(3.0)); //结果为3 System.out.println(Math.round(-3.5)); //结果为-3 System.out.println(Math.round(-3.0)); //结果为-3&#125; 语句三元操作符三目运算符 条件表法师?result1:result2 表达式为true,结果就是result1,否则结果是result2 支持无限嵌套,但是不推荐,因为可读性很差 m?(表达式?result1:result2):result2 if…else if语句单独使用场景 1234if(条件)&#123; code... code...&#125; {}可以省略的场景 - 如果if{}中的代码只有一行,那么{}可以省略,但是一定要缩进 123if(条件)&#123; code&#125; if…else…的使用 1234567if(条件)&#123; code... code...&#125;else&#123; code...&#125; 多条件分支if…else if…else… 1234567if(条件)&#123; code...&#125;else if(条件)&#123; code...&#125;else&#123; code...&#125; if…else语句可以无限嵌套使用 123456789101112131415if(条件)&#123; if(条件) code... else code...&#125;else if(条件)&#123; if(条件)&#123; code... &#125; else&#123; code... &#125;&#125;else&#123; code...&#125; 习题1.买奶茶,每第二杯半价,单价是10元.求总价. 1234567891011121314int n = 11; //奶茶的数量 double price = 10.0d; //奶茶的价格 // 10 5 10 5 10 5... //如果奶茶是双数杯-&gt; 一半是全价,一半是半价 //如果奶茶是单数杯-&gt; 一半加一杯是全价,一半是半价 double total = n/2 * price + n/2 * (price/2); // 判断是奇数 奇数&amp;1=1 if((n &amp; 1) == 1)&#123; total = total + price; &#125; System.out.println(total); 2.求某年某月最大天数 1234567891011121314151617181920212223242526/** * 判断某年是否为闰年 - (闰年%4=0 &amp;&amp; 闰年%100!=0) || 闰年%400 =0 * @param year 需要判断的年份 * @return */ public static boolean isLeapYear(int year)&#123; return ((year%4==0 &amp;&amp; year%100!=0) || year%400==0); &#125; /** * 求某年某月最大天数 * @param year * @param month * @return */ public static int getMaxDays(int year,int month)&#123; int days = 31; // 4,6,9,11 -&gt; 30 天 // 2 -&gt; 28/29天 // 其他-&gt;31天 if(month==4 || month==6 || month==9 || month==11) days = 30; else if(month == 2) days = isLeapYear(year)?29:28; return days; &#125; switch…caseswitch…case没有if…else灵活 语法 1234567891011switch(变量)&#123; case 值1: //code... [break]; case 值2: //code.. [break]; default: //code... [break];&#125; switch括号中变量的类型只能为byte short int char String enum Byte Short Integer Character 运行过程中如果进入到某个case块中执行,只有遇到break语句才会跳出switch块,如果没有遇到break语句,程序会自动进入到下一个case块中去执行. default语句可以省略,也可以放置在switch{}中的任意位置,但是推荐放置在末尾,如果switch括号中的变量没有匹配到任何的case后面的值,就会进入到default中. 循环语句while while属于后置循环 - 先判断循环条件是否成立,如果成立,则进入到循环体中,否则不执行循环 使用场景: 当不知道循环多少次,但是知道循环退出的条件的时候,优先选择while循环. 语法: 123while(条件)&#123; //循环体...&#125; 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; char c = &#x27;a&#x27;; while(c&lt;=&#x27;z&#x27;)&#123; System.out.print(c); c++; &#125; System.out.println(); //输出&#x27;A&#x27;-&#x27;Z&#x27; int n = 65; while(n&lt;=90)&#123; System.out.print((char)n); n++; &#125; System.out.println(); //死循环 int m = 0; while(true)&#123; System.out.print(m+&quot;\\t&quot;); if(m==10) break; m++; &#125; &#125; 死循环需要注意的点: 一定要有break,否则会一直处于死循环之中 注意要对变量进行操作,使它满足退出循环的条件 练习: 求两个数的最大公约数 12345678910public static int getMaxDivisor(int m,int n)&#123; int divisor = n; int first = m,second = n; while(divisor!=0)&#123; divisor = first % second; first = second; second = divisor; &#125; return first; &#125; 十进制转换为二进制 12345678910111213141516171819202122232425262728/** * 十进制转二进制 - String保存结果 * @param n */ public static void DecimalToBinary(int n)&#123; String result = &quot;&quot;; while(n!=0)&#123; result = n%2 + result; n=n/2; &#125; System.out.println(result); &#125; /** * 十进制转二进制 - int保存结果 * @param n */ public static void DecimalToBinary2(int n)&#123; int result = 0,count=0; while(n!=0)&#123; result = (int) (result + (n%2)*(Math.pow(10,count))); n = n/2; count++; &#125; System.out.println(result); &#125; for循环 单层for 123for(①表达式;②表达式;③表达式)&#123; //④循环体&#125; ①表达式 - 循环过程中变量的初始化操作 - 仅仅执行一次. ②表达式 - 循环退出的条件 - 至少执行一次 ③表达式 - 循环过程中,变量因子的变化 - 可能执行,可能不执行[取决于②表达式是否成立] 执行顺序: ① - ②[成立] - ④ - ③ - ②[成立] - ④ - ③ - … 怪异的写法 - 三个表达式都可以省略不写,或者写到其他地方 123for(;;)&#123; //死循环 - break打破循环&#125; for循环的复合形态 123for(同时定义若干个变量;条件;表达式)&#123; //循环体...&#125; 练习: 打印九九乘法表 12345678for (int i = 1,j=1; i &lt;9 ; j++) &#123; System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j + &quot;\\t&quot;); if(i==j)&#123; System.out.println(); j = 0; i++; &#125;&#125; 嵌套for循环,循环的层数不建议超过三层,嵌套越多,性能越低. 2-1.内外层无关 - 里面的for选中的时候可以单独执行,没有使用到外面for循环的变量因子 1234567//外层循环走一次,内层循环走全部for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 40; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println();&#125; 2-2 内外层相关 - 里面的for使用到了外面for循环的变量因子 123456for (int i = 0; i &lt;9 ; i++) &#123; for (int j = 0; j &lt;=i ; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println();&#125; 练习:打印所有的三位数,三位数由数字1,2,3,4组成,但是不能出现重复的,每打印四个换一行 1234567891011121314151617//定义计数器,用于换行int count = 0;for (int x = 1; x &lt;=4 ; x++) &#123; for (int y = 1; y &lt;=4 ; y++) &#123; for (int z = 1; z &lt;=4 ; z++) &#123; if(x!=y &amp;&amp; y!=z &amp;&amp; x!=z)&#123; System.out.print(x*100+y*10+z+&quot;\\t&quot;); count++; if(count==4)&#123; System.out.println(); count=0; &#125; &#125; &#125; &#125;&#125; 注意一下这里计数器的使用 do…while…do…while属于前置循环 - 无论循环条件是否成立,优先进入到循环体中执行一次,然后再判断条件,决定下一次是否会再次进入. 语法: 123do&#123; //循环体...&#125;while(条件); break语句 break可以跳出switch块. break可以打破它所在的那一层循环. continue语句它只能出现在循环体中,跳过本轮循环,继续执行下一轮循环. 1234567for (int i = 0; i &lt;10 ; i++) &#123; if(i==5)&#123; //break; //结果:01234 continue; //结果:012346789 &#125; System.out.print(i); &#125; 数组 数组的诞生 - 为了解决单个变量只能存储单个知道缺点 数组本身也属于数据结构[数组,栈,堆,树,链表,图] 数组属于对象类型,数组是存在在JVM内存的堆区,基本类型存储在JVM内存的栈区. 数组在内存中一定是一块连续的空间 数组的大小[长度]一旦确定了,就不能改变 语法121. 元素类型[] 变量名 = new 元素类型[size] //推荐使用这种2. 元素类型 变量名[] = new 元素类型[size] 元素类型就是数据类型[8种基本数据类型以及对象类型],决定了这个数组中可以存放的数据的类型 123//arr的数据类型是什么?int[]-&gt;整数型数组// 定义一个长度为3的int型数组int[] arr = new int[3]; 赋值方式如果定义了数据,但是没用对其进行赋值操作,那么系统会默认分配一个默认值.默认值由元素类型决定.byte,short,int,long -&gt; 0float,double -&gt; 0.0boolean -&gt; falsechar -&gt; 空格对象类型 -&gt; null 首先定义数组,然后通过下标一一赋值 下标的范围[0,数组长度-1] 1234int[] arr = new int[3];arr[0] = 10;arr[1] = 10;arr[2] = 10; 如果下标不在此范围,控制台抛出java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常 定义数组的同时进行赋值 12int[] arr= &#123;3,4,5&#125;;int[] arr = new int[]&#123;3,4,5&#125;; 通过普通for循环语句去赋值 1234int[] arr = new int[3];for(int i=0;i&lt;arr.length;i++)&#123; arr[i] = (int)(Math.random()*100+1); //[1,100]的随机数&#125; 获取数组的值 通过下标一一取值 1System.out.println(arr[下标]); 数组提供了属性length - 获取数据的长度,通过普通for循环进行遍历 123for(int i = 0; i &lt; arr.length; i++)&#123; System.out.println(arr[i]);&#125; 使用jdk5.x提供的增强for循环的语法,属于只读的for循环 1234567for(元素类型 元素变量:数组变量名)&#123; System.out.println(元素);&#125;for (int i:arr)&#123; System.out.print(i); &#125; 数组的内存通过new关键字在JVM的堆区中开辟新的空间01,用来存储这个对象{10,20,30},然后将这个对象在堆空间中的内存地址赋值给了引用变量arr1,这个变量存储在栈区中. arr1的本质不是对象,只是一个引用变量. 引用变量中存储的是对象在堆中的内存地址.并且一个引用变量在同一时刻只能指向一个对象,一个对象在同一时刻可以被多个引用指向. 12345int[] arr1 = new int[]&#123;10,20,30&#125;;int[] arr2 = &#123;10,20,30&#125;;arr1 = arr2; //执行完本条语句后,arr1和arr2都是指向第二次创建出来的数组对象//原来第一次创建出来的对象就称为内存中的垃圾对象[没有任何引用指向的对象],会由GC[垃圾回收线程]进行回收并释放内存. 123456int[] arr = &#123;1,3,4,7&#125;; //arr是引用变量,指向该数组在堆区中的地址System.out.println(arr); //打印的是arr的值,也就是数组的地址[I@1b6d3586int[] arr2 = &#123;1,3,4,7&#125;;System.out.println(arr == arr2); //false//因为==始终比较的是值,也就是arr和arr2所代表的值,即两个数组的地址,是不同的,所以是false 方法的参数传递方式 基本类型采用值传递 - 形参的改变不影响实参 12345678910111213141516public static void main(String[] args) &#123; //基本类型采用值传递 int a=10,b=20; //将a,b变量中保存的具体的值拷贝一份赋值给了方法参数中的那俩个变量m,n //所以m和n的改变不影响a,b add(a,b); System.out.println(&quot;main-a:&quot;+a); //10 System.out.println(&quot;main-b:&quot;+b); //20 &#125; private static void add(int m, int n) &#123; m = m + 10; n = n + 10; System.out.println(&quot;add-m:&quot;+m); //20 System.out.println(&quot;add-n:&quot;+n); //30 &#125; 对象类型[引用类型]采用地址传递 12345678910111213public static void main(String[] args) &#123; //对象类型采用的是地址传递/引用传递 int[] arr = &#123;1,3,4,5&#125;; add(arr); System.out.println(&quot;main-arr[3]:&quot;+arr[3]); //15 &#125; private static void add(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] += 10; &#125; System.out.println(&quot;add-arr[3]:&quot;+arr[3]); //15 &#125; 总结:Java中只有值传递,没有地址传递.对象类型[引用类型]看起来是地址传递,但是实际上传递的是引用变量的值,这个值表示的是地址. 注意String类型虽然是一个对象类型,但是具备基本类型传递的特点 12345678910public static void main(String[] args) &#123; String s = &quot;Hello&quot;; add(s); System.out.println(&quot;main-s:&quot;+s);&#125;private static void add(String s) &#123; s += &quot;Sakura&quot;; System.out.println(&quot;add-s:&quot;+s); //main-s:Hello&#125; 一个重点题目: 1234567891011121314public static void main(String[] args) &#123; int[] arr1 = &#123;10&#125;; int[] arr2 = &#123;20&#125;; change(arr1,arr2); System.out.println(&quot;main-arr1[0]:&quot;+arr1[0]); System.out.println(&quot;main-arr2[0]:&quot;+arr2[0]); &#125; private static void change(int[] arr1, int[] arr2) &#123; arr2[0] = 100; arr1 = arr2; System.out.println(&quot;change-arr1[0]:&quot;+arr1[0]); System.out.println(&quot;change-arr2[0]:&quot;+arr2[0]); &#125; 图片虽然有些草率,能看懂大致意思即可. 二维数组定义 数据类型 变量 = 初始化; 数据类型 - 八种基本数据类型以及对象类型 数组本身就属于对象类型 1int[] arr =new int[3]; //arr的数据类型int[],整数型数组,int型数组 元素类型[] 变量名 = new 元素类型[数组长度]; 123int[][] 变量名 = new int[rows][cols];//元素类型决定了数组中可以存放的数据类型//二维数组中的每个元素就是一堆数组 123//定义一个3行2列的int型二维数组int[][] arr = new int[3][2];int arr[][] = new int[3][2]; 一定要理解一下,二维数组的每个元素就是一个一维数组 在定义的时候,列可以省略,行不能省略 赋值方式 通过下标一一赋值 12int[][] arr = new int[3][2];arr[0][0] = 100; 定义二维数组的同时进行赋值 12int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;int[][] arr2 = new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; 先定义一个数组,然后一行一行进行赋值 1234int[][] arr = new int[3][3];//arr[0] = &#123;1,2,3&#125;; //error//注意一下这个每行进行赋值不能省略newarr[0] = new int[]&#123;1,2,3&#125;; 定义一个不规则的二维数组 1234int[][] arr4 = new int[3][];arr4[0] = new int[]&#123;1&#125;;arr4[1] = new int[]&#123;1,2&#125;;arr4[2] = new int[]&#123;1,2,3&#125;; 遍历方式 通过下标一一输出 通过单层for循环输出 123for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(Arrays.toString(arr[i]));&#125; 双层for循环 123456for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.print(arr[i][j]+&quot;\\t&quot;); &#125; System.out.println();&#125; 利用java.util.Arrays工具类中的方法 1System.out.println(Array.deepToString(arr)); 增强型for循环 123456for (int[] i : arr2) &#123; for (int i1 : i) &#123; System.out.print(i1+&quot;\\t&quot;); &#125; System.out.println();&#125; 实例:二维数组的行列转换 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; String[][] arr = new String[4][6]; arr[0]=new String[]&#123;&quot;白&quot;,&quot;日&quot;,&quot;依&quot;,&quot;山&quot;,&quot;尽&quot;,&quot;,&quot;&#125;; arr[1]=new String[]&#123;&quot;黄&quot;,&quot;河&quot;,&quot;入&quot;,&quot;海&quot;,&quot;流&quot;,&quot;.&quot;&#125;; arr[2]=new String[]&#123;&quot;欲&quot;,&quot;穷&quot;,&quot;千&quot;,&quot;里&quot;,&quot;目&quot;,&quot;,&quot;&#125;; arr[3]=new String[]&#123;&quot;更&quot;,&quot;上&quot;,&quot;一&quot;,&quot;层&quot;,&quot;楼&quot;,&quot;.&quot;&#125;; change(arr); &#125; private static void change(String[][] arr) &#123; // 注意一下这个新建的二维数组的元素个数 String[][] temp = new String[6][4]; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; temp[j][i] = arr[i][j]; &#125; &#125; //打印输出 for (String[] strings : temp) &#123; for (String string : strings) &#123; System.out.print(string+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; 递归算法 方法体中调用方法自己本身 递归算法的方法体中一定要出现递归的出口,否则会抛出java.lang.StackOverflowError - 堆栈溢出错误 使用场景:适合解决大量的,重复性的业务题 缺点:性能比较低,将每次计算的结果都会保存在内存中. 获取键盘输入 java.util.Scanner键盘类 如何构建这个Scanner对象 1Scanner sc = new Scanner(System.in); 方法 3-1. int nextInt();//只能获取整数 3-2. double nextDouble();//获取小数 3-3. String nextLine();//获取字符串 注意点:nextLine不要和nextInt或者nextDouble混用.","categories":[],"tags":[{"name":"Scanner","slug":"Scanner","permalink":"http://beautifulboyy/tags/Scanner/"},{"name":"变量","slug":"变量","permalink":"http://beautifulboyy/tags/%E5%8F%98%E9%87%8F/"},{"name":"方法","slug":"方法","permalink":"http://beautifulboyy/tags/%E6%96%B9%E6%B3%95/"},{"name":"循环语句","slug":"循环语句","permalink":"http://beautifulboyy/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"数组","slug":"数组","permalink":"http://beautifulboyy/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Java算法学习","slug":"javastudy-algorithm","date":"2021-07-20T08:34:09.000Z","updated":"2021-08-02T02:15:00.912Z","comments":true,"path":"2021/07/20/javastudy-algorithm/","link":"","permalink":"http://beautifulboyy/2021/07/20/javastudy-algorithm/","excerpt":"","text":"简单算法题整数的逆序给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:34 * @description 给一个的正整数，要求：一、求它是几位数，二、逆序打印出各位数字. */public class ReverseNumber &#123; /** * 获取正整数的位数 * @param num 输入的正整数 * @return */ public static int getDigit(int num)&#123; int digit = 0; while(num!=0)&#123; digit++; num = num/10; &#125; return digit; &#125; /** * 直接逆序输出正整数 * @param num 输入的正整数 */ public static void reverseNumber(int num)&#123; while(num!=0)&#123; System.out.print(num%10+&quot;\\t&quot;); num = num/10; &#125; System.out.println(); &#125; /** * 把逆序的正整数保存在String类型的字符串中 * @param num * @return */ public static String reverseNumberByString(int num)&#123; String str = &quot;&quot;; while(num!=0)&#123; str += num%10; num = num/10; &#125; return str; &#125; /** * 正整数的逆序,逆序的结果仍然是int型 * @param num * @return */ public static int reverseNumberByInt(int num)&#123; int result = 0; while(num!=0)&#123; result = result*10 + num%10; num = num/10; &#125; return result; &#125; public static void main(String[] args) &#123;// System.out.println(getDigit(1247));// reverseNumber(1247); System.out.println(reverseNumberByString(1247)); System.out.println(reverseNumberByInt(1247)); &#125;&#125; 判断回文数一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同 12345678910111213141516171819202122232425package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:43 * @description 一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同 * 思路 - 判断这个数逆序之后的结果是否与原来的数相等 */public class JudgePalindrome &#123; public static boolean judge(int num)&#123; int result = ReverseNumber.reverseNumberByInt(num); if(result == num) return true; return false; &#125; public static void main(String[] args) &#123; System.out.println(judge(123)); System.out.println(judge(12321)); System.out.println(judge(1221)); &#125;&#125; 打印水仙花数打印出所有的 “水仙花数 “,所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。 例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方 1234567891011121314151617181920212223242526272829303132package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:46 * @description 打印水仙花数 * 打印出所有的 &quot;水仙花数 &quot;,所谓 &quot;水仙花数 &quot;是指一个三位数，其各位数字立方和等于该数本身。 * 例如：153是一个 &quot;水仙花数 &quot;，因为153=1的三次方＋5的三次方＋3的三次方 */public class PrintNumberOfDaffodils &#123; public static boolean judge(int num)&#123; int result = 0; result = (int) (Math.pow(num/100,3) + Math.pow(num/10%10,3) + Math.pow(num%10,3)); if(result == num) return true; return false; &#125; public static void print()&#123; for (int i = 100; i &lt; 1000; i++) &#123; if(judge(i)) System.out.print(i+&quot;\\t&quot;); &#125; &#125; public static void main(String[] args) &#123; print(); &#125;&#125; 结果:153 379 371 407 判断完数一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。 例如6=1＋2＋3.编程找出1000以内的所有完数 123456789101112131415161718192021222324252627282930313233343536373839404142package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:55 * @description 判断完数 * 一个数如果恰好等于它的因子之和，这个数就称为 &quot;完数 &quot;。 * 例如6=1＋2＋3.编程找出1000以内的所有完数 */public class JudgePerfectNumber &#123; /** * 判断完数 * @param num * @return */ public static boolean judge(int num)&#123; int result = 0; //存储因子的结果 for (int i = 1; i &lt;num ; i++) &#123; if(num%i==0) result += i; &#125; if(result == num) return true; return false; &#125; /** * 打印1000以内的完数 */ public static void print()&#123; for(int i=1;i&lt;1000;i++)&#123; if(judge(i)) System.out.print(i+&quot;\\t&quot;); &#125; &#125; public static void main(String[] args) &#123; print(); &#125;&#125; 结果:6 28 496 打印菱形打印如下图形,空心的和实心的 123456789* 4 * * 3 5 * * 2 6 * * 1 7 * * 0 8 * * 1 7 * * 2 6 * * 3 5 * 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 16:05 * @description 打印菱形 * 找规律 - 找i和j之间的关系 * * 4 i=0,j=4; * * * 3 5 i=1,j=3,j=5; * * * 2 6 i=2,j=2,j=6; * * * 1 7 i=3,j=1,j=7; * * * 0 8 i=4,j=0,j=8; * * * 1 7 i=5,j=1,j=7; * * * 2 6 i=6,j=2,j=6; * * * 3 5 i=7,j=3,j=5; * * 4 i=8,j=4; * * 左上的边:i+j=4 * 右上的边:j-i=4 * 左下的边:i-j=4 * 右下的边:i+j=12 */public class PrintDiamond &#123; public static void printHollowDiamond()&#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt;9 ; j++) &#123; if(i+j==4 || j-i==4 || i-j==4 || i+j==12) System.out.print(&quot;*&quot;); else System.out.print(&quot; &quot;); &#125; System.out.println(); &#125; &#125; public static void printSolidDiamond()&#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt;9 ; j++) &#123; if(i+j&lt;4 || j-i&gt;4 || i-j&gt;4 || i+j&gt;12) System.out.print(&quot; &quot;); else System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; printHollowDiamond(); printSolidDiamond(); &#125;&#125; 判断素数输出[1~199]之间所有的质数,并且每打印7个换一行 123456789101112131415161718192021222324252627282930313233343536373839404142package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 20:10 * @description 判断素数 * 输出[1~199]之间所有的质数,并且每打印7个换一行 */public class JudgePrime &#123; public static boolean judge(int num) &#123; boolean flag = true; // 注意一下范围是Math.sqrt() for (int i = 2; i &lt;= Math.sqrt(num); i++) &#123; if (num % i == 0) &#123; flag = false; break; &#125; &#125; return flag; &#125; public static void print()&#123; int count = 0; for (int i = 2; i &lt;200 ; i++) &#123; if(judge(i))&#123; System.out.print(i+&quot;\\t&quot;); count++; if(count==7)&#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; //System.out.println(judge(13)); print(); &#125;&#125; 求某年某月的最大天数12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 8:11 * @description 求某年某月的最大天数 */public class GetMaxDay &#123; public static boolean isLeapYear(int year)&#123; if((year%4 == 0 &amp;&amp; year%100!=0) || year%400 == 0) return true; return false; &#125; /** * 获取某年某月的最大天数 * @param year * @param month * @return */ public static int getMaxDay(int year,int month)&#123; int days = 31; if(month == 4 || month == 6 || month == 9 || month == 11)&#123; days = 30; &#125;else if(month == 2)&#123; // 判断平闰年 if(isLeapYear(year)) days = 29; days = 28; &#125; return days; &#125; public static void main(String[] args) &#123; System.out.println(getMaxDay(2021,2)); &#125;&#125; 斐波那契数列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 8:32 * @description 斐波那契数列 * 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 */public class FeiBoNaQi &#123; /** * 递归实现求斐波那契数列中第n个数的值 * @param n * @return */ public static int getFei(int n)&#123; if(n==1 || n==2) return 1; return getFei(n-1) + getFei(n-2); &#125; /** * 循环实现求斐波那契数列中第n个数的值 * @param n * @return */ public static int getFei2(int n)&#123; int first = 1,second=1; int result = 0; if(n==1 || n==2) return 1; int i = 3; while(i&lt;=n)&#123; result = first + second; first = second; second = result; i++; &#125; return result; &#125; public static void main(String[] args) &#123; //System.out.println(getFei(10)); System.out.println(getFei2(10)); &#125;&#125; 求阶乘123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 11:13 * @description 求阶乘! * 1! = 1 * 2! = 1 * 2 = 2 * 3! = 1 * 2 * 3 = 6 */public class GetFactorial &#123; /** * 利用递归求阶乘 * @param n * @return */ public static int getFactorial(int n)&#123; if(n==1) return 1; return n*getFactorial(n-1); &#125; public static int getFactorial2(int n)&#123; if (n==1) return 1; int i = n; int result = 1; while(i&gt;0)&#123; result = result * i; i--; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getFactorial(4)); &#125;&#125; 求最大公约数和最小公倍数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 14:55 * @description 求两个数的最大公约数和最小公倍数 */public class GetCommonDivisor &#123; /** * 递归求最大公约数 * * @param m * @param n * @return */ public static int getDivisor2(int m, int n) &#123; if (m % n == 0) return n; return getDivisor2(n, m % n); &#125; /** * 求两个数的最大公约数 * 20 12 * 20 % 12 = 8 * 12 % 8 = 4 * 8 % 4 = 0 * @param m * @param n * @return */ public static int getDivisor(int m,int n)&#123; int first = m,second = n,result = first % second; while(result!=0)&#123; result = first % second; first = second; second =result; &#125; return first; &#125; /** * 求最小公倍数 * 最小公倍数 = m*n/最大公约数 * @param m * @param n * @return */ public static int getMultiple(int m,int n)&#123; return m*n/getDivisor(m,n); &#125; public static void main(String[] args) &#123; System.out.println(getDivisor(12,20)); System.out.println(getMultiple(12,20)); &#125;&#125; 十进制转二进制12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 14:56 * @description 十进制转二进制 */public class DecimalToBinary &#123; /** * 十进制转二进制 * 10 -&gt; 1010 * 10 / 2 = 5 ... 0 * 5 / 2 = 2 ... 1 * 2 / 2 = 1 ... 0 * 1 / 2 = 0 ... 1 * * @param n * @return */ public static int getBinary(int n) &#123; int result = 0; int count = 0; while (n!=0) &#123; int j = n % 2; result = (int) (result + Math.pow(10, count++) * j); n = n/2; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getBinary(12)); &#125;&#125; 杨辉三角12345public static int yang(int x,int y)&#123; if(x==y || y==0) return 1; return yang(x-1,y-1) + yang(x-1,y);&#125; 一维数组根据值删除元素123456789101112131415161718192021222324252627282930public static int[] deleteByTarget(int[] arr,int target)&#123; // 0.首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1. 首先判断数组中有几个这个值 // 定义count记录 int count = 0; for (int i : arr) &#123; if(i==target) count++; &#125; // 2. 根据结果进行下一步 // 2.1如果count=0,表示没有该值,直接返回原数组 if(count == 0) return arr; // 2.2 如果count不为0,则定义一个新的数组,数组长度为原数组长度-count int[] newArr = new int[arr.length-count]; // 2.3 将arr中除了target以外的值都复制到newArr中 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(!(arr[i] == target)) newArr[pos++] = arr[i]; &#125; // 3.最后返回新的数组 return newArr;&#125; 根据下标删除数组123456789101112131415public static int[] deleteByIndex(int[] arr,int index)&#123; // 要求删除指定下标,而下标是唯一的 // 1.首先判断下标是否合法 if(null==arr || arr.length==0 || index&lt;0 || index&gt;=arr.length) return new int[]&#123;-1&#125;; // 2.定义新的数组,数组长度为原来的长度-1 int[] newArr = new int[arr.length-1]; // 3.循环赋值 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(i!=index) newArr[pos++] = arr[i]; &#125; return newArr;&#125; 数组的去重 - 三种方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 数组的去重 * 思路:将数组的值放到另一个数组中,每次放入一个数,都删掉所有与它值相同的数 * @param arr * @return */public static int[] delDoubleElement(int[]arr)&#123; // 0.首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1.首先定义一个新的数组,用于存储去重后的数据 int[] newArr = new int[arr.length]; // 2.遍历arr数组 int pos = 0; while(arr.length!=0)&#123; // 3. 每次都将arr[0]添加到newArr中 newArr[pos++] = arr[0]; // 4. 删除数组中所有值为arr[0]的元素 arr = deleteByTarget(arr,arr[0]); &#125; // 5.此时得到的newArr数组的末尾可能会有0 // 利用Arrays.copyOf()方法复制 newArr = Arrays.copyOf(newArr,pos); return newArr;&#125;/** * 数组的去重 - 方法二 * 遍历元素,将该元素和后面的所有元素进行比较,如果相同,就删除后面的元素 * @param arr * @return */public static int[] delDoubleElement2(int[]arr)&#123; // 首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1.遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; // 遍历数组之后的值 for (int j = i+1; j &lt; arr.length; j++) &#123; if(arr[i] == arr[j])&#123; // 别忘了给arr重新赋值 arr = deleteByIndex(arr,j); j--; &#125; &#125; &#125; return arr;&#125;/** * 数组的去重方法三 - 利用boolean类型的数组 -&gt; 不需要依赖按下标删除或按元素删除的方法 * @param arr * @return */public static int[] delDoubleElement3(int[]arr)&#123; if(null == arr || arr.length == 0) return arr; // 1. 定义一个boolean类型的数组 boolean[] flag = new boolean[arr.length]; // 2.利用Arrays.fill方法为flag数组赋值,所有的值都赋值为true Arrays.fill(flag,true); // 3. 遍历数组 如果元素在前面已经出现过,同样的位置上,flag设置为false for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if(arr[i] == arr[j]) flag[j] = false; &#125; &#125; // 4.统计true的个数,新数组的长度就是true的个数 int count = 0; for (int i = 0; i &lt; flag.length; i++) &#123; if(flag[i]) count++; &#125; // 5.定义新的数组 int[] newArr = new int[count]; // 6.进行赋值,如果值是false就不赋值 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(flag[i]) newArr[pos++] = arr[i]; &#125; return newArr;&#125; 排序冒泡排序12345678910111213141516171819/** * 冒泡排序 - 两两比较 * @param arr * @param flag flag为true表示从小到大排序,flag为false表示从大到小排序 */public static int[] bubble(int[] arr,boolean flag)&#123; //遍历数组 for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = 0; j &lt; arr.length-1-i; j++) &#123; if(flag?arr[j]&gt;arr[j+1]:arr[j]&lt;arr[j+1])&#123; //进行值交换 arr[j] = arr[j] ^ arr[j+1]; arr[j+1] = arr[j] ^ arr[j+1]; arr[j] = arr[j] ^ arr[j+1]; &#125; &#125; &#125; return arr;&#125; 选择排序123456789101112131415161718/** * 选择排序 - 将第一个数和后面所有的数相比,如果不符合需求则交换值 * @param arr * @param flag flag为true表示从小到大,flag为false表示从大到小 * @return */public static int[] select(int[] arr,boolean flag)&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = i+1; j &lt;arr.length ; j++) &#123; if(flag?arr[i]&gt;arr[j]:arr[i]&lt;arr[j])&#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; &#125; &#125; return arr;&#125; 直接插入排序1234567891011121314151617181920 /** * 直接插入排序 - 前面的序列是有序序列,每次插入一个,都要插入在正确的位置 * @param arr * @param flag flag为true表示从小到大,flag为false表示从大到小 * @return */public static int[] insert(int[] arr,boolean flag)&#123; //下标从1开始 for (int i = 1; i &lt; arr.length; i++) &#123; // 从第二个数开始比较 for (int j = i; j &gt;0 ; j--) &#123; if(flag?arr[j]&lt;arr[j-1]:arr[j]&gt;arr[j-1])&#123; arr[j] = arr[j] ^ arr[j-1]; arr[j-1] = arr[j] ^ arr[j-1]; arr[j] = arr[j] ^ arr[j-1]; &#125; &#125; &#125; return arr;&#125; 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /** * 找基准数 * @param arr * @param start * @param end * @return */public static int getIndex(int[] arr,int start,int end)&#123; int i = start; int j = end; int x = arr[i]; //每次都先将arr[i]设为基准数 即x为基准书 while(i&lt;j)&#123; // 从右往左如果大于等于基准数则继续向左 即j-- while(i&lt;j &amp;&amp; arr[j]&gt;=x)&#123; j--; &#125; if(i&lt;j)&#123; // 此时表示从右往左找到了一个数小于基准数,那么进行占坑操作 arr[i] = arr[j]; // 在占坑以后i的指向要往后一位 i++; &#125; // 从左往右如果小于等于基准数则继续向右 即i++ while(i&lt;j &amp;&amp; arr[i]&lt;x)&#123; i++; &#125; if(i&lt;j)&#123; // 此时表示从左往右找到了一个数大于基准数,那么进行占坑操作 arr[j] = arr[i]; // 在占坑以后j的指向要往前一位 j--; &#125; &#125; //退出循环的时候 表示i&gt;=j 这个时候找到了基准数 // 所以要给基准数赋值 arr[i] = x; return i; //基准数的位置&#125;public static void quickStart(int[] arr,int start,int end)&#123; if(start&lt;end)&#123; int index = getIndex(arr,start,end); quickStart(arr,0,index-1); quickStart(arr,index+1,end); &#125;&#125; 递归类型 求某个数的阶层 12345678910111213 /** * 求某个数的阶层 * 1 = 1 * 2 = 2 * 1 * 3 = 3 * 2 *1 * @param n * @return */public static int jie(int n)&#123; if(n==1) return 1; return n*jie(n-1);&#125; 求斐波那契数列 1234567891011 /** * 斐波那契数列 * //1 1 2 3 5 8 13 21 34 55 ... * @param n * @return */public static int Fibonacci(int n)&#123; if(n==1 || n==2) return 1; return Fibonacci(n-1)+Fibonacci(n-2);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://beautifulboyy/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"hexo和github部署","slug":"blog-deployment","date":"2021-07-15T10:08:42.000Z","updated":"2021-07-31T12:20:39.509Z","comments":true,"path":"2021/07/15/blog-deployment/","link":"","permalink":"http://beautifulboyy/2021/07/15/blog-deployment/","excerpt":"","text":"博客项目Hexo安装 1.首先在某个盘目录下新建文件夹,假设为hello-hexo,这是博客项目的根目录 2.打开终端通过dos命令进入到hello-hexo目录中,输入以下命令 1&gt;E:/cxstudy/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录12E:/cxstudy/hello-hexo&gt;hexo init hello-studyE:/cxstudy/hello-hexo/hello-study&gt;nmp install 测试-启动博客服务器启动服务器代码: 1E:/cxstudy/hello-hexo/hello-study&gt;hexo s 关闭服务器:ctrl+c 打开浏览器输入:localhost:4000 主题模板的安装使用 优质主题模板:https://blog.csdn.net/zgd826237710/article/details/99671027 可以在该博客中找到自己想要的主题进行下载(从github上直接clone) 1.通过cmd进入到hello-study目录中的themes目录中 2.通过git clone命令进行克隆 12&gt;E:/cxstudy/hello-hexo/hello-study&gt;cd themes&gt;E:/cxstudy/hello-hexo/hello-study/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 配置主题模板1.指定新的主题 修改hello-study目录下的_config.yml文件 1theme: hexo-theme-pure 2.修改个人信息 修改hexo-theme-pure目录下的_config.yml文件 12345678profile: enabled: true # Whether to show profile bar avatar: images/avatar.jpg author: Sakurayo author_title: Web Developer author_description: I have nothing to say。 location: Shangrao, China follow: https://github.com/beautifulboyy 3.添加主题侧边栏 为了使得侧边栏的链接生效,将hello-study/themes/hexo-theme-pure/_source下的除了_data文件夹,其余文件夹拷贝一份到hello_study目录下的source目录中即可. 4.博客的语言环境设置 修改hello-study目录下的_config.yml文件 1language: zh-CN 5.设置图片的显示 首先需要安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 配置hello_study目录下的_config.yml文件 1post_asset_folder: true 6.内置搜索功能的实现 安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm i -S hexo-generator-json-content 7.评论功能的实现 评论功能不需要本地数据库进行存储,用的是第三方的LeanCloud 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 复制appId和appKey 在hexo-theme-pure目录下的_config.yml文件中进行配置 123valine: # Valine. https://valine.js.org appid: 复制的appid # your leancloud application appid appkey: 复制的appkey 8.字数统计和阅读时长功能的实现 安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm i -S hexo-wordcount 在hexo_theme-pure目录下的_config.yml文件中配置 1234postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 9.项目展示功能的实现 配置hexo_theme-pure目录下的_config.yml文件 12github: username: beautifulboyy # github username 新建博文1E:/cxstudy/hello-hexo/hello-study&gt;hexo n blog-deployment 部署到github中首先创建新的repository,命名规则为:用户名.github.io 例如:[beautifulboyy.github.io] 修改hello-study目录下的_config.yml文件 1234deploy: type: &#x27;git&#x27; repo: &#x27;https://github.com/beautifulboyy/beautifulboyy.github.io.git&#x27; branch: &#x27;master&#x27; 然后进行hexo三连操作 1234hexo clhexo ghexo shexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://beautifulboyy/tags/hexo/"}]}],"categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"项目","slug":"项目","permalink":"http://beautifulboyy/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"框架","slug":"框架","permalink":"http://beautifulboyy/categories/%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","permalink":"http://beautifulboyy/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://beautifulboyy/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"IO流","slug":"IO流","permalink":"http://beautifulboyy/tags/IO%E6%B5%81/"},{"name":"序列化","slug":"序列化","permalink":"http://beautifulboyy/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"异常","slug":"异常","permalink":"http://beautifulboyy/tags/%E5%BC%82%E5%B8%B8/"},{"name":"DateFormat","slug":"DateFormat","permalink":"http://beautifulboyy/tags/DateFormat/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"http://beautifulboyy/tags/BigDecimal/"},{"name":"BigInteger","slug":"BigInteger","permalink":"http://beautifulboyy/tags/BigInteger/"},{"name":"内部类","slug":"内部类","permalink":"http://beautifulboyy/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"UML","slug":"UML","permalink":"http://beautifulboyy/tags/UML/"},{"name":"static","slug":"static","permalink":"http://beautifulboyy/tags/static/"},{"name":"字符串","slug":"字符串","permalink":"http://beautifulboyy/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"java","slug":"java","permalink":"http://beautifulboyy/tags/java/"},{"name":"集合框架","slug":"集合框架","permalink":"http://beautifulboyy/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Integer","slug":"Integer","permalink":"http://beautifulboyy/tags/Integer/"},{"name":"深拷贝浅拷贝","slug":"深拷贝浅拷贝","permalink":"http://beautifulboyy/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"Date","slug":"Date","permalink":"http://beautifulboyy/tags/Date/"},{"name":"Calendar","slug":"Calendar","permalink":"http://beautifulboyy/tags/Calendar/"},{"name":"抽象类","slug":"抽象类","permalink":"http://beautifulboyy/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"接口","slug":"接口","permalink":"http://beautifulboyy/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"面向对象","slug":"面向对象","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Scanner","slug":"Scanner","permalink":"http://beautifulboyy/tags/Scanner/"},{"name":"变量","slug":"变量","permalink":"http://beautifulboyy/tags/%E5%8F%98%E9%87%8F/"},{"name":"方法","slug":"方法","permalink":"http://beautifulboyy/tags/%E6%96%B9%E6%B3%95/"},{"name":"循环语句","slug":"循环语句","permalink":"http://beautifulboyy/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"数组","slug":"数组","permalink":"http://beautifulboyy/tags/%E6%95%B0%E7%BB%84/"},{"name":"hexo","slug":"hexo","permalink":"http://beautifulboyy/tags/hexo/"}]}