{"meta":{"title":"今晚你会梦到电子羊吗","subtitle":"","description":"","author":"sakura","url":"http://beautifulboyy","root":"/"},"pages":[{"title":"tags","date":"2021-07-30T03:15:20.000Z","updated":"2021-07-30T03:16:05.153Z","comments":true,"path":"tags/index.html","permalink":"http://beautifulboyy/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-30T03:16:21.000Z","updated":"2021-07-30T03:16:40.094Z","comments":true,"path":"categories/index.html","permalink":"http://beautifulboyy/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2021-07-30T03:16:59.000Z","updated":"2021-07-30T03:17:13.878Z","comments":true,"path":"link/index.html","permalink":"http://beautifulboyy/link/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql重要知识点","slug":"mysql-points","date":"2021-08-31T11:45:12.000Z","updated":"2021-08-31T13:13:43.207Z","comments":true,"path":"2021/08/31/mysql-points/","link":"","permalink":"http://beautifulboyy/2021/08/31/mysql-points/","excerpt":"","text":"数据库SQL的分类SQL - Structured Query Language - 结构化查询语言 按照功能分类: DQL(Data Query Language) - 数据查询语言 - select DML(Data Manipulation Language) - 数据操纵语言 - insert,update,delete DDL(Data Definition Language) - 数据定义语言 - create,alter,drop,truncate DCL(Data Control Language) - 数据控制语言 - grant[授权],revoke[取消授权] DTL(Data Transaction Language) - 数据事务语言 - commit,savepoint,rollback 要把上述每种类型的中英文还有例子记下来. 三大范式 第一范式(1NF):保证列的原子性,列不可再分割. 第二范式(2NF):基于第一范式,确保属性完全依赖于主键列,不存在非关键列部分依赖于关键列. 第三范式(3NF):基于第三范式,确保属性直接依赖于主键列,不存在非关键列传递依赖于关键列. char和varchar的区别varchar类型用于存储可边长的字符串,char类型用于存储定长的字符串. varchar适用于字符串列的最大长度比平均长度大的情况,char适用于列的长度为定值的情况. Date和Datetime的区别date类型可用于需要一个日期值而不需要时间时.datetime类型可用于需要同时包含日期和时间信息的值. 在mysql中可以以’YYYY-MM-DD’格式检索显示date的值,以’YYYY-MM-DD HH:mm:ss’格式检索显示datetime的值. 事务的四大特性[ACID] Atomicity - 原子性 事务是不可再分割的,要么同时成功,要么同时失败. Consistency - 一致性 事务一旦结束,内存中的数据和数据库中的数据是保持一致的. Isolation - 隔离性 事务之间互不干扰,多个用户并发访问数据库,数据库会为每一个用户开启事务.每个事务相互独立,互不干扰. Durability - 持久性 事物一旦提交,内存中的数据持久化[保存,序列化]到数据库中,永久保存. 多事务并发处理造成的问题 脏读 - 一个事务读取到了另外一个事务中尚未提交的数据. 一个事务正在访问数据并且对这个数据进行修改,而这种修改还没有提交到数据库,另一个事务也访问了这个数据并且使用了这个修改后的数据. 解决方法:一个事务在修改数据时,该数据不能被其他事务访问. 不可重复读 - 同一个事务多次读取同一条记录结果不同. 当一个事务多次读取同一条记录时,另一个事务也访问并且修改了数据,就会导致多次读取结果不一致的情况,造成不可重复读. 解决方法:只有在修改事务完全提交过后才可以读取到数据. 幻读 - 一个事务修改表中的多行记录后查看存在没有改变的数据 一个事务在修改表中的多行记录时,此时另一个事务对表格进行了插入数据的操作,则第一个事务会发现表中没有被修改的行,像出现了幻觉一样. 解决方法:在一个事务提交数据之间,其他事务不能添加数据. 不可重复读的重点是修改,而幻读的重点是新增或者删除. 事务隔离级别 READ UNCOMMITTED - 读未提交 事务最低的隔离级别,允许另外一个事务可以看到这个事务未提交的数据.会出现脏读,不可重复读,幻读. READ COMMITTED - 读已提交 保证一个事务修改的数据提交后才能被另外一个事务读取,即另外一个事务不能读取该事务未提交的数据.解决了脏读,但会出现不可重复读,幻读. REPEATABLE READ - 可重复读 mysql默认的事务隔离级别,保证一个事务相同条件下前后获取的数据是一致的.解决了脏读,不可重复读的问题,但是会出现幻读. SERIALIZABLE - 串行化 事务被处理为顺序执行,有点类似于锁表,性能极其低下. 事务隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED √ √ √ READ COMMITTED × √ √ REPEATABLE READ × × √ SERIALIZABLE × × × myisam和innodb的区别 myisam不支持事务,innodb支持事务. myisam支持全文索引,innodb不支持全文索引. myisam支持到表所,innodb支持到行锁. 行锁的效率高于表锁. myisam不支持外键约束,innodb支持外键约束 索引的定义索引:对数据库表的一列或者多列的值进行排序的一种结构,使用索引可以快速访问表中的特定信息. 索引的优缺点索引的优点: 大大加快数据检索的速度 将随机I/O编程顺序I/O 加速表与表之间的连接 索引的缺点: 从空间角度考虑,建立索引需要占用物理控件. 从时间角度考虑,创建和维护索引都需要花费时间. 索引的种类 主键索引:数据列不允许重复,不能为null,一个表只能有一个主键索引. 组合索引:由多个列值组成的索引. 唯一索引:数据列不允许重复,可以为null,索引列的值必须是唯一的,如果是组合索引,则列值的组合必须唯一. 全文索引:对文本的内容进行搜索 普通索引:基本的索引类型,可以为null 最左匹配原则最左匹配原则：从最左边为起点开始连续匹配，遇到范围查询（&lt;、&gt;、between、like）会停止匹配。 例如建立索引(a,b,c)，大家可以猜测以下几种情况是否用到了索引。 第一种select * from table_name where a = 1 and b = 2 and c = 3select * from table_name where b = 2 and a = 1 and c = 3上面两次查询过程中所有值都用到了索引，where后面字段调换不会影响查询结果，因为MySQL中的优化器会自动优化查询顺序。 第二种select * from table_name where a = 1select * from table_name where a = 1 and b = 2select * from table_name where a = 1 and b = 2 and c = 3答案是三个查询语句都用到了索引，因为三个语句都是从最左开始匹配的。 第三种select * from table_name where b = 1select * from table_name where b = 1 and c = 2答案是这两个查询语句都没有用到索引，因为不是从最左边开始匹配的 第四种select * from table_name where a = 1 and c = 2这个查询语句只有a列用到了索引，c列没有用到索引，因为中间跳过了b列，不是从最左开始连续匹配的。 第五种select * from table_name where a = 1 and b &lt; 3 and c &lt; 1这个查询中只有a列和b列使用到了索引，而c列没有使用索引，因为根据最左匹配查询原则，遇到范围查询会停止。 第六种select * from table_name where a like ‘ab%’;select * from table_name where a like ‘%ab’select * from table_name where a like ‘%ab%’对于列为字符串的情况，只有前缀匹配可以使用索引，中缀匹配和后缀匹配只能进行全表扫描。 索引失效情况 不遵循最左原则 where条件中有or 在索引上进行计算会导致索引失效 在索引的类型上进行数据类型的隐式转换 在索引中使用函数 在使用like进行模糊查询时以”%”开头 索引上使用! = &lt;&gt;进行判断 索引字段上使用is null/is not null 聚簇索引和非聚簇索引主要区别数据和索引是否分开存储 聚簇索引: 将数据和索引放到一起存储,索引结果的叶子结点保留了数据行. 非聚簇索引:将数据和索引分开存储,索引叶子结点存储的是指向数据行的地址.","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://beautifulboyy/tags/mysql/"}]},{"title":"mybatis基础(一)","slug":"mybatis01","date":"2021-08-31T03:00:38.000Z","updated":"2021-09-02T13:48:27.683Z","comments":true,"path":"2021/08/31/mybatis01/","link":"","permalink":"http://beautifulboyy/2021/08/31/mybatis01/","excerpt":"","text":"Mybatis框架简介 官方学习文档 - https://mybatis.org/mybatis-3/zh/index.html 属于主流的持久层[和db交互的层,负责和db打交道]框架,不负责业务操作.只会涉及到sql语句的编写. 属于ORM[对象关系映射 - 表和实体类息息相关的关系]框架,ORM是一个思想.ORM框架就是这个思想的”实现者” Mybatis是属于半自动的ORM框架 - MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作. 复杂的查询那么仍然是需要手动进行映射的[列-属性] Mybatis底层是基于jdbc代码的. mybatis前身叫ibatis Mybatis环境的搭建使用框架之前,都是需要经过繁琐的配置的.除了SpringBoot[简化了配置] 最新版本 - 3.5.7 - https://github.com/mybatis/mybatis-3/releases 在这个网站可以查看最新的版本以及源码 导入jar包 项目的根目录下新建一个lib目录 - 用来存放第三方jar 1-1. mysql-connector-java-8.0.25.jar - mysql的驱动jar包 1-2. mybatis-3.5.7.jar - mybatis的jar包 选中jar - 右击 - Add As Library … - 把这俩个jar添加到类路径中[classpath] 配置文件框架的配置文件要么是properties文件[支持,优先级是最高的],本次课程中推荐使用的配置文件是xml文件[结构比较清晰] 等待后面学习SpringBoot - 推荐使用的配置文件是yml文件[yarn语法] mybatis的主配置文件 - 主配置文件中也要配置mapper映射文件的resource mapper的映射文件 - 存储项目中的所有的sql语句.sql语句和应用程序进行了分离,方便sql语句的维护. mybatis的主配置文件mybatis的运行时环境,mybatis框架能够被使用的前提是肯定会去读取这个配置文件.配置了该框架运行所有应该具备的信息. 推荐 - 放在src的根目录下mybatis-config.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;dev&quot;&gt; &lt;environment id=&quot;dev&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/j03s?useSSL=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- mapper映射文件的配置 --&gt; &lt;mapper resource=&quot;tech/aistar/mapperxml/user-mapper.xml&quot;&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 核心apiSqlSessionFactoryBuilder仅仅会使用到一次,用于创建SqlSessionFactory对象 SqlSessionFactory build(InputStream in); 功能::读取xml的字节输入流来构建一个重量级的对象SqlSessionFactory - 相当于jdbc数据源对象[BasicDataSource]. SQLSessionFactory重量级的对象 - 不能随意创建多个或者随意销毁 - 耗时间 - 占内存 - 单例 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例 SqlSession openSession(); 获取SqlSession对象 SqlSession作用:负责和db进行CRUD操作 与DB进行一次会话,一次连接 -&gt; 相当于JDBC中的Connection对象,但是比JDBC多出缓存的功能 SqlSession = Connection[db连接] + Cache[默认的一次缓存] SqlSession的实例不是线程安全的,因此是不能被共享的,每个线程都应该有它自己的SqlSession实例. SqlSession应该是一个局部变量,当线程执行到方法的时候,就会在本地开辟一块区域,线程栈[独占的] 传统的开发方式 db设计 - 实体类设计 - User,Video 编写IUserDao接口,UserDaoImpl实现类 编写映射文件 - tech/aistar/mapperxm - 目录下存储所有的映射文件user-mapper.xml 需要在mybatis-config.xml文件中配置映射文件 1234&lt;mappers&gt; &lt;!-- 指定映射文件的配置路径--&gt; &lt;mapper resource=&quot;tech/aistar/mapperxml/user-mapper.xml&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 剖析 session = MybatisUtil.getSession(); 观察MybatisUtil - 读取了mybatis-config.xml文件 - user-mapper.xml 俩个文件都被加载到JVM内存了. user-mapper.xml里面的信息都是在内存中了. namespace=”userMapper”应该是唯一的,一个namespace应该是对应唯一的映射文件. 因为项目中可能有多个映射文件.Map&lt;String,xml映射对象&gt; maps maps.put(“userMapper”,xml文件对应的映射对象); selectOne(namespace.sql语句id值) XMl映射对象 变量 = maps.get(“userMapper”);//精准的定位到它自己的xml文件. xml文件中会有很多个sql标签 - 每个sql标签的id应该是唯一的.精确拿到select标签 定位到select标签之后,利用xml的dom解析技术 - 标签体中的内容/标签属性的值 select * from t_user where username = #{username} resultType=”tech.aistar.model.entity.User” ~~~java Class&lt;?&gt; c = Class.forName(“tech.aistar.model.entity.User”); jdbc编程步骤 pst = conn.preparedStatement(sql); T t = null;判断参数个数 - 发送参数rs=pst.executeQuery(); if(rs.next()){ // } 映射文件配置注意点配置别名在mybatis-config.xml文件中进行配置 1234567&lt;!-- 配置别名 --&gt;&lt;typeAliases&gt; &lt;!-- 一个一个的配置 - 不推荐使用 --&gt; &lt;!-- &lt;typeAlias type=&quot;tech.aistar.model.entity.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!-- 扫包 - 实体类所在的包,默认分配一个别名,就是类名的小写 --&gt; &lt;package name=&quot;tech.aistar.model&quot;/&gt;&lt;/typeAliases&gt; 配置匈牙利&lt;-&gt;小驼峰自动映射123&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;&lt;/settings&gt; parameterType内置对象的对象类型或者基本类型,可以简便的使用这些类型的别名,底层进行了特殊的处理了 比如:parameterType=”java.lang.String”可以简单表示为parameterType=”string” 比如:long-&gt;long或者别名_long. ①推荐如果遇到的基本数据类型,直接写它名称本身即可int-&gt;int ②如果遇到包装类型,推荐写它对应的基本类型的名称[就是包装类型的别名] ③内置的对象类型,诸如String,Date,Map,List等可以写它们的别名[这些单词的小写字母] resultType只有select标签才需要指定resultType属性 mybatis什么时候才能够实现自动映射的效果 - 一定是查询出来的列名和实体类属性名高度保持一致 或者出来的列名是一个合法的匈牙利命名 - 实体类属性的小驼峰. 绑定失败的场景: 12345resultType=&quot;user&quot;select id uid,username uname,password,birthday from t_user where username = #&#123;username&#125;User&#123;id=null, username=&#x27;null&#x27;, password=&#x27;654321&#x27;, birthday=Thu Aug 26 00:00:00 CST 2021&#125; 绑定失败的原因 在获取数据时为其修改了别名,新增了uid和uname,而底层会对其进行处理,处理成setUid和setUname,然后发现没有这个Method实例,再次尝试getDeclaredFileld(),然后发现没有uid和uname这个属性,所以会获取失败. resultMap应用场景一: 当查询的列值不能自动映射/绑定实体类的属性的时候,需要通过resultMap来进行一一绑定. mybatis有些场景下还是需要手动绑定 - 半自动的ORM框架. 12345678910111213&lt;!-- 手动映射--&gt;&lt;resultMap id=&quot;get_map&quot; type=&quot;user&quot;&gt;&lt;!-- 主键列映射--&gt;&lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;&lt;!-- 普通列映射--&gt;&lt;result column=&quot;uname&quot; property=&quot;username&quot;&gt;&lt;/result&gt;&lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;&lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;get&quot; parameterType=&quot;string&quot; resultMap=&quot;get_map&quot;&gt;select id uid,username uname,password,birthday from t_user where username = #&#123;username&#125;&lt;/select&gt; 手动绑定的过程剖析1234567891011121314151617181920type=&quot;tech.aistar.model.pojo.user&quot; - &gt; Class&lt;?&gt; c = Class.forName(type);T t = (T)c.newInstance();result标签的顺序可以随机的 -&gt; 说明底层 - rs要么根据列的序号取[从1开始],可以根据列的名称去取. Object getObject(String columnLabel) throws SQLException;Object uname = rs.getObject(&quot;uname&quot;);property=&quot;username&quot; -&gt; 底层&quot;setUsername&quot;-&gt;Method m = c.getDeclaredMethod(&quot;setUsername&quot;);m.invoke(t,uname);//反射调用setter方法.加入method找不到 - Field f = c.getDeclaredField(&quot;username&quot;);f.set(t,uname);如果property=&quot;属性值&quot;找不到任何一个对应的method或者field -&gt; 直接抛出 There is no setter for property named &#x27;usernames&#x27; in &#x27;class tech.aistar.model.entity.User&#x27; selectOne和selectList区别 selectOne - 负责加载唯一的一条数据,返回的是一个单个对象 selectList - 负责加载多条数据,返回一个集合 如果结果是多条数据则必须使用selectList,如果不小心使用到了selectOne,就会抛出异常. 1org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 5 占位符区别$和# $ - 产生了sql注入的问题,把参数直接硬拼接到了sql中,相当于Statement # - 相当于PreparedStatement占位符,会提前将语句进行预编译,不会产生sql注入的问题 12-- 提前将这条语句进行预编译,设置参数和发送参数select * from t_video where title = #&#123;title&#125; 参数名 如果是简单类型,单个参数[String,包装类型,基本数据类型] 1234567#&#123;参数名&#125;和$&#123;参数名&#125;是任意取名称的.id=#&#123;ttt&#125; id=#&#123;value&#125; id=#&#123;id&#125;本质上#&#123;参数&#125; 等同于 ?&lt;select id = &quot;getById&quot; resultType=&quot;video&quot; parameterType=&quot;int&quot;&gt; select * from t_video where id = #&#123;id&#125;&lt;/select&gt;推荐使用#&#123;value&#125;或者#&#123;方法的参数名称&#125; 如果是自定义的对象类型则不能瞎写 123 &lt;insert id=&quot;save&quot; parameterType=&quot;video&quot;&gt; insert into t_video values(#&#123;id&#125;,#&#123;title&#125;,#&#123;createDate&#125;,#&#123;price&#125;,#&#123;videoUrl&#125;,#&#123;userId&#125;)&lt;/insert&gt; Mapper代理开发方式底层使用到的技术就是动态代理 - 动态代理技术[JDK]来在程序的运行期间来生成Mapper接口的实现类. 传统的方式还是需要手动写接口的实现类的. 遵守Mapper开发方式的规范 - 一定要遵守 规范 创建包tech.aistar.mapper - 用于存放mapper接口,替代之前的dao包下的dao接口 制定mapper接口 - 接口的命名必须要规范 -&gt; 实体类名Mapper.比如UserMapper 在Mapper接口中指定方法 在Mapper接口所在包下新建Mapper接口对一个的映射文件,并且映射文件的名称一定要和它对应的Mapper接口的命名高度保持一致. 每个映射文件都会指定唯一的一个namespace属性值,一定是这个映射文件对应的那个Mapper接口的全限定名 select,update,insert,delete这些标签sql的id属性值一定要和mapper接口中方法的名称高度保持一致. mybatis-config.xml配置映射文件 1234567891011&lt;mappers&gt; &lt;!-- &lt;mapper resource=&quot;tech/aistar/mapperxml/user-mapper.xml&quot;&gt;&lt;/mapper&gt;--&gt; &lt;!-- &lt;mapper resource=&quot;tech/aistar/mapperxml/video-mapper.xml&quot;&gt;&lt;/mapper&gt;--&gt; &lt;!-- &lt;mapper resource=&quot;tech/aistar/mapperxml/comment-mapper.xml&quot;&gt;&lt;/mapper&gt;--&gt; &lt;!-- 直接扫接口 - 一个一个扫--&gt; &lt;!-- &lt;mapper class=&quot;tech.aistar.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;--&gt; &lt;!-- &lt;mapper class=&quot;tech.aistar.mapper.VideoMapper&quot;&gt;&lt;/mapper&gt;--&gt; &lt;package name=&quot;tech.aistar&quot;/&gt;&lt;/mappers&gt; mapper编程步骤 获取连接-&gt;获取Mapper接口对象(session.getMapper(class实例))-&gt;接口对象调用方法-&gt;commit(DML)-&gt;关闭连接 输入参数类型 接口中的方法是单个参数,sql标签需要制定参数的类型 - parameterType - 支持类型的别名,如果是自定义的类型,需要提前在mybatis-config.xml主配置文件中进行配置. 散列的类型 - 一定要配置@Param注解,无需在sql标签中写parameterType 12345678/** * 散列的数据 - 根据价格[大于price]和title查找数据 * @Param(&quot;参数名称&quot;) 是sql标签中的#&#123;占位符名称&#125; 两者名称高度保持一致即可. * @param title * @param price * @return */List&lt;Video&gt; findByTitleAndPrice(@Param(&quot;title&quot;) String title,@Param(&quot;price&quot;) Double price); 1234&lt;!-- 这里的#&#123;price&#125;和$&#123;title&#125;取的都是接口中@Param的值--&gt;&lt;select id=&quot;findByTitleAndPrice&quot; resultType=&quot;video&quot;&gt; select * from t_video where price &gt; #&#123;price&#125; and title like &#x27;%$&#123;title&#125;%&#x27;&lt;/select&gt; 希望接口更加具备可拓展性的话,不建议使用散列的数据.如果哪天条件增多/减少,接口是需要变化的,而接口是给外部调用的,所以可以使用第三方实体类来封装条件 第三方实体类 1234public class VideoQueryDTO &#123; private String title; private Double price;&#125; 123456/** * 根据VideoUSerDTO来筛选数据(数据传输对象-&gt;里面存储的是title,price) -&gt; 需要在mybatis-config中进行配置 * @param videoQueryDTO * @return */List&lt;Video&gt; findByTitleAndPrice2(VideoQueryDTO videoQueryDTO); 1234&lt;!-- 这里的#&#123;price&#125;和$&#123;title&#125;取得都是VideoQueryDTO类中的属性值--&gt;&lt;select id=&quot;findByTitleAndPrice2&quot; parameterType=&quot;videoQueryDTO&quot; resultType=&quot;video&quot;&gt; select * from t_video where price &gt; #&#123;price&#125; and title like &#x27;%$&#123;title&#125;%&#x27;&lt;/select&gt; 使用Map来封装条件 123456789/** * 根据title和price来筛选数据,采用的是Map进行筛选 * 这里的title是String,price是Double不要想当然以为是Map&lt;String,Double&gt; * 实际上Map中的key表示的是名称,value是真正的值 * 在xml中通过#&#123;名称&#125;来获取真正的值 * @param maps * @return */List&lt;Video&gt; findByTitleAndPrice3(Map&lt;String,Object&gt; maps); 1234&lt;!-- 这里的price和title值的是map中的key,获取的值是map中的value--&gt;&lt;select id=&quot;findByTitleAndPrice3&quot; parameterType=&quot;map&quot; resultType=&quot;video&quot;&gt; select * from t_video where price &gt; #&#123;price&#125; and title like &#x27;%$&#123;title&#125;%&#x27;&lt;/select&gt; 1234567891011121314151617@Testpublic void testFindByTitleAndPrice3()&#123; SqlSession session = null; try &#123; session = MybatisUtil.getSession(); VideoMapper videoMapper = session.getMapper(VideoMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;title&quot;,&quot;你&quot;); map.put(&quot;price&quot;,40.0d); List&lt;Video&gt; videoList = videoMapper.findByTitleAndPrice3(map); videoList.forEach(e-&gt; System.out.println(e)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; MybatisUtil.closeSession(session); &#125;&#125; 返回参数类型 单个参数 - resultType 查询出来的列,没有对应的实体类,需要创建第三方dto对象来封装查询的结果 查询每个用户发布的视频数. UserResultDTO 1234public class UserResultDTO &#123; private String username; private Integer counts;&#125; 12345/** * 查询每位用户发布的视频数 * @return */List&lt;UserResultDTO&gt; countUserVideos(); 1234&lt;select id=&quot;countUserVideos&quot; resultType=&quot;userResultDTO&quot;&gt; select u.username,count(tv.id) counts from t_user u join t_video tv on u.id = tv.user_id group by username&lt;/select&gt; 使用Map作为返回类型 123456/** * 查询每位用户发布的视频数 * 用户名称 - 视频数量 * @return */List&lt;Map&lt;String,Object&gt;&gt; countUserVideos2(); 1234&lt;select id=&quot;countUserVideos2&quot; resultType=&quot;map&quot;&gt; select u.username,count(tv.id) counts from t_user u join t_video tv on u.id = tv.user_id group by username&lt;/select&gt; 动态SQL语句mybatis映射文件的灵魂 - 支持动态sql以及sql片段[封装sql,然后支持多次调用] if标签123456789 &lt;select id=&quot;findIf&quot; resultType=&quot;video&quot;&gt; select * from t_video where 1=1 &lt;if test=&quot;title!=null&quot;&gt; and title like &#x27;%$&#123;title&#125;%&#x27; &lt;/if&gt; &lt;if test=&quot;price!=null&quot;&gt; and price &gt;= #&#123;price&#125; &lt;/if&gt;&lt;/select&gt; where标签作用 查询语句后面自动拼接where语句 去除where语句后面的第一个条件前面的条件连接符号[and,or] 12345/** * 在xml文件中使用if进行判断,判断输入的值是否需要为null * @return */List&lt;Video&gt; findByTitleAndPriceUseIf(@Param(&quot;title&quot;) String title,@Param(&quot;price&quot;) Double price); 1234567891011&lt;select id=&quot;findByTitleAndPriceUseIf&quot; resultType=&quot;video&quot;&gt; select * from t_video &lt;where&gt; &lt;if test=&quot;price!=null&quot;&gt; and price &gt; #&#123;price&#125; &lt;/if&gt; &lt;if test=&quot;title!=null&quot;&gt; and title like &#x27;%$&#123;title&#125;%&#x27; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 1List&lt;Video&gt; videoList = videoMapper.findByTitleAndPriceUseIf(null,50.0d); 12345DEBUG - ==&gt; Preparing: select * from t_video WHERE price &gt; ?DEBUG - ==&gt; Parameters: 50.0(Double)DEBUG - &lt;== Total: 2Video&#123;id=5, title=&#x27;千层套路你&#x27;, createDate=Thu Aug 26 20:47:11 CST 2021, price=1000.0, videoUrl=&#x27;http://aistar/005.mp4&#x27;, userId=3&#125;Video&#123;id=6, title=&#x27;嘻嘻嘻哈&#x27;, createDate=Tue Aug 31 15:18:31 CST 2021, price=300.0, videoUrl=&#x27;http://bilibili.com&#x27;, userId=4&#125; set标签作用 生成set语句 去除最后一个更新列的最后一个逗号 123456789101112131415&lt;update id=&quot;update&quot; parameterType=&quot;video&quot;&gt; update t_video &lt;set&gt; &lt;if test=&quot;title!=null&quot;&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=&quot;price!=null&quot;&gt; price = #&#123;price&#125;, &lt;/if&gt; &lt;if test=&quot;videoUrl!=null&quot;&gt; video_url = #&#123;videoUrl&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; foreach标签foreach标签用于对集合进行遍历(构建in条件语句的时候) 123456789/** * 动态sql -foreach标签 * 查询id为集合中的数据的Video对象 * 此时使用@Param(&quot;ids&quot;)则collection=&quot;ids&quot; * 如果没有使用,则可以使用默认的list * @param ids * @return */List&lt;Video&gt; findInId(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids); 1234567&lt;!-- select * from t_video where id in (,,,)--&gt;&lt;select id=&quot;findInId&quot; parameterType=&quot;list&quot; resultType=&quot;video&quot;&gt; select * from t_video where id in &lt;foreach collection=&quot;ids&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot; item=&quot;item&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; foreach标签用于批量保存数据 1234567/** * 保存多条视频信息 * -&gt; 但一般这种类型使用jdbc的批处理 * @param videos * @return */int saveList(List&lt;Video&gt; videos); 123456&lt;insert id=&quot;saveList&quot; parameterType=&quot;list&quot;&gt; insert into t_video values &lt;foreach collection=&quot;list&quot; separator=&quot;,&quot; item=&quot;item&quot;&gt; (#&#123;item.id&#125;,#&#123;item.title&#125;,#&#123;item.createDate&#125;,#&#123;item.price&#125;,#&#123;item.videoUrl&#125;,#&#123;item.userId&#125;) &lt;/foreach&gt;&lt;/insert&gt; 注解开发注解开发和xml开发并存 123456789101112131415public interface CommentMapper &#123; @Select(&quot;select * from tbl_comment&quot;) List&lt;Comment&gt; findAll(); @Select(&quot;select * from tbl_comment where id = #&#123;id&#125;&quot;) Comment getById(Integer id); @Delete(&quot;delete from tbl_comment where id = #&#123;id&#125;&quot;) int delById(Integer id); @Insert(&quot;insert into tbl_comment values(#&#123;id&#125;,#&#123;userId&#125;,#&#123;videoId&#125;,#&#123;content&#125;,#&#123;commentId&#125;)&quot;) int save(Comment comment);&#125; sql片段主要的作用就是用来封装sql语句,以便sql语句的多次复用 引用本映射文件中的sql片段&lt;include refid=&quot;sql的id&quot;&gt;&lt;/include&gt; 引用其他映射文件中的sql片段&lt;include refid=&quot;其他映射文件的namespace.sql的id&quot;&gt;&lt;/include&gt; 12345678910111213141516171819202122&lt;!-- 定义一个sql片段,查询t_user的所有信息--&gt;&lt;sql id=&quot;findAllUserSql&quot;&gt; select * from t_user&lt;/sql&gt;&lt;!-- &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;--&gt;&lt;!-- select * from t_user--&gt;&lt;!-- &lt;/select&gt;--&gt;&lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt; &lt;!-- 引用sql片段 --&gt; &lt;include refid=&quot;findAllUserSql&quot;&gt;&lt;/include&gt;&lt;/select&gt;&lt;!-- &lt;select id=&quot;getById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;--&gt;&lt;!-- select * from t_user where id = #&#123;id&#125;--&gt;&lt;!-- &lt;/select&gt;--&gt;&lt;select id=&quot;getById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;findAllUserSql&quot;&gt;&lt;/include&gt; where id = #&#123;id&#125;&lt;/select&gt; resultMap - 继承性应用场景一: 当查询的列值不能自动映射/绑定实体类的属性的时候,需要通过resultMap来进行一一绑定. 这条语句只需要取出俩条数据 - 手动封装了俩条数据即可 12345678&lt;resultMap id=&quot;getByIdMap&quot; type=&quot;user&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;uname&quot; property=&quot;username&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;getById&quot; resultMap=&quot;getByIdMap&quot; parameterType=&quot;int&quot;&gt; select id uid,username uname from t_user where id = #&#123;id&#125;&lt;/select&gt; 需要把所有的列数据进行查询绑定 - resultMap标签是允许被继承的. 123456789101112&lt;sql id=&quot;findAllUserSql&quot;&gt; select id uid,username uname,password,birthday from t_user&lt;/sql&gt;&lt;resultMap id=&quot;findAllMap&quot; type=&quot;user&quot; extends=&quot;getByIdMap&quot;&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;findAllMap&quot;&gt; &lt;include refid=&quot;findAllUserSql&quot;&gt;&lt;/include&gt;&lt;/select&gt; 日志的配置Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一： SLF4J Apache Commons Logging Log4j 2 Log4j - 配置方式比较简单 - 选用的 JDK logging SLF4J日志框架官方地址:http://www.slf4j.org/ 市面提供了SLF4J - 日志门面-接口 slf4j-api.jar - 日志接口 - slf4j-api-1.7.30.jar - 项目中仅仅只有日志的接口,而没有实现jar - 不ok springboot框架中推荐使用的日志实现 - logback 必须先引入日志门面 - 日志接口 slf4j-api.jar 必须引入日志的具体的实现 - logback-core.java 不需要中间适配包的原因是slf4j日志框架的创造者和logback日志具体实现的创造者是同一个作者 mybatis中想要使用log4j 引入日志接口slf4j-api.jar - pc的接口 B -&gt; 5个方法 slf4j-log412.jar - 适配包 - usb转接口 C extends B 引入log4j.jar - log4j日志具体实现 - 网线接口 D extends C -&gt; 10个方法 slf4j日志接口的作者和log4j作者不是同一个人 配置文件1234567891011121314151617181920212223242526#log4j.rootLogger=debug,stdout,logfile# ERROR - 日志的级别,只有出现错误才会输出日志信息.# stdout - 将日志信息输出到控制台,不会输出到日志文件# logfile - 将日志信息输出到日志文件中去.不会在控制台输出log4j.rootLogger=INFO,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.SimpleLayoutlog4j.appender.logfile=org.apache.log4j.FileAppender# 日志文件的路径log4j.appender.logfile.File=jbit.loglog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %F %p %m%n# 项目中调用哪个接口中的方法的时候,才会产生日志信息.log4j.logger.tech.aistar.mapper=DEBUG#log4j.logger.com.mybatis.common.jdbc.SimpleDataSource=DEBUG#log4j.logger.com.mybatis.common.jdbc.ScriptRunner=DEBUG#log4j.logger.com.mybatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG#log4j.logger.java.sql.Connection=DEBUG#log4j.logger.java.sql.Statement=DEBUG#log4j.logger.java.sql.PreparedStatement=DEBUG#log4j.logger.java.sql.ResultSet=DEBUG 日志显示级别log4j定义了8个级别的log（除去OFF和ALL，可以说分为6个级别），优先级从高到低依次为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、 ALL。 ALL 最低等级的，用于打开所有日志记录。 TRACE designates finer-grained informational events than the DEBUG.Since:1.2.12，很低的日志级别，一般不会使用。 DEBUG 指出细粒度信息事件对调试应用程序是非常有帮助的，主要用于开发过程中打印一些运行信息。 INFO 消息在粗粒度级别上突出强调应用程序的运行过程。打印一些你感兴趣的或者重要的信息，这个可以用于生产环境中输出程序运行的一些重要信息，但是不能滥用，避免打印过多的日志。 WARN 表明会出现潜在错误的情形，有些信息不是错误信息，但是也要给程序员的一些提示。 ERROR 指出虽然发生错误事件，但仍然不影响系统的继续运行。打印错误和异常信息，如果不想输出太多的日志，可以使用这个级别。 FATAL 指出每个严重的错误事件将会导致应用程序的退出。这个级别比较高了。重大错误，这种级别你可以直接停止程序了。 OFF 最高等级的，用于关闭所有日志记录。 从上到下 - 输出的日志信息肯定是越来越少的. 级联查询 根据视频的id来查询视频信息,顺便加载出该视频的用户信息 根据用户的id来查询用户信息,顺便加载出该用户下所有的视频信息 加载一的一方第一种方式根据视频的id来查询视频信息,顺便加载出该视频的用户信息 方法一:创建DTO对象,DTO散列的属性和查询的列对上号 - resultType VideoUserDTO 1234567891011public class VideoUserDTO implements Serializable &#123; private Integer tid; private String title; private Date createDate; private Double price; private String videoUrl; private Integer uid; private String username; private String password; private Date birthday;&#125; VideoMapper.java 12345678910/** * 根据id查询出视频信息以及该视频的用户信息 * 这里也可以使用注解开发 * @Select(&quot;select t.id tid,t.title title,t.create_date create_date,t.price price, t.video_url video_url,u.id uid,u.username username,u.password password,u.birthday birthday * from t_video t join t_user u on u.id = t.user_id * where t.id = #&#123;id&#125;&quot;) * @param id * @return */VideoUserDTO getVideoAndUserById(Integer id); VideoMapper.xml 12345&lt;select id=&quot;getVideoAndUserById&quot; parameterType=&quot;int&quot; resultType=&quot;videoUserDTO&quot;&gt; select t.id tid,t.title title,t.create_date create_date,t.price price, t.video_url video_url,u.id uid,u.username username,u.password password,u.birthday birthday from t_video t join t_user u on u.id = t.user_id where t.id = #&#123;id&#125;&lt;/select&gt; 第二种方式方法一:使用第三方类实现关系的维护,mybatis支持ognl语言[对象导航语言] - 针对单个对象,不能集合对象 VideoUserDTO2 1234public class VideoUserDTO2 implements Serializable &#123; private Video video; private User user;&#125; VideoMapper.java 1VideoUserDTO2 getVideoAndUserById2(Integer id); VideoMapper.xml 在resultMap中要使用OGNL[对象导航语言],要在property指定是什么对象的什么属性,然后一一映射. 123456789101112131415161718&lt;resultMap id=&quot;getVideoAndUserById2Map&quot; type=&quot;videoUserDTO2&quot;&gt; &lt;result column=&quot;tid&quot; property=&quot;video.id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;title&quot; property=&quot;video.title&quot;&gt;&lt;/result&gt; &lt;result column=&quot;create_date&quot; property=&quot;video.createDate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;video_url&quot; property=&quot;video.videoUrl&quot;&gt;&lt;/result&gt; &lt;result column=&quot;user_id&quot; property=&quot;video.userId&quot;&gt;&lt;/result&gt; &lt;result column=&quot;uid&quot; property=&quot;user.id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;username&quot; property=&quot;user.username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;user.password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;user.birthday&quot;&gt;&lt;/result&gt;&lt;/resultMap&gt;&lt;select id=&quot;getVideoAndUserById2&quot; parameterType=&quot;int&quot; resultMap=&quot;getVideoAndUserById2Map&quot;&gt; select t.id tid,t.title title,t.create_date create_date,t.price price, t.video_url video_url,u.id uid,u.username username,u.password password,u.birthday birthday from t_video t join t_user u on u.id = t.user_id where t.id = #&#123;id&#125;&lt;/select&gt; 补充一下:DTO对象也需要序列化 association专门用来映射一的一方 作用:把查询出来的结果绑定到type指定类型中关联的那个单个对象的某个属性上 resultMap的type指的是sql查询映射结果到videoUserDTO2对象中,这个对象有两个属性分别是user属性和video属性.association的property属性就是指的这个属性,而association的javaType指的是属性对应的实体类.在里面具体的property指定的是实体类的属性. 1234567891011121314151617181920212223&lt;resultMap id=&quot;getVideoAndUserById3Map&quot; type=&quot;videoUserDTO2&quot;&gt; &lt;association property=&quot;video&quot; javaType=&quot;video&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot;&gt;&lt;/result&gt; &lt;result column=&quot;price&quot; property=&quot;price&quot;&gt;&lt;/result&gt; &lt;result column=&quot;create_date&quot; property=&quot;createDate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;video_url&quot; property=&quot;videoUrl&quot;&gt;&lt;/result&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getVideoAndUserById3&quot; parameterType=&quot;int&quot; resultMap=&quot;getVideoAndUserById3Map&quot;&gt; select t.id tid,t.title title,t.create_date create_date,t.price price, t.video_url video_url,u.id uid,u.username username,u.password password,u.birthday birthday from t_video t join t_user u on u.id = t.user_id where t.id = #&#123;id&#125;&lt;/select&gt; resultMap单表的手动映射的结果进行一个单独的封装 - 查所有列 这里将配置放在mapperxml/common-mapper.xml文件中,(这样写是不符合规范滴,只是暂时这样写),还需要在mybatis-config中进行配置. 1&lt;mapper resource=&quot;tech/aistar/mapperxml/comment-mapper.xml&quot;&gt;&lt;/mapper&gt; common-mapper.xml resultMap是可以继承的 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;commentMapper&quot;&gt; &lt;resultMap id=&quot;userIdMap&quot; type=&quot;user&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;userAllMap&quot; type=&quot;user&quot; extends=&quot;userMap&quot;&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;videoIdMap&quot; type=&quot;video&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;videoMap&quot; type=&quot;video&quot;&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot;&gt;&lt;/result&gt; &lt;result column=&quot;create_date&quot; property=&quot;createDate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;price&quot; property=&quot;price&quot;&gt;&lt;/result&gt; &lt;result column=&quot;video_url&quot; property=&quot;videoUrl&quot;&gt;&lt;/result&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;resultMap id=&quot;videoAllMap&quot; type=&quot;video&quot; extends=&quot;videoMap&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;/resultMap&gt;&lt;/mapper&gt; VideoMapper.xml 在association中可以指定resultMap来进行映射.格式是”映射文件的namespace.resultMap的id” 12345678910&lt;resultMap id=&quot;getVideoAndUserById4Map&quot; type=&quot;videoUserDTO2&quot;&gt; &lt;association property=&quot;video&quot; javaType=&quot;video&quot; resultMap=&quot;commonMapper.videoAllMap&quot;&gt;&lt;/association&gt; &lt;association property=&quot;user&quot; javaType=&quot;user&quot; resultMap=&quot;commonMapper.userAllMap&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getVideoAndUserById4&quot; parameterType=&quot;int&quot; resultMap=&quot;getVideoAndUserById4Map&quot;&gt; select t.id tid,t.title title,t.create_date create_date,t.price price, t.video_url video_url,u.id uid,u.username username,u.password password,u.birthday birthday from t_video t join t_user u on u.id = t.user_id where t.id = #&#123;id&#125;&lt;/select&gt; 方法二 - 推荐的写法 回忆jdbc写法 - 对象只会id[Video类 - user_id属性] IVideoDao.java - Video getById(Integer id);//根据id查询视频 select * from t_video where id=? IUserDao.java - User getById(Integer id);//根据用户id查询用户 select * from t_user where id=? 按需加载 - 必须在业务层中进行一个处理了. 12345678910111213141516//IUserDao.javaUser findById(Integer id);//IVideoDao.javaVideo findById(Integer id);//IVideoService.javaVideoVo findVideoUser(Integer id);//VideoServiceImpl.java@Overridepublic VideoVo findVideoUser(Integer id)&#123; VideoVo vo = new VideoVo(); Video v = videoDao.findById(id); User user = userDao.findById(v.getUserId()); vo.setVideo(v); vo.setUser(user); return vo;&#125; 延迟加载懒加载 - 查询多的一方时希望延迟加载出一的一方 迫切加载是不管实际的业务,把数据全部加载出来的情况. 延迟加载:如果只查询视频,是不会查询用户的信息的.如果业务中需要加载出视频对应的user,才会去查询这个视频的用户信息. 配置延迟加载mybatis-config 1234&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;!-- 只要触发对象的equals,clone,hashCode,toString - 延迟效果都会失效了.--&gt;&lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;clone&quot;/&gt; 只要触发了对象的equals,clone,hasCode,toString - 延迟效果都会失效 方法三 - mybatis的特性 - resultMap + association VideoMapper.java 12//延迟加载 - resultMap + associationVideoUserDTO2 getVideoLazyLoadUser(Integer id); VideoMapper.xml 在resultMap中配置video的映射,同时在配置user时使用select指定使用UserMapper中的getById方法,参数是查询出来的user_id. 123456789101112131415&lt;resultMap id=&quot;getVideoLazyLoadUserMap&quot; type=&quot;videoUserDTO2&quot;&gt; &lt;association property=&quot;video&quot; javaType=&quot;video&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot;&gt;&lt;/result&gt; &lt;result column=&quot;price&quot; property=&quot;price&quot;&gt;&lt;/result&gt; &lt;result column=&quot;create_date&quot; property=&quot;createDate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;video_url&quot; property=&quot;videoUrl&quot;&gt;&lt;/result&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;association property=&quot;user&quot; column=&quot;user_id&quot; select=&quot;tech.aistar.mapper.UserMapper.getById&quot;&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id=&quot;getVideoLazyLoadUser&quot; parameterType=&quot;int&quot; resultMap=&quot;getVideoLazyLoadUserMap&quot;&gt; select * from t_video where id = #&#123;id&#125;&lt;/select&gt; 加载多的一方根据用户的id来查询用户信息,顺便加载出该用户下所有的视频信息 collection使用resultMap + collection UserQuerVo.java 123public class UserQueryVo extends User implements Serializable &#123; private List&lt;Video&gt; videoList;&#125; UserMapper.java 123456/** * 根据用户id查询用户信息以及该用户发布的视频信息 * @param id * @return */UserQueryVo findUserWithVideos(Integer id); UserMapper.xml 在数据传输对象中继承了User实体类,所以可以直接通过映射绑定user对象属性.而video对象是通过collection进行绑定的,property指的是userQueryVo中的集合属性名,ofType表示的是集合中存储的video实体类的对象,再进行一一映射. 123456789101112131415161718192021&lt;resultMap id=&quot;findUserWithVideosMap&quot; type=&quot;userQueryVo&quot;&gt; &lt;!-- 处理user对象属性的绑定--&gt; &lt;id column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;videoList&quot; ofType=&quot;video&quot;&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot;/&gt; &lt;result column=&quot;create_date&quot; property=&quot;createDate&quot;/&gt; &lt;result column=&quot;price&quot; property=&quot;price&quot;/&gt; &lt;result column=&quot;video_url&quot; property=&quot;videoUrl&quot;/&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;findUserWithVideos&quot; parameterType=&quot;int&quot; resultMap=&quot;findUserWithVideosMap&quot;&gt; select u.id uid,u.username,u.password,u.birthday,v.* from t_user u left join t_video v on v.user_id = u.id where u.id=#&#123;id&#125;;&lt;/select&gt; mybatis逆向工程由db设计来自动构成entity以及mapper接口以及mapper的映射文件 逆向工程的配置文件是config.xml文件中 - 关键的配置信息 123456&lt;!-- 数据库连接信息 --&gt;&lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/j03s?characterEncoding=utf-8&amp;amp;serverTimezone=UTC&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt;&lt;/jdbcConnection&gt; 123456&lt;!-- targetProject:生成PO类的位置 --&gt;&lt;javaModelGenerator targetPackage=&quot;tech.aistar.entity&quot; targetProject=&quot;src/&quot;&gt;&lt;sqlMapGenerator targetPackage=&quot;tech.aistar.mapper&quot; targetProject=&quot;src/&quot;&gt; 12345678910&lt;!-- 指定数据库表 &lt;domainObjectRenamingRule searchString=&quot;^T&quot; replaceString=&quot;&quot;&gt;&lt;/domainObjectRenamingRule&gt; T一定是大小,表的前缀.t_user,t_video--&gt;&lt;table tableName=&quot;t_user&quot;&gt;&lt;domainObjectRenamingRule searchString=&quot;^T&quot; replaceString=&quot;&quot;&gt;&lt;/domainObjectRenamingRule&gt;&lt;/table&gt;&lt;table tableName=&quot;t_video&quot;&gt;&lt;domainObjectRenamingRule searchString=&quot;^T&quot; replaceString=&quot;&quot;&gt;&lt;/domainObjectRenamingRule&gt;&lt;/table&gt; 如果表设计是不带前缀的,那么直接写即可 1&lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt; 启动startServer Mybatis逆向工程生成的Example使用方式 - api方式来替代手写sql方式 mapper接口的方法 方法 说明 int countByExample(UserExample) 按条件计数 int deleteByPrimaryKey(Integer) 按主键删除 int deleteByExample(UserExample) 按条件查询 String/Integer insert(User) 插入数据(返回值为id) User selectByPrimaryKey(Integer) 按主键查询 List selectByExample(UserExample) 按条件查询 int updateByExampleSelective(User,UserExample) 按条件更新值不为null的字段 int updateByPrimaryKeySelective(User) 按主键更新值不为null的字段 int updateByExample(User , UserExample) 按条件更新 Example方法 方法 说明 example.setOrderByClause(“字段名 asc/desc”) 添加升序排列条件,asc升序,desc降序 example.setDistinct(true/false) 去除重复,true为选择不重复的记录 criteria.andxxxIsNull 添加xxx字段为null的条件 criteria.andxxxIsNotNull 添加xxx字段不为null的条件 criteria.andxxxEqualTo(value) 添加xxx字段等于value的条件 criteria.andxxxNotEqualTo(value) 添加xxx字段不等于value的条件 criteria.andxxxGreaterThan(value) 添加xxx字段大于value的条件 criteria.andxxxGreaterThanOrEqualTo(value) 添加xxx字段大于等于value的条件 criteria.andxxxLessThan(value) 添加xxx字段小于value的条件 criteria.andxxxLessThanOrEqualT(value) 添加xxx字段小于等于value的条件 criteria.andxxxIn(list) 添加xxx字段值在list中的条件 criteria.andxxxNotIn(list) 添加xxx字段值不在list中的条件 criteria.andxxxLike(“%value%”) 添加xxx字段值为value的模糊查询条件 criteria.andxxxNotLike(“%value%”) 添加xxx字段值不为value的模糊查询条件 criteria.andxxxBetween(v1,v2) 添加xxx字段值在v1和v2之间的条件 criteria.andxxxNotBetween(v1,v2) 添加xxx字段值不在v1和v2之间的条件 Example的用法基础用法[以UserExample为例] 123456789UserExample userExample = new UserExample();// 准则UserExample.Criteria criteria = userExample.createCriteria;// 查找//criteria.andUsernameEqualTo(&quot;sakura&quot;);//还可以嵌套criteria.andUsernameLike(&quot;%k%&quot;).andIdGreaterThan(4);// 获取结果List&lt;User&gt; userList = userMapper.selectByExample(userExample); 查询的条件可以为或or,则需要定义两个Criteria对象. 12345678UserExample userExample = new UserExample();UserExample.Criteria c1 = userExample.createCriteria();c1.andIdGreaterThan(3).andUsernameLike(&quot;%k%&quot;);UserExample.Criteria c2 = userExample.createCriteria();c2.andUsernameEqualTo(&quot;admin&quot;);userExample.or(c2);List&lt;User&gt; users = userMapper.selectByExample(userExample);users.forEach(e-&gt; System.out.println(e)); 分页查询利用分页插件进行分页查询,针对单表操作进行分页,针对实体对象进行分页. 导入 - pagehelper-4.1.6.jar,jsqlparser-1.0.jar 分页的动作肯定是在service层进行的 - 将来的动作. 导入jar包以后需要在mybatis-config.xml文件中进行配置 123&lt;plugins&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;&lt;/plugin&gt;&lt;/plugins&gt; 但是如果数据量特别大,分页插件的效率就会变得很低,这时候就要考虑手写分页或者改写分页插件. 方法1.PageHelper.startPage(m,n);//开始分页,m表示读取第m页的数据,每页的数据为n. 2.PageInfo&lt;实体类&gt; pageInfo = new PageInfo&lt;&gt;(实体类集合) 3.List&lt;实体类&gt; lists = pageInfo.getList(); //获取具体的分页结果 4.pageInfo.getPages(); //获取总页数 5.pageInfo.getPageNum(); // 当前页 6.pageInfo.getPageSize(); //每页显示条数 7.pageInfo.getTotal(); //总条数 8.pageInfo.getSize(); //当前页面总条数 demo123456789101112131415161718192021222324252627282930313233@Testpublic void testUserPage()&#123; SqlSession session = null; try &#123; session = MybatisUtil.getSession(); UserMapper userMapper = session.getMapper(UserMapper.class); // pageNow - 当前页,pageSize - 每页显示条数 PageHelper.startPage(2,2); // 有可能是去调用多条件的查询 - 配合动态sql // 针对单标操作进行分页,针对的是实体对象进行分页的. List&lt;User&gt; userList = userMapper.findAll(); PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;&gt;(userList); // 打印信息 System.out.println(&quot;总页数:&quot;+pageInfo.getPages()); System.out.println(&quot;当前页:&quot;+pageInfo.getPageNum()); System.out.println(&quot;每页显示条数:&quot;+pageInfo.getPageSize()); System.out.println(&quot;总条数:&quot;+pageInfo.getTotal()); System.out.println(&quot;当前页总条数:&quot;+pageInfo.getSize()); // 打印具体数据 List&lt;User&gt; pageUser = pageInfo.getList(); for (User user : pageUser) &#123; System.out.println(user); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; MybatisUtil.closeSession(session); &#125;&#125;","categories":[],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://beautifulboyy/tags/mybatis/"}]},{"title":"jdbc拓展","slug":"jdbc04","date":"2021-08-30T08:32:14.000Z","updated":"2021-08-30T09:23:24.639Z","comments":true,"path":"2021/08/30/jdbc04/","link":"","permalink":"http://beautifulboyy/2021/08/30/jdbc04/","excerpt":"","text":"Jdbc拓展Jdbc封装针对单标的万能查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 针对单表的查询操作 * 通用的万能查询,返回的是多个对象 * 能够实现自动封装,表查询结果 - 对象中 * @param c 目标对象的class实例 * @param sql 带有占位符号的sql语句 * @param args 参数列表 - 可以看成数组 * @param &lt;T&gt; * @return */public static &lt;T&gt; List&lt;T&gt; queryList(Class&lt;?&gt; c, String sql, Object...args)&#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; List&lt;T&gt; dataList = new ArrayList&lt;&gt;(); T t = null; try &#123; // 获取连接 conn = PoolUtil.getInstance().getConnection(); // 获取语句对象 pst = conn.prepareStatement(sql); // 传入的sql语句 // 考虑是否需要发送参数 if(null!=args &amp;&amp; args.length&gt;0)&#123; // 表示确实需要发送参数 for (int i = 0; i &lt; args.length; i++) &#123; pst.setObject(i+1,args[i]); &#125; &#125; // 获取结果集对象 rs = pst.executeQuery(); // 结果集元数据 -&gt; 用来获取列的个数和列的名称 ResultSetMetaData rsmd = rs.getMetaData(); // 获取列的个数 int cols = rsmd.getColumnCount(); while (rs.next())&#123; // 获取每一行的结果 // 处理结果 t = (T) c.newInstance(); for (int i = 1; i &lt;= cols; i++) &#123; // 处理某行中每一列的数据 String colName = rsmd.getColumnName(i); colName = changeColName(colName); // 获取属性 Field f = c.getDeclaredField(colName); // 设置权限 f.setAccessible(true); // 对日期类型进行单独的处理 String colType = rsmd.getColumnTypeName(i); if(&quot;DATETIME&quot;.equals(colType))&#123; f.set(t,rs.getTimestamp(i)); &#125;else &#123; f.set(t,rs.getObject(i)); &#125; &#125; dataList.add(t); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtil.close(rs,pst,conn); &#125; return dataList;&#125; 针对单标的增删改操作1234567891011121314151617181920212223242526/** * 针对单标的增删改操作 * @param sql * @param args * @return */public static int update(String sql,Object... args)&#123; Connection conn = null; PreparedStatement pst = null; int count = 0; try &#123; conn = PoolUtil.getInstance().getConnection(); pst = conn.prepareStatement(sql); if(null!=args &amp;&amp; args.length&gt;0)&#123; for (int i = 0; i &lt; args.length; i++) &#123; pst.setObject(i+1,args[i]); &#125; &#125; count = pst.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil.close(null,pst,conn); &#125; return count;&#125; 根据id返回单个对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 根据id查找 * @param c 对象的实例 * @param id 查找的id * @param &lt;T&gt; * @return */public static &lt;T&gt; T findById(Class&lt;?&gt; c, Serializable id)&#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; T t = null; try &#123; // 获取连接 conn = PoolUtil.getInstance().getConnection(); // 创建sql // select * from t_user where id = ? String sql = &quot;select * from t_&quot; + c.getSimpleName().toLowerCase() +&quot; where id = ?&quot;; // 获取语句对象 pst = conn.prepareStatement(sql); // 填充占位符 pst.setObject(1,id); // 获取结果 rs = pst.executeQuery(); if(rs.next())&#123; // 处理结果 t = (T) c.newInstance(); ResultSetMetaData rsmd = rs.getMetaData(); // 获取列数 int cols = rsmd.getColumnCount(); // 遍历每一列 for (int i = 1; i &lt;= cols; i++) &#123; // 获取列名 String colName = rsmd.getColumnName(i); // 处理列名 colName = changeColName(colName); // 获取属性 Field f = c.getDeclaredField(colName); // 设置权限 f.setAccessible(true); // 获取属性数据类型并设置值 String colType = rsmd.getColumnTypeName(i); if(&quot;DATETIME&quot;.equals(colType))&#123; f.set(t,rs.getTimestamp(i)); &#125;else&#123; f.set(t,rs.getObject(i)); &#125; &#125; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil.close(rs,pst,conn); &#125; return t;&#125; 条件查询返回某个单个对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 条件查询,但是只返回单个结果. * @param c * @param args * @param &lt;T&gt; * @return */public static &lt;T&gt; T queryOne(Class&lt;?&gt; c,String sql,Object... args)&#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; T t = null; try &#123; // 获取连接 conn = PoolUtil.getInstance().getConnection(); // 获取语句对象 pst = conn.prepareStatement(sql); // 考虑是不是要设置参数 if(null!=args &amp;&amp; args.length&gt;0)&#123; // 设置参数 for (int i = 0; i &lt; args.length; i++) &#123; // 考虑一下这里的DateTime合理吗? pst.setObject(i+1,args[i]); &#125; &#125; // 获取结果集对象 rs = pst.executeQuery(); if(rs.next())&#123; t = (T) c.newInstance(); // 获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取列的个数 int cols = rsmd.getColumnCount(); // 获取列的名称 for (int i = 1; i &lt;= cols; i++) &#123; String colName = rsmd.getColumnName(i); colName = changeColName(colName); Field f = c.getDeclaredField(colName); f.setAccessible(true); String colType = rsmd.getColumnTypeName(i); if(&quot;DATETIME&quot;.equals(colType))&#123; f.set(t,rs.getTimestamp(i)); &#125;else&#123; f.set(t,rs.getObject(i)); &#125; &#125; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtil.close(rs,pst,conn); &#125; return t;&#125; 根据id删除123456789101112131415161718192021222324252627282930/** * 根据id删除 * @param c * @param id * @return */public static int delById(Class&lt;?&gt; c,Serializable id)&#123; Connection conn = null; PreparedStatement pst = null; int count = 0; try &#123; // 获取连接 conn = PoolUtil.getInstance().getConnection(); // 创建sql语句 // delete from t_video where id = ? String sql = &quot;delete from t_&quot; + c.getSimpleName().toLowerCase()+&quot; where id = ?&quot;; // 预编译 pst = conn.prepareStatement(sql); // 填充占位符 pst.setObject(1,id); // 发送sql count = pst.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil.close(pst,conn); &#125; return count;&#125; 根据实例插入数据123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 保存数据 * @param obj * @return */public static int save(Object obj)&#123; Connection conn = null; PreparedStatement pst = null; int count = 0; try &#123; // 获取连接 conn = PoolUtil.getInstance().getConnection(); // 创建sql // insert into t_video values(...) Class&lt;?&gt; c = obj.getClass(); StringBuilder builder = new StringBuilder(); builder.append(&quot;insert into t_&quot; + c.getSimpleName().toLowerCase() +&quot; values(&quot;); // 根据属性的个数来判断要多少个占位符 Field[] fields = c.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; if(i!=fields.length-1)&#123; builder.append(&quot;?,&quot;); &#125;else&#123; builder.append(&quot;?&quot;); &#125; &#125; builder.append(&quot;)&quot;); //System.out.println(builder.toString()); // 预编译 pst = conn.prepareStatement(builder.toString()); // 填充占位符 // 反射技术来获取每个字段的值 for (int i = 0; i &lt; fields.length; i++) &#123; // 不要忘了设置权限 fields[i].setAccessible(true); pst.setObject(i+1,fields[i].get(obj)); &#125; return pst.executeUpdate(); &#125; catch (SQLException | IllegalAccessException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil.close(pst,conn); &#125; return count;&#125; jdbc缺陷 涉及到查询语句 - 手动封装的过程 - 麻烦 持久层的框架 - Hibernate全自动的ORM框架 - 可以实现完全的自动封装的过程. Mybatis半自动的ORM框架 - 查询的结果 - 有的需要手动封装,有的可以自动封装. 框架 - 为了解决某一领域里的问题而提供的一套解决方案. sql语句会硬编码到了程序中了.java代码和sql语句耦合在一块儿了.不利于后期的sql语句的优化 如果后期需要对sql进行优化,还需要对java代码重新编译 - 重新打包 - 重新部署. 实体类的设计开发中严格按照这个要求. 表名要么就和类名保持一致,要么就使用统一的前缀. 列名-属性名高度保持一致-全部小写以及多个单词一定采用匈牙利命名xxx_yyy_zzz 尤为重要的 - 对象之间的关系不再是采用之前的那样的强耦合的关系呢! 案例表设计1234567891011121314151617181920212223242526272829303132-- 用户表drop table t_user;create table t_user( id int(7) primary key auto_increment, username varchar(20) unique not null, password varchar(20) not null, birthday date);insert into t_user values(1,&#x27;admin&#x27;,&#x27;123&#x27;,now());insert into t_user values(2,&#x27;tom&#x27;,&#x27;123&#x27;,now());insert into t_user values(3,&#x27;lucy&#x27;,&#x27;123&#x27;,now());insert into t_user values(4,&#x27;jack&#x27;,&#x27;234&#x27;,now());insert into t_user values(5,&#x27;sakura&#x27;,&#x27;567&#x27;,now());-- 视频表 一个用户可以发布多个视频drop table t_video;create table t_video( id int(7) primary key auto_increment,title varchar(20) not null,create_date datetime,price double(7,2),video_url varchar(120),-- 不需要创建外键约束,但是仍然需要通过user_id确定和t_user表的关系-- Video实体类中 - private User user;-- User实体类 - private List&lt;Video&gt; videos;user_id int(7));insert into t_video values(1,&#x27;娱乐圈需要整顿&#x27;,now(),10.0,&#x27;http://aistar/001.mp4&#x27;,1);insert into t_video values(2,&#x27;新概念吃播&#x27;,now(),20.0,&#x27;http://aistar/002.mp4&#x27;,1);insert into t_video values(3,&#x27;花少北的一百个圈套&#x27;,now(),30.0,&#x27;http://aistar/003.mp4&#x27;,2);insert into t_video values(4,&#x27;双镜yyds&#x27;,now(),40.0,&#x27;http://aistar/004.mp4&#x27;,4);insert into t_video values(5,&#x27;千层套路你&#x27;,now(),1000.0,&#x27;http://aistar/005.mp4&#x27;,4); 实体类设计1234567891011121314151617public class User&#123; private Integer id; private String username; private String password; private Date birthday; //不需要进行视频信息的集合的维护...&#125;public class Video&#123; private Integer id; private String title; private Date createDate; private Double price; private String videoUrl; //表中的外键是什么,此处就写什么. private Integer userId;&#125; 级联查询思路: 先根据用户id查询出用户出来 根据用户id[user_id]去查询视频表 需要使用第三方DTO对象来建立User和Video的关系 指定业务层接口 - 完成数据的绑定 123456789// 第三方DTO - 不推荐使用继承,推荐使用第二种方法public class UserDTO2 extends User&#123; private List&lt;Video&gt; videoList;&#125;// 第二种方式public class UserDTO2&#123; private User user; private List&lt;Video&gt; videoList;&#125; IUserDao 1User findById(Integer id); UserDaoImpl 1234@Overridepublic User findById(Integer id) &#123; return JdbcNBUtil.findById(User.class,id);&#125; IVideoDao 1List&lt;Video&gt; findByUserId(Integer userId); VideoDaoImpl 1234@Overridepublic List&lt;Video&gt; findByUserId(Integer userId) &#123; return JdbcNBUtil.queryList(Video.class,&quot;select * from t_video where user_id = ?&quot;,userId);&#125; IUserService 1UserDTO2 loadById(Integer id); UserServiceImpl 123456789101112131415161718public class UserServiceImpl implements IUserService &#123; private IUserDao userDao = new UserDaoImpl(); private IVideoDao videoDao = new VideoDaoImpl(); @Override public UserDTO2 loadById(Integer id) &#123; UserDTO2 userDTO2 = new UserDTO2(); User user = userDao.findById(id); userDTO2.setUser(user); List&lt;Video&gt; videos = videoDao.findByUserId(id); // 判断是否有视频 if(null!=videos &amp;&amp; videos.size()&gt;0)&#123; // 绑定 userDTO2.setVideoList(videos); &#125; return userDTO2; &#125;&#125; 级联删除IUserDao 1int delById(Integer id); UserDaoImpl 1234@Overridepublic int delById(Integer id) &#123; return JdbcNBUtil.delById(User.class,id);&#125; IVideoDao 1int delByUserId(Integer userId); VideoDaoImpl 1234@Overridepublic int delByUserId(Integer userId) &#123; return JdbcNBUtil.update(&quot;delete from t_video where user_id = ?&quot;,userId);&#125; IUserService 1int delAllById(Integer id); UserServiceImpl 123456@Overridepublic int delAllById(Integer id) &#123; // 先删除多的一方 videoDao.delByUserId(id); return userDao.delById(id);&#125;","categories":[],"tags":[]},{"title":"数据库连接池","slug":"jdbc03","date":"2021-08-25T06:47:49.000Z","updated":"2021-08-30T13:40:19.576Z","comments":true,"path":"2021/08/25/jdbc03/","link":"","permalink":"http://beautifulboyy/2021/08/25/jdbc03/","excerpt":"","text":"数据库连接池DriverManager方式缺陷在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接， 那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。 连接池连接池的选择JDBC连接池有一个标准的接口javax.sql.DataSource，注意这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，我们必须选择一个JDBC连接池的实现。常用的JDBC连接池有： HikariCP C3P0 BoneCP Druid - 阿里的 dbcp 连接池的基本原理数据库连接池的基本思想就是为数据库连接 建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。我们可以通过设定 连接池最大连接数来防止系统无尽的与数据库连接。更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量?使用情况，为系统开发?测试及性能调 整提供依据。 连接池的工作原理连接池的工作原理主要由三部分组成，分别为连接池的建立、连接池中连接的使用管理、连接池的关闭。 连接池的创建 一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector[线程安全的类]、Stack等。 连接池连接的使用管理 连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。 当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反 为什么要使用连接池数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 相关配置 maxActive 连接池支持的最大连接数，这里取值为20，表示同时最多有20个数据库连接。一般把maxActive设置成可能的并发量就行了设 0 为没有限制。 maxIdle 连接池中最多可空闲maxIdle个连接 ，这里取值为20，表示即使没有数据库连接时依然可以保持20空闲的连接，而不被清除，随时处于待命状态。设 0 为没有限制。 minIdle 连接池中最小空闲连接数，当连接数少于此值时，连接池会创建连接来补充到该值的数量 initialSize 初始化连接数目 maxWait 连接池中连接用完时,新的请求等待时间,毫秒，这里取值-1，表示无限等待，直到超时为止，也可取值9000，表示9秒后超时。超过时间会出错误信息 代理模式 静态代理 动态代理 - jdk动态代理[Spring底层默认的代理模式]以及cglib代理 jdk动态代理只能代理接口 需求给dao层中的每个方法添加日志输出 不使用代理ITeacherDao 1234567public interface ITeacherDao &#123; void save(); int delById(Integer id);&#125; TeacherDaoImpl 12345678910111213141516171819202122232425262728public class TeacherDaoImpl implements ITeacherDao&#123; @Override public void save() &#123; // 与业务无关的方法 - 日志记录 // 维护性很差 System.out.println(&quot;log-before...&quot;+new Date()); // 核心代码 System.out.println(&quot;jdbc...insert&quot;); // 日志记录 System.out.println(&quot;log-after...&quot; + new Date()); &#125; @Override public int delById(Integer id) &#123; System.out.println(&quot;log-before...&quot;+new Date()); // 核心代码 System.out.println(&quot;jdbc...del&quot;); // 日志记录 System.out.println(&quot;log-after...&quot; + new Date()); return 0; &#125;&#125; 静态代理在程序的编译期间,手动编写静态代理类 =&gt; 并且在编译期就得生成这个静态代理类. 优点:将核心的代码和非核心的代码[日志代码]进行了分离.不会导致核心的代码显示得比较臃肿了. 缺点 程序中会出现大量的静态代理类[增加了维护成本]. 如果日志格式需要改变.需要修改很多静态代理类中的代码的.对于静态代理类而言的.违背了软件的”开闭原则”. 代理对象和被代理对象都应该去实现同一个接口 - 在实际应用的时候,是使用代理对象去调用接口的 TeacherDaoImpl 1234567891011121314public class TeacherDaoImpl implements ITeacherDao&#123; @Override public void save() &#123; // 仅包含核心代码 System.out.println(&quot;jdbc..insert&quot;); &#125; @Override public int delById(Integer id) &#123; // 仅包含核心代码 System.out.println(&quot;jdbc...delete&quot;); return 0; &#125;&#125; TeacherDaoImplProxy 1234567891011121314151617181920212223242526272829303132public class TeacherDaoImplProxy implements ITeacherDao&#123; private ITeacherDao teacherDao; public TeacherDaoImplProxy() &#123; // 构建一个代理对象的同时初始化被代理的对象 teacherDao = new TeacherDaoImpl(); &#125; @Override public void save() &#123; // 日志记录 System.out.println(&quot;log-before&quot;); teacherDao.save(); // 日志记录 System.out.println(&quot;log-after&quot;); &#125; @Override public int delById(Integer id) &#123; // 日志记录 System.out.println(&quot;log-before&quot;); teacherDao.delById(id); // 日志记录 System.out.println(&quot;log-after&quot;); return 0; &#125;&#125; 动态代理 不需要在编译期间手动编写代理类 是在程序的运行期间,反射创建的代理对象 jdk动态代理只能代理接口 总结:使用动态代理对象调用的方法应该是比你原始对象去调用方法的功能更加强大 ProxyHandler 1234567891011121314151617181920212223242526272829public class ProxyHandler implements InvocationHandler &#123; // jdk动态代理技术只能代理接口 private Object obj; //被代理的原始对象 public ProxyHandler(Object obj) &#123; this.obj = obj; &#125; /** * invoke方法被调用的时机: * 当使用代理对象调用被代理对象中的方法的时候[save,del] * 会自动执行invoke方法 * 如果调用的是ITeacherDAo中的save方法 * @param proxy 程序运行过程中的代理对象 * @param method 当前正在调用接口中的那个方法对应的反射的Method实例 * @param args 被调用的方法的参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;log-before&quot;); Object result = method.invoke(obj,args); System.out.println(&quot;log-after&quot;); return result; &#125;&#125; TestProxyHandler 123456789101112131415161718public static void main(String[] args) &#123; // 1.构建原始对象 ITeacherDao teacherDao = new TeacherDaoImpl(); // 2.构建ProxyHandler对象 ProxyHandler handler = new ProxyHandler(teacherDao); // 3.程序的运行过程中如何去构建ITeacherDao的接口的代理对象呢 //ClassLoader loader - 被代理接口的类加载器 // Class&lt;?&gt;[] interfaces - 父接口的Class类型数据 // InvocationHandler - ProxyHandler ITeacherDao proxy = (ITeacherDao) Proxy.newProxyInstance(teacherDao.getClass().getClassLoader(),teacherDao.getClass().getInterfaces(),handler); proxy.save(); System.out.println(proxy.getClass()); int id = proxy.delById(200); System.out.println(id);&#125; 使用第三方连接池连接池[实现类]本身就是jdk提供的java.sql.DataSource接口的具体的实现类[BasicDataSource]. 连接池本身就是属于一个昂贵的重量级的对象,不要轻易去关闭它. 整个应用程序中,一个连接池对应一个db数据库 - 连接池叫做数据源.保证连接池的单例. 步骤 导入jar包 连接池的配置文件,配置参数建议是放在配置文件中统一进行管理的. db.properties 12345678910# 系统初始化的时候,连接池中可用的连接的初始个数initialSize = 3# 连接池中最小空闲连接数minIdle = 5# 连接池中最大空闲连接数maxIdle = 15# 连接池支持的最大连接数[一般和最大空闲连接数保持一致]maxActive = 15# 连接池中连接用完时,新的请求等待时间,毫秒maxWait = 5000 编写连接池类 - 单例的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.util;import org.apache.commons.dbcp.BasicDataSource;import java.sql.Connection;import java.sql.SQLException;/** * @Author liuWenXiu * @Date 2021/8/29 17:40 * @description 连接池类,设置参数 */public class PoolUtil &#123; private static volatile PoolUtil instance; private BasicDataSource basicDataSource; public PoolUtil()&#123; // 连接池的配置工作 basicDataSource = new BasicDataSource(); basicDataSource.setUrl(&quot;jdbc:mysql://localhost:3306/j03s?useSSL=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true&quot;); basicDataSource.setUsername(&quot;root&quot;); basicDataSource.setPassword(&quot;123456&quot;); //设置参数 basicDataSource.setInitialSize(Integer.valueOf(DBPropUtil.getValue(DBPropEnum.initialSize.getSign()))); basicDataSource.setMaxIdle(Integer.valueOf(DBPropUtil.getValue(DBPropEnum.maxIdle.getSign()))); basicDataSource.setMinIdle(Integer.valueOf(DBPropUtil.getValue(DBPropEnum.minIdle.getSign()))); basicDataSource.setMaxActive(Integer.valueOf(DBPropUtil.getValue(DBPropEnum.maxActive.getSign()))); basicDataSource.setMaxWait(Long.valueOf(DBPropUtil.getValue(DBPropEnum.maxWait.getSign()))); &#125; public static PoolUtil getInstance()&#123; if(null==instance)&#123; synchronized (PoolUtil.class)&#123; if(null==instance)&#123; instance = new PoolUtil(); &#125; &#125; &#125; return instance; &#125; // 获取连接 public Connection getConnection() throws SQLException &#123; return basicDataSource.getConnection(); &#125;&#125; 自己写一个连接池 创建一个单例的连接池类,在类中定义最大连接数,初始化连接数,连接池中的数目,正在使用的连接数,最大空闲数,连接池[链表]以及一个实例. 私有化构造方法,在构造方法中按照初始化连接数的大小创建连接并且放到连接池中. 静态方法返回该类的唯一实例. 创建连接的方法Connection createConnection() 获取连接的方法Connection getConnection(); MyDataSource 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package tech.aistar.mypools;import tech.aistar.proxy.demo3.ProxyHandler;import tech.aistar.util.JdbcUtil;import tech.aistar.util.PoolUtil;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.Connection;import java.sql.SQLException;import java.util.LinkedList;/** * @Author liuWenXiu * @Date 2021/8/30 15:29 * @description 简化的连接池 * 连接池是单例的 */public class MyDataSource &#123; public int maxActive = 10; //最大连接数 public int initialSize = 3; //初始化连接数量 public int activeSize = initialSize; //连接池中的数目 public int currSize = 0; //正在使用的连接数 public int maxIdle = 5; // 最大空闲数 public LinkedList&lt;Connection&gt; pools = new LinkedList&lt;&gt;(); //连接池对象 private static MyDataSource instance = null; // 私有化构造 private MyDataSource()&#123; // 初始化连接数量有几个就创建几个 for (int i = 0; i &lt; initialSize; i++) &#123; pools.add(createConnection()); &#125; &#125; // 获取实例 public static MyDataSource getInstance()&#123; if(null == instance)&#123; synchronized (MyDataSource.class)&#123; if(null == instance)&#123; instance = new MyDataSource(); &#125; &#125; &#125; return instance; &#125; // 创建连接 public Connection createConnection() &#123; Connection connProxy = null; try &#123; // 获取连接 Connection conn = JdbcUtil.getConnection(); // 获取代理对象 connProxy = (Connection) Proxy.newProxyInstance(conn.getClass().getClassLoader(), conn.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 只要使用代理对象调用目标接口Connection接口的任何方法,都会执行invoke方法 Object result = null; // 根据传入的method名称进行判断,如果是close则进行处理,如果不是则直接调用invoke方法 String methodName = method.getName(); if (&quot;close&quot;.equals(methodName)) &#123; // 表示是close方法,需要进行处理 // 如果连接池中当前数量小于最大空闲数量 if (activeSize &lt; maxIdle) &#123; // 则直接将该连接放回连接池中 System.out.println(&quot;放回到连接池中,连接池中空闲数目为:&quot; + (++activeSize) + &quot;.此时正在使用的连接数为:&quot; + (--currSize)); pools.add(conn); &#125; else &#123; // activeSize &gt;= maxActive 表示连接池的空闲连接已经满了,需要进行销毁 System.out.println(&quot;销毁连接,连接池中空闲数目为:&quot; + activeSize + &quot;.此时正在使用的连接数为:&quot; + (--currSize)); if (null != conn) &#123; conn.close(); &#125; &#125; &#125; else &#123; // 是其他方法,可能是commit等 result = method.invoke(conn, args); &#125; return result; &#125; &#125;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connProxy; &#125; // 获取连接 public Connection getConnection()&#123; // 连接池是共享资源,需要锁住 - 保证多线程情况下不会出现两个线程竞争同一个连接 synchronized (pools)&#123; if(activeSize &gt; 0)&#123; // 如果连接池中存在空闲的连接,那么直接从连接池中获取连接 System.out.println(&quot;从连接池中获取连接,获取后连接池空闲数目为:&quot;+(--activeSize)+&quot;.此时正在使用的连接数为:&quot;+(++currSize)); return pools.removeLast(); &#125;else if(currSize &lt;= maxActive)&#123; // 连接池中已经不存在空闲的连接,则需要创建连接 System.out.println(&quot;新建连接,创建后连接池空闲数目为:&quot;+activeSize+&quot;.此时正在使用的连接数为:&quot;+(++currSize)); return createConnection(); &#125;else &#123; // 否则如果超过最大连接数,报异常 throw new RuntimeException(&quot;抱歉,连接数已经全部被占用,请稍等...&quot;); &#125; &#125; &#125;&#125; TestMyDataSource 123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.mypools;import java.sql.Connection;import java.sql.SQLException;/** * @Author liuWenXiu * @Date 2021/8/30 18:47 * @description */public class TestMyDataSource &#123; public static void main(String[] args) &#123; MyDataSource myDataSource = MyDataSource.getInstance(); Connection conn = myDataSource.getConnection(); //System.out.println(&quot;最大连接数:&quot;+myDataSource.maxActive); Connection conn2 = myDataSource.getConnection(); Connection conn3 = myDataSource.getConnection(); Connection conn4 = myDataSource.getConnection(); Connection conn5 = myDataSource.getConnection(); Connection conn6 = myDataSource.getConnection(); Connection conn7 = myDataSource.getConnection(); Connection conn8 = myDataSource.getConnection(); try &#123; conn2.close(); conn3.close(); conn4.close(); conn5.close(); conn8.close(); conn7.close(); conn6.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819运行结果:从连接池中获取连接,获取后连接池空闲数目为:2.此时正在使用的连接数为:1从连接池中获取连接,获取后连接池空闲数目为:1.此时正在使用的连接数为:2从连接池中获取连接,获取后连接池空闲数目为:0.此时正在使用的连接数为:3新建连接,创建后连接池空闲数目为:0.此时正在使用的连接数为:4新建连接,创建后连接池空闲数目为:0.此时正在使用的连接数为:5新建连接,创建后连接池空闲数目为:0.此时正在使用的连接数为:6新建连接,创建后连接池空闲数目为:0.此时正在使用的连接数为:7新建连接,创建后连接池空闲数目为:0.此时正在使用的连接数为:8放回到连接池中,连接池中空闲数目为:1.此时正在使用的连接数为:7放回到连接池中,连接池中空闲数目为:2.此时正在使用的连接数为:6放回到连接池中,连接池中空闲数目为:3.此时正在使用的连接数为:5放回到连接池中,连接池中空闲数目为:4.此时正在使用的连接数为:4放回到连接池中,连接池中空闲数目为:5.此时正在使用的连接数为:3销毁连接,连接池中空闲数目为:5.此时正在使用的连接数为:2销毁连接,连接池中空闲数目为:5.此时正在使用的连接数为:1Process finished with exit code 0","categories":[],"tags":[{"name":"连接池","slug":"连接池","permalink":"http://beautifulboyy/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}]},{"title":"jdbc基础(二)","slug":"jdbc02","date":"2021-08-25T06:47:36.000Z","updated":"2021-08-28T14:04:07.122Z","comments":true,"path":"2021/08/25/jdbc02/","link":"","permalink":"http://beautifulboyy/2021/08/25/jdbc02/","excerpt":"","text":"元数据DataBaseMetaData - 数据库的元数据 - 可以获取数据库的元新信息 - url,user,driver,版本号等信息 12java.sql.Connection提供的DataBaseMetaData getMentaData(); ResultSetMetalData - 结果集元数据 - 可以获取结果集的元信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package tech.aistar.day03;import tech.aistar.util.JdbcUtil;import java.sql.*;/** * @Author liuWenXiu * @Date 2021/8/28 20:22 * @description */public class ResultSetMetaDataDemo &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; try &#123; conn = JdbcUtil.getConnection(); String sql = &quot;select id,title from t_video&quot;; // 可以生成滚动和可更新的ResultSet对象 pst = conn.prepareStatement(sql); // 本质上是一个光标,默认停留在第一行的上方 rs = pst.executeQuery(); // 描述结果集的 - 结果集的元数据[描述数据的数据] ResultSetMetaData rsmd = rs.getMetaData(); // 查询结果:列的个数 int cols = rsmd.getColumnCount(); for (int i = 1; i &lt;= cols; i++) &#123; // 获取列的标题名称 注意下标是从1开始的 String colName = rsmd.getColumnName(i); System.out.print(colName+&quot;\\t&quot;); &#125; System.out.println(); while (rs.next())&#123; for (int i = 1; i &lt;= cols ; i++) &#123; System.out.print(rs.getString(i)+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil.close(rs,pst,conn); &#125; &#125;&#125; 重新认识ResultSet构建一个可滚动可更新的结果集对象 可以任意定位到具体的行 直接使用rs对象来进行update和delete以及insert操作 本质上是一个光标,默认是停留在第一行的上方 boolean next(); //向下移动一行 boolean absolute(int row); //绝对定位到行 boolean first(); //定位到第一行 boolean last(); //定位到最后一行 boolean relative(int n); //相对定位 updateString(列名,值); // 更新数据 deleteRow(); //删除数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package tech.aistar.day03;import tech.aistar.util.JdbcUtil;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @Author liuWenXiu * @Date 2021/8/28 21:51 * @description */public class ResultSetDemo &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; try &#123; conn = JdbcUtil.getConnection(); String sql = &quot;select * from t_video&quot;; // 可以生成可滚动和可更新的ResultSet对象 pst = conn.prepareStatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE); rs = pst.executeQuery(); // 绝对定位默认是不支持的,正常情况下只能从第一行到最后一行迭代一次. // 设置了可以生成可滚动和可更新的ResultSet对象以后才可以使用绝对定位 // 绝对定位到第三行 rs.absolute(3); System.out.println(rs.getString(2)); // 相对定位 往前移动一行,到了第二行 rs.relative(-1); System.out.println(rs.getString(2)); // 定位到第一行 rs.first(); System.out.println(rs.getString(2)); //定位到最后一行 rs.last(); System.out.println(rs.getString(2)); // 还可以通过光标来进行update和delete操作 // 更新第三行的title rs.absolute(3); rs.updateString(&quot;title&quot;,&quot;suxi&quot;); //commit rs.updateRow(); // 删除行 //rs.deleteRow(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil.close(rs,pst,conn); &#125; &#125;&#125;","categories":[],"tags":[{"name":"jdbc","slug":"jdbc","permalink":"http://beautifulboyy/tags/jdbc/"}]},{"title":"jdbc基础(一)","slug":"jdbc01","date":"2021-08-25T06:47:30.000Z","updated":"2021-09-03T01:23:38.995Z","comments":true,"path":"2021/08/25/jdbc01/","link":"","permalink":"http://beautifulboyy/2021/08/25/jdbc01/","excerpt":"","text":"JDBCJDBC概述 jdbc - java database connectivity - java数据库连接 使用java编写的程序来访问数据库的技术.优势在于可以使用同一套java代码来访问市面上不同的数据库. 作用:为访问不同的数据库来提供统一的方式. 市面上主流的关系型数据库:sqlserver,oracle,mysql 非关系型数据库:文档型数据库 - mongodb.键值对数据库-redis 属于早期的JAVAEE[jakartaEE]十三种核心技术中的一种. 这个技术已经被淘汰了.属于**持久层[数据访问层 - 和DB交互的层]**的最传统的技术.持久层框架的底层都是采用的jdbc技术. 市面上有很多持久层的框架,主流的ORM[Object Relation Mapping 对象关系映射]框架. ORM本质上是一个思想,在这个思想下诞生了很多ORM框架[实际上就是ORM思想的实现者] 3-1. 非移动互联网时代 - Hibernate框架[全自动的ORM框架 - 不需要写sql语句 - 不能进行sql优化] 3-2. 大数据时代 - **Mybatis[**半自动的ORM框架,需要写sql,但是相对于jdbc技术稍微简单一点,可以进行sql优化] 3-3. 国产的Mybatis-plus框架 - 又是对Mybatis的进一步的封装 核心apiDriver驱动接口 - 驱动实现类是各个db厂商去实现的. 1.java.sql.Driver[I] 驱动jar - mysql-connector-java-8.0.25.jar - 本质就是对sun公司制定的Driver接口的实现类. 想要使用哪个db厂商的db,那么就导入哪个db的驱动jar. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657-- 历史-- java-sun公司-oracle公司收购了[oracle数据库-收费]伪代码 java-oracle//jdbc编程第一步 - 创建一个驱动类对象OracleDriver driver = new OraclerDiver();-- java语言发展壮大了,mysql原先是不属于oracle.-- java-mysqlMysqlDriver driver = new MysqlDriver();//代码的可维护性不是太好.java代码不能随便切换数据库了;//因为db厂商不一样[类,接口命名都不一样]//有多少个db,就得写多少套java代码//sun考虑到这一点,制定了一系列的接口[居多]和类//接口作用就是用来指定一个规范,&quot;契约&quot;.//jdk-api - 查得到java.sql.Driver[I]//sun - db厂商下的db要和java交互的.必须遵守我的规范.你们这些db厂商只要给我实现这个规范接口.public interface Driver&#123; Driver getInstance();&#125;//oracle遵守规范//sqlserver,mysql遵守规范public class OracleDriver implements Driver&#123; @Override public Driver getIntance()&#123; //db是不同的,每个厂商程序根据具体的db产品来的 //具体的实现肯定是由db厂商去实现... return new OracleDriver(); &#125;&#125;//sqlserver - mspublic class SqlServerDriver implements Driver&#123; @Override public Driver getIntance()&#123; //db是不同的,每个厂商程序根据具体的db产品来的 //具体的实现肯定是由db厂商去实现... return new SqlServerDriver(); &#125;&#125;//每个db厂商就会把这些实现类全部打包 - mysql-connector-java-8.0.25.jar//java = oracle//多态 - 面向接口编程//---&gt; 反射实现 ---Driver driver = XXX.getInstance(); DriverManager[C]sun - java.sql.DriverManager[C] - 驱动管理类,管理注册驱动.通过驱动管理类来获取DB连接 123456789url - 不同的数据库 - url是不一样的user - db用户名password - db密码public static Connection getConnection(String url, String user, String password); String url = &quot;jdbc:mysql://localhost:3306/j03s?useSSL=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;;String user = &quot;root&quot;;String password = &quot;123456&quot;;conn = DriverManager.getConnection(url,user,password); 数据库连接url的设置1.主协议:次协议://数据库主机地址:数据库端口号/db名称?连接属性key=连接属性值 比如jdbc:mysql://localhost:3306/数据名?key1=value1&amp;key2=value2… 2.常见的url的设置如下 123456789101112jdbc:mysql://localhost:3306/j03s-- 高版本的需要设置useSSL=true,否则会报警告jdbc:mysql://localhost:3306/j03s?useSSL=true-- 设置编码jdbc:mysql://localhost:3306/j03s?useSSL=true&amp;characterEncoding=utf-8-- 继续设置时区-- 世界的标准时区 - UTC-- 中国的标准时区 - Asia/Shanghaijdbc:mysql://localhost:3306/j03s?useSSL=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai Connection[I]连接对象.和db进行一次会话 Statetement createStatement();//获取语句对象 Statement[I]语句对象 - 作用-负责将sql语句发送给mysql-server端进行sql编译和解释 如果发送的是dql语句,mysql-server会将查询的结果返回,封装到一个ResultSet对象中. sun - java.sql.Statement[I] 121. int executeUpdate(String sql);//执行的是dml操作,返回的是受影响的行数2. ResultSet executeQuery(String sql);//执行的dql操作.处理结果集对象ResultSet ResultSet[I]本质上一个游标-光标,默认是在标题行,在数据行的上方.比如要想取第一行的数据,应该是要将这个游标向下移动一行. booelan next();//向下移动一行.如果下一行没有数据行了,自动返回false int getInt(int index);//比如id列是int型,序号是从1开始的 12345select id,first_name fname from s_emp;rs.next();int id = rs.getInt(1);String first_name = rs.getString(2); String getString(int index);//比如name列是varchar int getInt(String colName);//根据列的名称去取 12int id = rs.getInt(&quot;id&quot;);String firstName = rs.getString(&quot;fname&quot;); jdbc编程步骤 加载驱动 - 加载驱动实现类 - Driver 获取连接 - 和db进行连接 - DriverManager 获取语句对象Statement 写sql语句 由语句对象将sql发送到mysql-server,如果执行的是DQL操作,还需要对结果集进行处理.. 处理结果集 - 通过光标来获取表中的数据 - ResultSet 关闭对象 - ResultSet,Statement,Connection - 注意顺序 demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package tech.aistar.day01;import javax.xml.transform.Result;import java.sql.*;/** * @Author liuWenXiu * @Date 2021/8/25 13:53 * @description 六大编程步骤 */public class HelloJdbcDemo &#123; public static void main(String[] args) &#123; // 1.加载驱动 - 把驱动类加载到java内存中 // 但是jdbc4.0规范及其以后 - 加载驱动的代码可以省略不写,默认加载 Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 2. 获取连接 - 通过DriverManager类提供的getConnection来进行获取 // 为了关闭资源,将变量的声明写在try外面 // 2-1 准备三个参数 url,user,password String url = &quot;jdbc:mysql://localhost:3306/j03s?useSSL=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; conn = DriverManager.getConnection(url,user,password); // 3.创建语句对象 st = conn.createStatement(); // st负责将sql语句发送到mysql-server端进行sql编译和解释 // 4. 发送sql String sql = &quot;select id,first_name,salary from s_emp&quot;; // 4-1. 因为执行的是DQL,所以返回一个结果集对象 rs = st.executeQuery(sql); // 5. 如果是DQL语句,则需要处理一下结果集 // 结果集对象ResultSet实际上是一个光标,停留在标题行的上方 // 调用next方法的时候,光标就会向下移动一行,如果下面没有数据航的时候,自动返回false while (rs.next())&#123; // 获取查询语句中的数据 注意一下调用的类型 /* int -&gt; getInt varchar -&gt; getString date -&gt; getDate float/double -&gt; getDouble getString可以获取任意类型的列 */ // 根据序号取!!!!注意不是根据原表中的序号,是根据查询列的序号 // 序号从1开始 int id = rs.getInt(1);; String firstName = rs.getString(&quot;first_name&quot;); double salary = rs.getDouble(3); System.out.println(id+&quot;\\t&quot;+firstName+&quot;\\t&quot;+salary); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null!=rs)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(null!=st)&#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(null!=conn)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; ORM+OO分析OO设计表123456789101112drop table t_user;create table t_user( id int(7) primary key auto_increment, username varchar(20) unique not null, password varchar(20) not null, birthday date);insert into t_user values(1,&#x27;admin&#x27;,&#x27;123&#x27;,now());insert into t_user values(2,&#x27;tom&#x27;,&#x27;123&#x27;,now());insert into t_user values(3,&#x27;lucy&#x27;,&#x27;123&#x27;,now());insert into t_user values(4,&#x27;jack&#x27;,&#x27;234&#x27;,now());insert into t_user values(5,&#x27;sakura&#x27;,&#x27;567&#x27;,now()); ORM12345表 - 实体主键列id 对象标识id普通列 普通属性外键 对象与对象之间的关系 - 对象之间是没有什么关键关系 要么关联单个对象/集合对象 int -&gt; Integervarchar -&gt; Stringfloat/double -&gt; Doubledate/datetime -&gt; java.util.Date 12345678910public class User implements Serializable &#123; //实体类中的属性都是根据db设计来写的 private Integer id; private String username; private String password; private Date birthday;&#125; 指定业务接口IUserDao.java 1234public interface IUserDao &#123; //具体的操作功能 List&lt;User&gt; findAll();&#125; 接口实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package tech.aistar.dao.impl;import tech.aistar.dao.IUserDao;import tech.aistar.entity.User;import java.sql.*;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/25 14:36 * @description 持久层的实现类 - jdbc代码 */public class UserDaoImpl implements IUserDao &#123; @Override public List&lt;User&gt; findAll() &#123; // 编程六大步骤 // 1. 加载驱动 - 可以省略 Connection conn = null; Statement st = null; ResultSet rs = null; List&lt;User&gt; users = new ArrayList&lt;&gt;(); try &#123; // 2. 获取连接 String url = &quot;jdbc:mysql://localhost:3306/j03s?useSSL=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; conn = DriverManager.getConnection(url,user,password); // 3.创建语句对象 st = conn.createStatement(); // 4.发送sql语句 String sql = &quot;select * from t_user&quot;; // 5.处理结果集 rs = st.executeQuery(sql); while (rs.next())&#123; int id = rs.getInt(1); String username = rs.getString(2); String pwd = rs.getString(3); Date birthday = rs.getDate(4); // 获取实体类对象 User u = new User(); u.setId(id); u.setUsername(username); u.setPassword(pwd); u.setBirthday(birthday); // 添加进集合中 users.add(u); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 if(null!=rs)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(null!=st)&#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(null!=conn)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return users; &#125;&#125; 单元测试Junit在项目根目录下新建一个test目录 - 右击它 - mark direcotry as - Test Sources Root 1234567891011121314151617181920212223package tech.aistar.dao;import org.junit.Test;import tech.aistar.dao.impl.UserDaoImpl;import tech.aistar.entity.User;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/25 14:43 * @description 针对IUserDao接口中方法进行逐一单元测试 */public class UserDaoTest &#123; IUserDao userDao = new UserDaoImpl(); @Test public void testFindAll()&#123; List&lt;User&gt; userList = userDao.findAll(); userList.forEach(System.out::println); &#125;&#125; DTODTO - Data Transfer Object - 数据传输对象 当内存中的数据没有任何一个实体类可以绑定的时候,那么可以考虑创建第三方实体类,用来作为数据交互的容器 - DTO DTO对象它是不需要和表进行映射的,它是只在内存中进行传输的. 业务逻辑层 - service 数据持久层 - dao - dao接口 - 只负责和db进行交互 - sql语句 - 关注点在”db和数据的crud” 业务逻辑层 - service - service接口 - 不需要和db进行交互,把dao层交互得到的数据进行业务逻辑的处理,不需要写sql service层需要调用dao层 - service关注点在”业务逻辑” 第一层封装 - JdbcUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.util;import java.sql.*;/** * @Author liuWenXiu * @Date 2021/8/25 18:34 * @description jdbc工具类 */public class JdbcUtil &#123; /** * 获取连接 * @return */ public static Connection getConnection() throws SQLException &#123; String url = &quot;jdbc:mysql://localhost:3306/j03s?useSSL=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai&quot;; String user = &quot;root&quot;; String pwd = &quot;123456&quot;; Connection conn = DriverManager.getConnection(url,user,pwd); return conn; &#125; /** * 关闭资源 * @param st * @param conn */ public static void close(Statement st,Connection conn) throws SQLException &#123; if(null!=st)&#123; st.close(); &#125; if(null!=conn)&#123; conn.close(); &#125; &#125; public static void close(ResultSet rs,Statement st,Connection conn) throws SQLException &#123; if(null!=rs) rs.close(); if(null!=st) st.close(); if(null!=conn) conn.close(); &#125;&#125; 作业涉及到的表 1234567891011121314151617181920212223242526272829303132-- 用户表drop table t_user;create table t_user( id int(7) primary key auto_increment, username varchar(20) unique not null, password varchar(20) not null, birthday date);insert into t_user values(1,&#x27;admin&#x27;,&#x27;123&#x27;,now());insert into t_user values(2,&#x27;tom&#x27;,&#x27;123&#x27;,now());insert into t_user values(3,&#x27;lucy&#x27;,&#x27;123&#x27;,now());insert into t_user values(4,&#x27;jack&#x27;,&#x27;234&#x27;,now());insert into t_user values(5,&#x27;sakura&#x27;,&#x27;567&#x27;,now());-- 视频表 一个用户可以发布多个视频drop table t_video;create table t_video( id int(7) primary key auto_increment,title varchar(20) not null,create_date datetime,price double(7,2),video_url varchar(120),-- 不需要创建外键约束,但是仍然需要通过user_id确定和t_user表的关系-- Video实体类中 - private User user;-- User实体类 - private List&lt;Video&gt; videos;user_id int(7));insert into t_video values(1,&#x27;娱乐圈需要整顿&#x27;,now(),10.0,&#x27;http://aistar/001.mp4&#x27;,1);insert into t_video values(2,&#x27;新概念吃播&#x27;,now(),20.0,&#x27;http://aistar/002.mp4&#x27;,1);insert into t_video values(3,&#x27;花少北的一百个圈套&#x27;,now(),30.0,&#x27;http://aistar/003.mp4&#x27;,2);insert into t_video values(4,&#x27;双镜yyds&#x27;,now(),40.0,&#x27;http://aistar/004.mp4&#x27;,4);insert into t_video values(5,&#x27;千层套路你&#x27;,now(),1000.0,&#x27;http://aistar/005.mp4&#x27;,4); 二进制数据存储,列的数据类型blob - binary large object - 真正的把图片,视频 - 流 -&gt; 存储到列中 - 不可取 专门搭建一个服务器nginx - 服务器上的资源[图片/视频]都会拥有一个url[统一资源定位器 - 唯一的] https://cdn.cnbj1.fds.api.mi-img.com/mi-mall/eb69512d9d6430d865d457ec52eebb51.png?thumb=1&amp;w=400&amp;h=400&amp;f=webp&amp;q=90 实际现在推荐的方式是在表中,比如video_url - 存储这个视频对应的它所在服务器的地址即可 完成t_video表的crud操作Video实体类123456789101112131415161718192021package tech.aistar.entity;import tech.aistar.util.DateUtil;import java.io.Serializable;import java.util.Date;/** * @Author liuWenXiu * @Date 2021/8/25 18:50 * @description Video实体类 */public class Video implements Serializable &#123; private Integer id; private String title; //视频名称 private Date createDate; //创建事件 private Double price; //视频价格 private String videoUrl; //视频地址 private User user; //维护具体的对象&#125; IVideoDao接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package tech.aistar.dao;import tech.aistar.entity.Video;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/25 18:53 * @description */public interface IVideoDao &#123; /** * 查询所有结果 * @return Video集合 */ List&lt;Video&gt; findAll(); /** * 存储Video对象 * @param video * @return */ int save(Video video); /** * 根据id进行删除操作 * @param id 行记录的主键列id的值 * @return 删除行数 */ int delById(Integer id); /** * 根据id进行查询操作 * @param id 行记录的主键id的值 * @return Video对象 */ Video getById(Integer id); /** * 根据id进行更新 * @param video * @return */ int update(Video video);&#125; VideoDaoImpl实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226package tech.aistar.dao.impl;import tech.aistar.dao.IUserDao;import tech.aistar.dao.IVideoDao;import tech.aistar.entity.User;import tech.aistar.entity.Video;import tech.aistar.util.DateUtil;import tech.aistar.util.JdbcUtil;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/25 18:57 * @description */public class VideoDaoImpl implements IVideoDao &#123; private IUserDao userDao = new UserDaoImpl(); @Override public List&lt;Video&gt; findAll() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; List&lt;Video&gt; videos = new ArrayList&lt;&gt;(); try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 获取语句对象 st = conn.createStatement(); // 创建sql语句 String sql = &quot;select * from t_video&quot;; // 发送sql并获取结果 rs = st.executeQuery(sql); while (rs.next())&#123; // 获取结果 int id = rs.getInt(1); String title = rs.getString(2); Date createDate = rs.getTimestamp(3); Double price = rs.getDouble(4); String videoUrl = rs.getString(5); int userId = rs.getInt(6); User user = userDao.getById(userId); Video video = new Video(id,title,createDate,price,videoUrl,user); videos.add(video); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 try &#123; JdbcUtil.close(rs,st,conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return videos; &#125; @Override public int save(Video video) &#123; Connection conn = null; Statement st = null; int count = 0; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 获取语句对象 st = conn.createStatement(); String title = video.getTitle(); String createDate = DateUtil.format(video.getCreateDate(),&quot;yyyy-MM-dd HH:mm:ss&quot;); Double price = video.getPrice(); String videoUrl = video.getVideoUrl(); int userId = video.getUser().getId(); // 创建sql语句 // insert into t_video(title,create_date,price,video_url,user_id) values (&#x27;title&#x27;,&#x27;createDate&#x27;,price,&#x27;videoUrl&#x27;,userId); String sql = &quot;insert into t_video(title,create_date,price,video_url,user_id) values (&#x27;&quot; + title + &quot;&#x27;,&#x27;&quot; + createDate + &quot;&#x27;,&quot; + price + &quot;,&#x27;&quot; + videoUrl + &quot;&#x27;,&quot; + userId + &quot;)&quot;; //System.out.println(sql); // 发送sql count = st.executeUpdate(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 try &#123; JdbcUtil.close(st,conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125; @Override public int delById(Integer id) &#123; Connection conn = null; Statement st = null; int count = 0; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 获取语句对象 st = conn.createStatement(); // 创建sql语句 // delete from t_video where id = id; String sql = &quot;delete from t_video where id = &quot; + id; // 发送sql count = st.executeUpdate(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 try &#123; JdbcUtil.close(st,conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125; @Override public Video getById(Integer id) &#123; Connection conn = null; Statement st = null; ResultSet rs = null; Video video = null; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 获取语句对象 st = conn.createStatement(); // 创建sql语句 // select * from t_video where id = id; String sql = &quot;select * from t_video where id = &quot; + id; // 发送sql rs = st.executeQuery(sql); // 获取结果 if(rs.next())&#123; String title = rs.getString(2); Date createDate = rs.getTimestamp(3); double price = rs.getDouble(4); String videoUrl = rs.getString(5); int userId = rs.getInt(6); User user = userDao.getById(userId); video = new Video(id,title,createDate,price,videoUrl,user); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; JdbcUtil.close(rs,st,conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return video; &#125; @Override public int update(Video video) &#123; Connection conn = null; Statement st = null; int count = 0; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 获取语句对象 st = conn.createStatement(); int id = video.getId(); String title = video.getTitle(); Date createDate = video.getCreateDate(); String dateStr = DateUtil.format(createDate,&quot;yyyy-MM-dd HH:mm:ss&quot;); double price = video.getPrice(); String videoUrl = video.getVideoUrl(); int userId = video.getUser().getId(); // 创建sql语句 // update t_video set title = &#x27;title&#x27;,create_date=&#x27;dateStr&#x27;,price=price,video_url=&#x27;videoUrl&#x27;,user_id=userId where id = id; String sql = &quot;update t_video set title=&#x27;&quot; + title + &quot;&#x27;,create_date=&#x27;&quot; + dateStr + &quot;&#x27;,price=&quot; + price + &quot;,video_url=&#x27;&quot; + videoUrl + &quot;&#x27;,user_id=&quot; + userId + &quot; where id=&quot; + id; //System.out.println(sql); // 发送sql count = st.executeUpdate(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; JdbcUtil.close(st,conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125;&#125; 单元测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package tech.aistar.dao;import org.junit.Test;import tech.aistar.dao.impl.UserDaoImpl;import tech.aistar.dao.impl.VideoDaoImpl;import tech.aistar.entity.User;import tech.aistar.entity.Video;import java.util.Date;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/25 19:16 * @description */public class VideoDaoTest &#123; private IVideoDao videoDao = new VideoDaoImpl(); private IUserDao userDao = new UserDaoImpl(); @Test public void testFindAll()&#123; List&lt;Video&gt; videos = videoDao.findAll(); videos.forEach(System.out::println); &#125; @Test public void testSave()&#123; User user = userDao.getById(3); Video video = new Video(&quot;我是老番茄&quot;,new Date(),2000.d,&quot;http://aistart/005.mp4&quot;,user); int count = videoDao.save(video); System.out.println(&quot;添加了&quot;+count+&quot;条记录&quot;); &#125; @Test public void testDelById()&#123; int count = videoDao.delById(6); System.out.println(&quot;删除了&quot;+count+&quot;条记录&quot;); &#125; @Test public void testGetById()&#123; Video video = videoDao.getById(4); System.out.println(video); &#125; @Test public void testUpdate()&#123; Video video = videoDao.getById(3); video.setCreateDate(new Date()); video.setTitle(&quot;论北子哥的一百个圈套&quot;); video.setPrice(3000.d); int count = videoDao.update(video); if(count!=0)&#123; System.out.println(&quot;修改了id=&quot;+video.getId()+&quot;的记录&quot;); &#125; &#125;&#125; 级联操作IUserDao.java接口中 根据id删除用户,并且把这个用户下的所有的发布的视频全部删除 - 级联删除. 根据id查询用户,如果该用户发布了视频信息,查询这个用户下发布的视频信息 - 级联查询 保存一个用户的同时也保存了这个用户的三个视频信息 - 级联插入 级联删除12345/*** 级联删除操作 - 根据用户的id进行删除,并且如果这个用户存在视频,那么也删除它的视频* @param id*/void delByUserWithVideos(Integer id); 1234567891011121314151617181920212223242526272829303132333435@Overridepublic void delByUserWithVideos(Integer id) &#123; Connection conn = null; PreparedStatement pst = null; try &#123; // 获得连接 conn = JdbcUtil.getConnection(); // 删除时应该先删除多的一方,再删除一的一方 - 先删除t_video,再删除t_user // 创建sql String sql1 = &quot;delete from t_video where user_id = ?&quot;; // 预编译 pst = conn.prepareStatement(sql1); // 填充占位符 pst.setInt(1,id); // 发送sql pst.executeUpdate(); // 如果要执行两个不同的sql语句,要么创建两个PreparedStatement对象,要么每次使用后要关闭PreparedStatement对象 pst.close(); // 创建sql语句 String sql2 = &quot;delete from t_user where id = ?&quot;; // 预编译 pst = conn.prepareStatement(sql2); // 填充占位符 pst.setInt(1,id); // 发送sql pst.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 JdbcUtil.close(pst,conn); &#125;&#125; 注意:如果要执行两个不同的sql语句,要么创建两个PreparedStatement对象,要么每次使用后要关闭PreparedStatement对象. 级联查询123456/*** 级联查询操作 - 查询指定用户id的信息以及视频信息* @param id* @return*/User findUserWithVideos(Integer id); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Overridepublic User findUserWithVideos(Integer id) &#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; ResultSet rs2 = null; User user = null; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 创建sql语句 - 获取User对象 String sql1 = &quot;select * from t_user where id = ?&quot;; // 预编译 pst = conn.prepareStatement(sql1); // 填充占位符 pst.setInt(1,id); // 发送sql获取结果 rs = pst.executeQuery(); if(rs.next())&#123; // 处理结果 String username = rs.getString(2); String password = rs.getString(3); Date birthday = rs.getDate(4); user = new User(id,username,password,birthday); &#125; pst.close(); // 创建sql语句 - 获取Video对象 String sql2 = &quot;select * from t_Video where user_id = ?&quot;; // 预编译 pst = conn.prepareStatement(sql2); // 填充占位符 pst.setInt(1,id); // 发送sql获取结果 List&lt;Video&gt; videos = new ArrayList&lt;&gt;(); rs = pst.executeQuery(); while (rs.next())&#123; Integer vid = rs.getInt(1); String title = rs.getString(2); Date createDate = rs.getTimestamp(3); Double price = rs.getDouble(4); String videoUrl = rs.getString(5); Video video = new Video(vid,title,createDate,price,videoUrl); videos.add(video); &#125; // 绑定 // 如果为空则表示该用户没有发表数据,则不需要绑定 if(videos.size()!=0)&#123; user.setVideoList(videos); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil.close(rs,pst,conn); &#125; return user;&#125; 级联插入插入一个用户的同时插入这个用户的视频信息 - 业务线是不存在的. 如果视频信息比较多 - 采用批处理技术 注意事务是同时成功和同时失败的 插入user的时候要想办法拿到刚刚插入的主键值[auto_increment] 12345/*** 级联插入 - 插入指定用户信息,同时插入用户发布的视频信息* @param user*/void saveUserWithVideos(User user); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Overridepublic void saveUserWithVideos(User user) &#123; Connection conn = null; PreparedStatement pst = null; ResultSet rsPk = null; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 要保证同时成功同时失败&#x27; // 所以要设置手动提交 conn.setAutoCommit(false); // 创建sql语句 String sql = &quot;insert into t_user(username,password,birthday) value (?,?,?)&quot;; // 预编译 // Statement.RETURN_GENERATED_KEYS可以拿到自增长主键的值 pst = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS); // 填充占位符 pst.setString(1,user.getUsername()); pst.setString(2,user.getPassword()); pst.setDate(3,new java.sql.Date(user.getBirthday().getTime())); // 发送sql pst.executeUpdate(); // 现在不会自动commit // 插入一个新的User对象以后,我们需要拿到刚刚自增长的主键的值 // pst.getGeneratedKeys()可以获取一下刚刚自增长的主键值 rsPk = pst.getGeneratedKeys(); Integer insertUserId = null; if(rsPk.next())&#123; insertUserId = rsPk.getInt(1); &#125; // 关闭PreparedStatement,因为要使用新的sql啦 pst.close(); // 判断该用户User是否拥有视频信息 List&lt;Video&gt; videos = user.getVideoList(); if(null!=videos &amp;&amp; videos.size()&gt;0)&#123; // 表示有视频信息 需要插入视频信息 // 创建sql语句 String sql2 = &quot;insert into t_Video(title,create_date,price,video_url,user_id) values(?,?,?,?,?)&quot;; // 预编译 pst = conn.prepareStatement(sql2); for (Video video : videos) &#123; // 填充占位符 pst.setString(1,video.getTitle()); pst.setTimestamp(2,new Timestamp(video.getCreateDate().getTime())); pst.setDouble(3,video.getPrice()); pst.setString(4,video.getVideoUrl()); pst.setInt(5,insertUserId); // 发送sql pst.executeUpdate(); &#125; &#125; // 最后手动提交 conn.commit(); &#125; catch (SQLException e) &#123; // 如果发生异常则进行回滚 if(null!=conn)&#123; try &#123; conn.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125; e.printStackTrace(); &#125;finally &#123; // 关闭资源 JdbcUtil.close(rsPk,pst,conn); &#125;&#125; 级联插入时为了确保两张表的插入同时成功,需要设置setAutoCommit为false,在catch块中rollback. pst = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);在获取语句对象时,添加一个实参,使我们能够获取到插入的id的值.再通过ResultSet rsPk = pst.getGeneratedKeys();获取到该值. SQL注入负责发送sql语句的对象 - Statement语句对象 - 引发sql注入问题 - 因为参数硬拼接到了sql语句中 sql注入的场景: username是外部传过来的参数,该参数会直接被拼接到sql语句中. rs = st.executeQuery(sql) 12345public User getByUsername(String username)&#123; //... String sql = &quot;select * from t_user where username = &#x27;&quot; + username + &quot;&#x27;&quot;; //...&#125; PreparedStatement[I] 预编译语句对象 继承于Statement对象 有效方式sql注入 如何创建预编译语句对象 123456PreparedStatement prepareStatement(String sql); //利用一条sql构建预编译语句对象// 此处的sql可能包含一些参数的占位符// 创建sql语句String sql = &quot;insert into t_video(title,create_date,price,video_url,user_id) values(?,?,?,?,?)&quot;;// 创建语句对象 - 把带有参数占位符的sql语句提前发送到my-server端进行编译pst = conn.prepareStatement(sql); 如何发送参数 - 列的类型 setInt,setString,setDate,setDouble… 12345678910111213//把参数发送到mysql--server端,然后再由mysql-server端把参数填充到已经预编译好的sql语句中// 序号也是从1开始的pst.setString(1,video.getTitle());// setDate比较特殊,需要将java.util.Date转换成java.sql.Date// 利用毫秒数来创建一个java.sql.Date类型的日期对象//pst.setDate(2,new java.sql.Date(vido.getCreateDate().getTime()));// java.sql.Timestamp extends java.util.Date// 同样提供了构造Timestamp(long time)pst.setTimestamp(2,new Timestamp(video.getCreateDate().getTime()));pst.setDouble(3,video.getPrice());pst.setString(4,video.getVideoUrl());//为什么需要在Video中维护了单个user对象的原因.pst.setInt(5,video.getUser().getId()); 方法 int executeUpdate(); ResultSet executeQuery(); PreparedStatement和Statement区别 PreparedStatement继承于Statement,都是借口 Statement适用于静态运行SQL语句,参数直接硬拼接到sql语句.Statement借口不接受参数. PreparedStatement计划多次使用同一条SQL语句,适合执行同构的sql,PreparedStatement接口运行时接收输入的参数. PreparedStatement有效防止sql注入 PreparedStatement会预编译SQL语句,Statement每次都会解析/编译SQL PreparedStatement效率比Statement高. 批处理操作比如批量插入 - 即使以后学习了持久层的框架[hibernate,mybatis,mybatis-pllus,springdatatjpa],但是遇到批量插入,首选的技术jdbc,效率仍然是最高的. 使用时需要在url上增加一个配置 1&amp;rewriteBatchedStatement=true PreparedStatement关于批处理的api void addBatch();//向这个PreparedStatement对象的批命令添加一组参数 void clearParameters(); //立刻清除当前参数值 void clearVatch(); // 清空此Statement对象当前SQL命令列表 int[] executeBatch(); // 执行命令列表 批量插入数据demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic void saveListBatch(List&lt;Video&gt; videoList) &#123; Connection conn = null; PreparedStatement pst = null; int count = 0; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 创建sql语句 String sql = &quot;insert into t_video(title,create_date,price,video_url,user_id) values(?,?,?,?,?)&quot;; // 预编译 pst = conn.prepareStatement(sql); for (Video video : videoList) &#123; pst.setString(1,video.getTitle()); pst.setTimestamp(2,new Timestamp(video.getCreateDate().getTime())); pst.setDouble(3,video.getPrice()); pst.setString(4,video.getVideoUrl()); pst.setInt(5,video.getUser().getId()); pst.addBatch(); // 添加到Bash中,没有发送sql count++; // 当count达到一定数量时进行发送 - 每1000条发一次 if(count == 100)&#123; // 执行批处理的命令列表 pst.executeBatch(); // 清空命令列表 pst.clearBatch(); pst.clearParameters(); //清除当前参数值 - 前面设置的那些[也可以不写,但是为了保险起见写] count = 0; &#125; &#125; // 考虑如果插入的不是1000的倍数 会有多余的数据 if(count!=0)&#123; pst.executeBatch(); pst.clearBatch(); pst.clearParameters(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 JdbcUtil.close(pst,conn); &#125;&#125; 第二层封装 - 模板设计模式函数式接口PreparedStatementCallback1234@FunctionalInterfacepublic interface PreparedStatementCallback &#123; PreparedStatement execute(Connection conn) throws SQLException;&#125; JdbcTemplate - 自定义jdbc模板工具类123456789101112131415161718192021222324public class JdbcTemplate &#123; /** * 负责dml操作 * @param pcb */ public static void executeUpdate(PreparedStatementCallback pcb)&#123; Connection conn = null; PreparedStatement ps = null; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 获取语句对象 通过pcb来获取 ps = pcb.execute(conn); // 发送sql ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 JdbcUtil.close(ps,conn); &#125; &#125;&#125; 模板设计模式使用demolambda表达式 12345678910111213@Overridepublic void delById(Integer id) &#123; JdbcTemplate.executeUpdate(conn -&gt; &#123; // 创建sql语句 String sql = &quot;delete from t_video where id = ?&quot;; // 预编译 PreparedStatement pst = conn.prepareStatement(sql); // 填充占位符 pst.setInt(1,id); // 发送sql return pst; &#125;);&#125; 匿名内部类 12345678910111213141516@Overridepublic void delById(Integer id) &#123; JdbcTemplate.executeUpdate(new PreparedStatementCallback() &#123; @Override public PreparedStatement execute(Connection conn) throws SQLException &#123; // 创建sql语句 String sql = &quot;delete from t_video where id = ?&quot;; // 预编译 PreparedStatement pst = conn.prepareStatement(sql); // 填充占位符 pst.setInt(1,id); // 发送sql return pst; &#125; &#125;);&#125; 作业IUserDao.java 统计每个用户发布的视频的数量题目要求统计每个用户发布的视频数量,并且要返回出来,所以想到创建一个UserDTO类,用于统计用户发布的视频数量. UserDTO 123456789public class UserDTO &#123; private Integer userId; private String userName; private Integer videosCount; // 视频数量 // 构造... // getter/setter // toString&#125; UserDaoImpl 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic List&lt;UserDTO&gt; countUserVideos() &#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; List&lt;UserDTO&gt; userDTOS = new ArrayList&lt;&gt;(); try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 创建sql语句 // 查询用户以及它视频的个数 String sql = &quot;select u.id,u.username,count(tv.id) from t_user u left join t_video tv on u.id = tv.user_id group by u.id, u.username&quot;; // 预编译 pst = conn.prepareStatement(sql); // 发送sql,获取结果 rs = pst.executeQuery(); while (rs.next())&#123; Integer userId = rs.getInt(1); String userName = rs.getString(2); Integer videosCount = rs.getInt(3); UserDTO userDTO = new UserDTO(userId,userName,videosCount); userDTOS.add(userDTO); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JdbcUtil.close(rs,pst,conn); &#125; return userDTOS;&#125;&#125; 多条件组合分页查询1. 如果仅仅给定了一个用户名 - 根据用户名进行一个分页查询 2. 如果仅仅给定了一个title,那么就是根据title进行模糊分页查询 3. 如果username和title同时给了.同时根据这俩个条件[同时成立]进行分页查询. 4. 如果俩个条件都不给.那么就是查整个视频表,分页查询. 实现思路使用limit语句 - 分页公式: limit(pageNow-1)*pageSize,pageSize 分页之后得到的数据 每页显示的数据个数 - 手动传入的 根据条件查询得到的结果个数 - rows - 总的条数 总的条数/每页显示条数 = 总的页数 首先IVideoDao中定义方法List findPage(String username,String title,Integer pageNow,Integer pageSize)来获得具体页面数据.获取指定的用户名,视频标题,当前页面以及页面大小. 数据持久层IVideoDao 12345678910111213141516171819202122/*** 分页查询* 如果只给定了用户名,则根据用户名进行分页查询* 如果只给定了标题,则根据标题进行模糊分页查询* 如果两个都给了,则同时成立查询* 如果两个都没给,则查询所有视频并分页* @param username 精确匹配* @param title 模糊匹配* @param pageNow 当前页* @param pageSize 页面大小* @return*/List&lt;Video&gt; findPage(String username,String title,Integer pageNow,Integer pageSize);/*** 多条件组合查询得到的视频总个数* @param username* @param title* @return*/int countVideos(String username,String title); VideoDaoImpl 1.首先处理参数,如果用户没有指定页面和页面大小,则需要为其设置默认值. 2.在创建sql语句时注意添加where 1=1 便于后面添加条件查询 3.可以将条件放入到集合中,用来判断用户是否选择了条件 4.在使用模糊查询时,可以使用concat(‘%’,?,’%’); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121@Overridepublic List&lt;Video&gt; findPage(String username, String title, Integer pageNow, Integer pageSize) &#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; List&lt;Video&gt; videoList = new ArrayList&lt;&gt;(); try&#123; // 获取连接 conn = JdbcUtil.getConnection(); // 规范参数 如果没有传入具体的页面大小和当前页面 // 默认为查询第1页的数据,并且每页大小为2 pageNow = (pageNow==null?1:pageNow); pageSize = (pageSize==null?2:pageSize); // 创建sql语句 String sql = &quot;select tv.* from t_user u join t_video tv on u.id = tv.user_id where 1=1&quot;; // 需要根据参数补充sql语句 List&lt;String&gt; params = new ArrayList&lt;&gt;(); if(null!=username &amp;&amp; username.trim().length()&gt;0)&#123; // 说明用户确实输入了username sql += &quot; and username=?&quot;; params.add(username); &#125; if(null!=title &amp;&amp; title.trim().length()&gt;0)&#123; sql += &quot; and title like concat(&#x27;%&#x27;,?,&#x27;%&#x27;)&quot;; params.add(title); &#125; // 填充分页参数 sql += &quot; limit ?,?&quot;; // 预编译 pst = conn.prepareStatement(sql); // 填充占位符 int i = 0; if(null!=params &amp;&amp; params.size()&gt;0)&#123; // 说明用户确实输入了 for (i=0; i &lt;params.size() ; i++) &#123; pst.setObject(i+1,params.get(i)); &#125; &#125; pst.setObject(++i,(pageNow-1)*pageSize); pst.setObject(++i,pageSize); // 发送sql System.out.println(sql); rs = pst.executeQuery(); // 获取结果 while (rs.next())&#123; Video v = new Video(); v.setId(rs.getInt(1)); v.setTitle(rs.getString(2)); v.setCreateDate(rs.getTimestamp(3)); v.setPrice(rs.getDouble(4)); v.setVideoUrl(rs.getString(5)); videoList.add(v); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 JdbcUtil.close(rs,pst,conn); &#125; return videoList;&#125; @Override public int countVideos(String username, String title) &#123; Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; int count = 0; try &#123; // 获取连接 conn = JdbcUtil.getConnection(); // 创建sql语句 String sql = &quot;select tv.* from t_user u join t_video tv on u.id = tv.user_id where 1=1&quot;; // 需要根据参数补充sql语句 List&lt;String&gt; params = new ArrayList&lt;&gt;(); if (null != username &amp;&amp; username.trim().length() &gt; 0) &#123; // 说明用户确实输入了username sql += &quot; and username=?&quot;; params.add(username); &#125; if (null != title &amp;&amp; title.trim().length() &gt; 0) &#123; sql += &quot; and title like concat(&#x27;%&#x27;,?,&#x27;%&#x27;)&quot;; params.add(title); &#125; // 预编译 pst = conn.prepareStatement(sql); // 填充占位符 if (null != params &amp;&amp; params.size() &gt; 0) &#123; // 说明用户确实输入了 for (int i = 0; i &lt; params.size(); i++) &#123; pst.setObject(i + 1, params.get(i)); &#125; &#125; // 发送sql rs = pst.executeQuery(); // 获取结果 while (rs.next())&#123; count++; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count; &#125;&#125; 业务逻辑层创建PageDTO存储页面展示需要的数据,包括页面的大小,当前页面,总页数,具体数据 pageDTO 12345678public class PageDTO&lt;T&gt; &#123; private Integer pageNow; //当前页 private Integer pageSize; //每页显示条数 private Integer pageCount; //总页数 private List&lt;T&gt; dataList; //页面上分页显示的数据 //...构造等&#125; IVideoService 1234//分页的逻辑//分页的数据,[总的条数]+每页显示的条数=&gt;计算=&gt;总的页数,分页的条件,当前页 -&gt; 分页对象//分页对象完全返回给页面PageDTO&lt;Video&gt; findPageList(String username, String title, Integer pageNow, Integer pageSize); VideoServiceImpl 1234567891011121314151617181920212223242526272829public class VideoServiceImpl implements IVideoService &#123; private IVideoDao videoDao = new VideoDaoImpl(); @Override public PageDTO&lt;Video&gt; findPageList(String username, String title, Integer pageNow, Integer pageSize) &#123; PageDTO&lt;Video&gt; pageDTO = new PageDTO&lt;&gt;(); // 为pageNow和pageSize设置默认值 pageNow = (pageNow==null?1:pageNow); pageSize = (pageSize==null?2:pageSize); // 计算视频总个数 int videosCount = videoDao.countVideos(username, title); int pageCount = videosCount/pageSize; if(videosCount%pageSize!=0)&#123; pageCount++; &#125; // 获取具体页面数据 List&lt;Video&gt; data = videoDao.findPage(username, title, pageNow, pageSize); // 封装结果 pageDTO.setPageNow(pageNow); pageDTO.setPageSize(pageSize); pageDTO.setPageCount(pageCount); pageDTO.setDataList(data); return pageDTO; &#125;&#125;","categories":[],"tags":[{"name":"jdbc","slug":"jdbc","permalink":"http://beautifulboyy/tags/jdbc/"}]},{"title":"索引高阶","slug":"mysql05","date":"2021-08-23T13:34:03.000Z","updated":"2021-08-24T15:29:06.951Z","comments":true,"path":"2021/08/23/mysql05/","link":"","permalink":"http://beautifulboyy/2021/08/23/mysql05/","excerpt":"","text":"索引数据存储B+树InnoDB 存储引擎中的 B+ 树索引。要介绍 B+ 树索引，就不得不提二叉查找树，平衡二叉树和 B 树这三种数据结构。B+ 树就是从他们仨演化来的。 索引文件和数据文件 - innodb中 - 合二为一的 - 只有1个文件 索引文件和数据文件 - myisam中 - 分开独立的 - 俩个文件 二叉树查找 从图中可以看到，我们为 user 表（用户信息表）建立了一个二叉查找树的索引。 图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。键对应 user 表中的 id，数据对应 user 表中的行数据。 二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。 二叉树查找流程如果我们需要查找 id=12 的用户信息，利用我们创建的二叉查找树索引，查找流程如下： 将根节点作为当前节点，把 12 与当前节点的键值 10 比较，12 大于 10，接下来我们把当前节点&gt;的右子节点作为当前节点。 继续把 12 和当前节点的键值 13 比较，发现 12 小于 13，把当前节点的左子节点作为当前节点。 把 12 和当前节点的键值 12 对比，12 等于 12，满足条件，我们从当前节点中取出 data，即 id=12，name=xm。 利用二叉查找树我们只需要 3 次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要 6 次才能找到。 平衡二叉树上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造： 这个时候可以看到我们的二叉查找树变成了一个链表。如果我们需要查找 id=17 的用户信息，我们需要查找 7 次，也就相当于全表扫描了。 导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。 为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1。 下面是平衡二叉树和非平衡二叉树的对比： 左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2 在图二右边的AVL树上： 节点50的左子树高度为3，右子树高度为2，BF= 3-2 = 1； 节点45的左子树高度为2，右子树高度为1，BF= 2-1 = 1； 节点46的左子树高度为0，右子树高度为0，BF= 0-0 = 0； 节点65的左子树高度为0，右子树高度为1，BF= 0-1 = -1； 对于平衡二叉树，BF的取值范围为[-1,1]。如果发现某个节点的BF值不在此范围，则需要对树进行调整。 B树因为内存的易失性。一般情况下，我们都会选择将 user 表中的数据和索引存储在磁盘这种外围设备中。 但是和内存相比,从磁盘中读取数据的速度会慢上百倍千倍甚至万倍,所以我们应当尽量减少从磁盘中读取数据的次数.另外,从磁盘读取数据时,都是按照磁盘块来读取的,并不是一条一条的读取. 如果我们能把尽量多的数据放进磁盘块中,那么一次磁盘读取操作就会读取更多数据,查找数据的时候也会大幅度降低.如果我们用树这种数据结构作为索引的数据结构,那么我们每查找一次数据就需要从磁盘中读取一个节点,也就是我们说的一个磁盘块.我们都知道平衡二叉树是每个节点都只存储一个键值和数据的,说明每个磁盘块仅仅存储一个键值和数据,那如果我们要存储海量的数据,二叉树的节点将会非常多,高度也会极其高,查找数据时也会进行很多次磁盘IO交互,查找的效率将会极低. 为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的 B 树 B 树（Balance Tree）即为平衡树的意思，下图即是一棵 B 树 图中的 p 节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。 图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构。 从上图可以看出，B 树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的 B 树为 3 阶 B 树，高度也会很低。 基于这个特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。 假如我们要查找 id=28 的用户信息，那么我们在上图 B 树中查找的流程如下： 先找到根节点也就是页 1，判断 28 在键值 17 和 35 之间，那么我们根据页 1 中的指针 p2 找到页 3。 将 28 和页 3 中的键值相比较，28 在 26 和 30 之间，我们根据页 3 中的指针 p2 找到页 8。 将 28 和页 8 中的键值相比较，发现有匹配的键值 28，键值 28 对应的用户信息为（28，bv）。 B树的特点 根节点[第一页]永驻内存 每个节点可以保留多个key-value,导致子节点会增多,B树又矮又胖. 没有子节点的节点是叶节点,有子节点的节点是非叶节点. B数的m阶 - m值就是看它最大的子节点的个数. 页page的概念 - 每查找一次数据就需要从磁盘中读取一个节点,也就是我们说的一个磁盘块. 读取的单位是页 - 1页的磁盘块的数据大小是16kb,每个节点可以有更多的key-value 页与页之间是一个链表的结构 B+树B+树是对B树的进一步优化,B+树的结构图 B+树和B树的不同 B+树中非叶节点仅仅保存了key值,没有保存数据,每个非叶节点可以保存更多的key. B+树中索引的所有数据都放在了叶节点中,而且是按照顺序排列的. 页与页之间是双向链表结构,叶节点中的每个数据节点单向链表. B+树非叶子节点上是不存储数据的,仅存储简直,而B树节点中不仅存储键值,也会存储数据. 之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。 如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。 一般根节点是常驻内存的，所以一般我们查找 10 亿数据，只需要 2 次磁盘 IO。 因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。 那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。有心的读者可能还发现上图 B+ 树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。其实上面的 B 树我们也可以对各个节点加上链表。这些不是它们之前的区别，是因为在 MySQL 的 InnoDB 存储引擎中，索引就是这样存储的。 也就是说上图中的 B+ 树索引就是 InnoDB 中 B+ 树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。通过上图可以看到，在 InnoDB 中，我们通过数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。 MyISAM 中的 B+ 树索引实现与 InnoDB 中的略有不同。在 MyISAM 中，B+ 树索引的叶子节点并不存储数据，而是存储数据的文件地址。 聚簇索引和非聚簇索引在上节介绍 B+ 树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。 那什么是聚集索引呢？在 MySQL 中，B+ 树索引按照存储方式的不同分为聚集索引和非聚集索引。 这里我们着重介绍 InnoDB 中的聚集索引和非聚集索引： 聚集索引聚簇索引:以InnoDB作为存储引擎的表,表中的数据都会有一个主键,即使你不创建主键,系统也会帮你创建一个隐式的主键. 因为InnoDB是把数据存放在B+树中的,而B+树的键值就是主键,在B+树的叶子节点中,存储了表中所有的数据. 这种以主键作为B+树索引的键值而构成的B+树索引,我们称之为聚集索引. 非聚集索引(非聚簇索引):以主键以外的列值作为键值构建的B+树索引,我们称之为非聚集索引. 聚簇索引和非聚簇索引的区别:非聚簇索引的叶子节点不存储表中的数据,而是存储该列对应的主键,想要查找数据我们还需要根据主键再去聚簇索引中进行查找,这个根据聚簇索引查找数据的过程,我们称为回表. 聚簇索引查找流程 select * from user where id&gt;=18 and id &lt;40 其中 id 为主键，具体的查找过程如下： ①一般根节点都是常驻内存的，也就是说页 1 已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。 从内存中读取到页 1，要查找这个 id&gt;=18 and id &lt;40 或者范围值，我们首先需要找到 id=18 的键值。 从页 1 中我们可以找到键值 18，此时我们需要根据指针 p2，定位到页 3。 ②要从页 3 中查找数据，我们就需要拿着 p2 指针去磁盘中进行读取页 3。 从磁盘中读取页 3 后将页 3 放入内存中，然后进行查找，我们可以找到键值 18，然后再拿到页 3 中的指针 p1，定位到页 8。 ③同样的页 8 页不在内存中，我们需要再去磁盘中将页 8 读取到内存中。 将页 8 读取到内存中后。因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值 18。 此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值 18 对应的数据。 因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页 8 中的键值依次进行遍历查找并匹配满足条件的数据。 我们可以一直找到键值为 22 的数据，然后页 8 中就没有数据了，此时我们需要拿着页 8 中的 p 指针去读取页 9 中的数据。 ④因为页 9 不在内存中，就又会加载页 9 到内存中，并通过和页 8 中一样的方式进行数据的查找，直到将页 12 加载到内存中，发现 41 大于 40，此时不满足条件。那么查找到此终止。 最终我们找到满足条件的所有数据，总共 12 条记录： (18,kl), (19,kl), (22,hj), (24,io), (25,vg) , (29,jk), (31,jk) , (33,rt) , (34,ty) , (35,yu) , (37,rt) , (39,rt) 。 下面看下具体的查找流程图: 非聚簇索引查找数据 这个过程有空再看一遍 在查询过程中,可以通过非聚簇索引列的值,确定到该索引列值对应的主键值id 根据图一找到的主键id,然后进行一次回表操作.再继续按照聚簇索引的搜索方式来确定到具体的行记录 非聚簇索引列查找是否一定会回表未必 - 因为非叶节点中存储的就是索引列值. 查询**: select name from xx where name=’Blob’;** 不需要回表了.这条语句查询的结果name已经在非聚簇索引的非叶节点中保存了. 回表 根据一个非聚簇索引列查找 - 优先先到非聚簇索引的B+树中找到该列对应的主键列值[聚簇索引列值] 再拿着这个聚簇索引列的值再去到聚簇索引列的B+树中再查找一次 MyISAM索引***索引文件和数据文件是分开的.***B+树结构. 在 MyISAM 中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。","categories":[],"tags":[{"name":"索引","slug":"索引","permalink":"http://beautifulboyy/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"数据库索引","slug":"mysql04","date":"2021-08-23T01:46:02.000Z","updated":"2021-08-23T13:33:43.983Z","comments":true,"path":"2021/08/23/mysql04/","link":"","permalink":"http://beautifulboyy/2021/08/23/mysql04/","excerpt":"","text":"索引数据字典 用户表 - 自定义的表 - 存储用户的数据 系统表 - 数据字典 - 存储的是用户表的元信息 用户表仅仅可能只是系统表中的一个字段存在着而已. 类似于java.lang.Class,所有的类都是属于Class的对象,类是用来描述对象的,我们可以通过Class对象的api来获取类的信息.Class是用来描述类的类. demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849use information_schema;show tables;发现里面有一个系统表 - TABLE_CONSTRAINTS - 数据字典 - 保存的是所有的表的约束信息.desc table_constraints;+--------------------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------------------+--------------+------+-----+---------+-------+| CONSTRAINT_CATALOG | varchar(512) | NO | | | || CONSTRAINT_SCHEMA | varchar(64) | NO | | | || CONSTRAINT_NAME | varchar(64) | NO | | | || TABLE_SCHEMA | varchar(64) | NO | | | || TABLE_NAME | varchar(64) | NO | | | || CONSTRAINT_TYPE | varchar(64) | NO | | | |+--------------------+--------------+------+-----+---------+-------+6 rows in set (0.01 sec)table_name,constraint_name,constraint_type表名 约束名称 约束类型--1. 查什么--2. 到哪里查-- 查看tbl_comment表中以上三个字段mysql&gt; select table_name,constraint_name,constraint_type from table_constraints where table_name=&#x27;tbl_comment&#x27;;+-------------+-------------------------+-----------------+| table_name | constraint_name | constraint_type |+-------------+-------------------------+-----------------+| tbl_comment | PRIMARY | PRIMARY KEY || tbl_comment | tbl_comment_id_fk | FOREIGN KEY || tbl_comment | tbl_comment_user_id_fk | FOREIGN KEY || tbl_comment | tbl_comment_video_id_fk | FOREIGN KEY |+-------------+-------------------------+-----------------+-- 查看tbl_comment表中的列的名称[COLUMN_NAME],列的数据类型[COLUMN_TYPE]mysql&gt; select column_name,column_type from columns where table_name=&#x27;tbl_comment&#x27;;+-------------+-------------+| column_name | column_type |+-------------+-------------+| id | int(7) || user_id | int(7) || video_id | int(7) || content | varchar(50) || comment_id | int(7) |+-------------+-------------+5 rows in set (0.00 sec) 索引基础简介:mysql中不同的存储引擎的索引的实现方式是不同的. 索引最大的好处就是会提高查询效率,但是索引也占内存空间,索引也需要进行维护[更新-消耗时间],所以并不是索引创建的越多越好. **5.7及其以后默认的存储引擎就是innodb,**之前默认采用的是myisam myisam和innodb有何区别 innodb支持事务,myisam不支持事务 [DTL命令是不支持的] myisam支持全文索引.但是innodb不支持全文索引. innode可以支持到行锁.myisam支持到表锁. 行锁的性能高于表锁. innodb支持b+树索引 - 笔试索引的底层原理 = B+树相关 innodb支持外键约束的. 索引类型1.普通索引(index):仅仅是加快了查询速度 12345678-- 给非唯一,非主键的列添加的索引.比如表中的某列字段经常被用来搜索,比如emailcreate index 索引名 on 表名(列名);mysql&gt; create index student_age on student(age);Query OK, 0 rows affected (0.96 sec)-- 删除alter table 表名 drop index 索引名;mysql&gt; alter table student drop index student_age;Query OK, 0 rows affected (0.22 sec) 2.唯一索引(unique):行上的值不能重复 如果创建列的时候,给该列添加了唯一约束unique.那么这个列默认就是唯一索引. 3.主键索引(primary key):不能重复 1234567-- 如果某列是主键列,那么该列默认就是索引列-- 删除主键索引.主键索引是自动创建的,索引名是系统自动分配的,特殊的名称primary keyalter table 表名 drop primary key;-- 查看索引show index from 表名;show index from 表名 \\g; -- 看的更清晰 4.全文索引(fulltext):仅可用于MyISAM表,针对较大的数据,生成全文索引很耗时间空间. 5.组合索引[覆盖索引]:为了更多的提高mysql效率可建立组合索引,遵循”最左前缀”原则 1create index pro_city_index on address(province,city); 索引语法创建索引1234CREATE TABLE table_name( [col_name data type] [unique|fulltext][index|key] [index_name](col_name[length]) [asc|desc]) unique|fulltext为可选参数，分别表示唯一索引、全文索引 index和key为同义词，两者作用相同，用来指定创建索引 col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择 index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值 length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度 asc或desc指定升序或降序的索引值存储 索引使用方式1.查看某张表上的所有索引 1show index from tableName[\\G,如果在cmd窗口,可以换行] 2.建立索引 1create index 索引名 on 表名(列值) 3.删除索引 1alter table 表名 drop index 索引名. 4.删除主键索引 1alter table 表名 drop primary key; 实例demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273drop table index_test;create table index_test( id int(7) primary key, a int(7), b int(7), c varchar(20), d varchar(20));insert into index_test values(1,100,10,&#x27;aaa&#x27;,&#x27;A&#x27;);insert into index_test values(2,300,30,&#x27;aba&#x27;,&#x27;BB&#x27;);insert into index_test values(3,200,20,&#x27;caa&#x27;,&#x27;CC&#x27;);insert into index_test values(4,100,10,&#x27;daa&#x27;,&#x27;DD&#x27;);insert into index_test values(5,500,50,&#x27;aad&#x27;,&#x27;FF&#x27;);-- 默认主键列就是属于索引列 - 主键索引mysql&gt; show index from index_test \\G;*************************** 1. row *************************** Table: index_test Non_unique: 0 Key_name: PRIMARY Seq_in_index: 1 Column_name: id Collation: A Cardinality: 5 Sub_part: NULL Packed: NULL Null: Index_type: BTREE Comment: Index_comment: 1 row in set (0.00 sec)-- 给a列单独创建一个索引 - 普通索引 - 非聚簇索引create index index_test_a on index_test(a);-- 删除普通索引alter table index_test drop index index_test_a;-- 创建一个组合索引 - 非聚簇索引-- 非聚簇索引 - 非主键列索引-- 聚簇索引 - 主键列索引-- a,b当成一个整体来处理 - 实际上仍然是只有一个索引create index index_test_a_b on index_test(a,b);-- 给定一个索引的长度key_len,列的数据类型应该是字符串类型create index index_test on index_test(c(1));比如c列是学生的名称王三王静静王老二王八犊子王静二王静三-- 给某列创建索引的目的就是为了提高根据该列进行查询的效率-- 索引长度是1,区分度不够.假设的是姓王的比较多.-- 并没有提高多少查询效率-- 目录页 -&gt; 王 -&gt; 2页到10页select * from student where c=&#x27;王静%&#x27;;-- 长度为2-- 目录页-- 王三 - 2页-- 王静 - 4页~5页-- 王老,王八....-- create index index_test on index_test(c(2));-- 前俩个select * from student where c=&#x27;王静%&#x27;;-- 如果很多位重复,如何处理.....-- 自己了解... 查询是否使用到了索引1explain select 语句; 索引失效的情况面试题 - 数据库如何进行优化 - 谈到如何解决索引失效 索引type从优到差：System–&gt;**const–&gt;eq_ref–&gt;ref–&gt;ref_or_null–&gt;index_merge–&gt;unique_subquery–&gt;index_subquery–&gt;**range–&gt;index–&gt;all(全表扫描的意思) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162drop table index_test;create table index_test( id int(7) primary key, a int(7), b int(7), c varchar(20), d varchar(20));insert into index_test values(1,100,10,&#x27;aaa&#x27;,&#x27;A&#x27;);insert into index_test values(2,300,30,&#x27;aba&#x27;,&#x27;BB&#x27;);insert into index_test values(3,200,20,&#x27;caa&#x27;,&#x27;CC&#x27;);insert into index_test values(4,100,10,&#x27;daa&#x27;,&#x27;DD&#x27;);insert into index_test values(5,500,50,&#x27;aad&#x27;,&#x27;FF&#x27;);-- 复合索引create index index_test_abc on index_test(a,b,c);-- 测试explain - 测试查询是否使用到了索引.-- 测试主键索引mysql&gt; explain select * from index_test where id = 4;+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| 1 | SIMPLE | index_test | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL |+----+-------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+主要就是观察type=&#x27;const&#x27;;所谓创建索引 - 索引高级篇.索引文件采取一个数据结构[b+树]用来专门存放索引.为何根据索引查找比较快 - 先查索引[先查目录] - 进行定位到行的操作 - myisam中.myisam中索引文件和数据文件.独立存储的,也是分开的存储.1. 数据文件[磁盘上的]也就是所谓的表文件.加载到mysql内存中[select]. 表里面的每一行在内存中也有一个内存地址.2. 索引文件存储的是索引列的值以及该索引列对应的行记录的内存地址. 索引列 内存地址 1 0x7a 2 0x7b 3 0x7c 4 0x7d 5 0x7e myisam索引 - 键值对索引[键 - 索引列值,值 - 行记录的内存地址] 键值对存储在B+树中. select * from index_test where id = 4; 1. 根据id=4先到索引文件中去查找了[消耗时间的] 2. 找到id=4对应的行记录地址[唯一的映射关系] 3. 直接根据行记录地址定位到具体的一行,不需要在数据文件中进行一个全表扫描了.-- 测试非索引列的查询 dmysql&gt; explain select * from index_test where d = &#x27;DD&#x27;;+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | index_test | NULL | ALL | NULL | NULL | NULL | NULL | 5 | 20.00 | Using where |+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+1 row in set, 1 warning (0.00 sec)Type=&#x27;all&#x27; , 全表扫描 , 没有用到索引或者索引失效 , 从表里面的第一行一直扫描到最后一行 - 查询性能肯定是低下的. 遵循最左原则针对的是复合索引 - 查询语句where最左边的列一定要和创建复合索引的第一个列保持一致.并且必须要连续 12345678910111213141516171819202122232425262728293031323334-- 创建复合索引的第一个列acreate index index_test_abc on index_test(a,b,c);-- a,b,c都是生效的-100 | 10 | daaexplain select * from index_test where a=100 and b=10 and c=&#x27;daa&#x27;;-- key_len 是73,三个索引都走了.-- 比如b失效的场景,c也是失效explain select * from index_test where b=10;//不走索引explain select * from index_test where c=&#x27;daa&#x27;;//不走索引-- 不生效 - mysql5.7以后对where语句进行了优化.-- oracle中where语句如果跟了多个条件,执行顺序 - 从右到左-- mysql中where语句条件默认是从左到右的.-- mysql低版本中where c=&#x27;daa&#x27; and a=100;//不会走索引的-- mysql5.7优化,优化成where a=100 and c=&#x27;add&#x27;;//才会走索引.-- a走了索引,c没有索引 - 特殊的场景 - 底层优化了.explain select * from index_test where c=&#x27;daa&#x27; and a=100;-- key_len = 5-- a列索引生效explain select * from index_test where a = 100;-- key_len = 5-- a,b生效explain select * from index_test where a=100 and b=10;-- key_len = 10-- 如果仅仅是根据a列查询,key_len是5,但是此时key_len是10.说明a,b索引都生效.-- a列是走了索引,但是c列没有走索引-- 必须要连续.这个是时候a和c是不连续的,中间跳过了b.所以只有a是生效的,但是c是不生效的.explain select * from index_test where a=100 and c=&#x27;daa&#x27;;-- key_len=5 范围之后索引列也会失效12345-- a列和b列是走了索引的,但是c列没有走索引.因为c列是范围之后的判断mysql&gt;explain select * from index_test where a=100 and b&gt;10 and c=&#x27;daa&#x27;;-- 如果三个索引都生效 - key_len=73-- 如果只有a,b走索引 - key_len=10 √ 模糊查询123456789101112like &#x27;%&#x27;出现在末尾,仍然a,b,c都是走索引-- key_len = 73 - a,b,c都是走了索引的mysql&gt; explain select * from index_test where a=100 and b=10 and c like &#x27;d%&#x27;;-- like &#x27;%&#x27;如果出现在开始,不走索引的-- 只有a,b是走了索引的,c是没有走索引的-- key_len = 10 mysql&gt;explain select * from index_test where a=100 and b=10 and c like&#x27;%d&#x27;;-- 只有a,b是走了索引的,c是没有走索引的-- key_len=10mysql&gt;explain select * from index_test where a=100 and b=10 and c like&#x27;%d%&#x27;; 索引列使用函数12345678910索引列套在函数中使用,将会导致索引失效-- 进行了ALL全表扫描mysql&gt; explain select * from index_test where abs(id)=1;+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | index_test | NULL | ALL | NULL | NULL | NULL | NULL | 5 | 100.00 | Using where |+----+-------------+------------+------------+------+---------------+------+---------+------+------+----------+-------------+ 索引列参加了计算1234-- 导致索引列失效mysql&gt; explain select * from index_test where id+1=2;-- 索引列正常mysql&gt; explain select * from index_test where id = 2 - 1; 索引列参与运算符12345678910111213141516171819202122232425262728-- 给员工表的提成率列添加一个索引-普通索引create index s_emp_cp on s_emp(commission_pct);-- is null(没有走索引)和is not null(走索引)-- is null - type=&#x27;ALL&#x27;mysql&gt;explain select first_name,commission_pct from s_emp where commission_pct is null;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+| 1 | SIMPLE | s_emp | NULL | ALL | s_emp_cp | NULL | NULL | NULL | 25 | 80.00 | Using where |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+-- is not null type=&#x27;range&#x27; - 走了索引的.mysql&gt; explain select first_name,commission_pct from s_emp where commission_pct is not null;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+| 1 | SIMPLE | s_emp | NULL | range | s_emp_cp | s_emp_cp | 5 | NULL | 5 | 100.00 | Using index condition |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+-- in(走索引 - range) not in(不走索引 - ALL)mysql&gt; explain select * from index_test where id in(1,2,3);mysql&gt; explain select * from index_test where id not in(1,2,3);-- 能用关联解决的,尽量不要使用not-- 找出没有选择任何一门课程的学生的信息 当数据量达到百万级别,利用索引列查询出来的数据超过整张表的30%,索引对应的重复的数据太多也是不适合创建索引的. 建立索引的策略 索引不是越多越好的. 因为索引也是需要占内容,也是需要到索引文件中去匹配索引的 - 需要消耗时间的.更新数据的同时,我们更新索引数据. 建立索引推荐的列 主键列和唯一性列 不经常发生改变的列 满足以上两个条件并且经常作为查询条件的列 不建议简历索引的列 重复值太多的列 null值太多的列 查询效率 数据库读写分离. 分表分库 - 水平分割和垂直分割 使用专门的搜索引擎 - es - elasticsearch/solr 避免使用索引查询导致索引失效 - 规避问题.","categories":[],"tags":[{"name":"索引","slug":"索引","permalink":"http://beautifulboyy/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"叮咚","slug":"life","date":"2021-08-21T13:06:18.000Z","updated":"2021-08-31T11:34:15.680Z","comments":true,"path":"2021/08/21/life/","link":"","permalink":"http://beautifulboyy/2021/08/21/life/","excerpt":"","text":"","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://beautifulboyy/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"mysql_practice","slug":"mysql-practice","date":"2021-08-21T13:03:42.000Z","updated":"2021-08-22T11:57:21.576Z","comments":true,"path":"2021/08/21/mysql-practice/","link":"","permalink":"http://beautifulboyy/2021/08/21/mysql-practice/","excerpt":"","text":"数据库笔试题1.查询id=1课程比id=2课程成绩高的学生的信息[学生id和学生的姓名]及课程分数 1234567891011121314151617181920212223242526-- 查询id=1的课程id,学生id以及分数select sid,cid,score from sc where cid=1;-- 查询id=2的课程id,学生id以及分数select sid,cid,score from sc where cid=2;-- 联合上面的两张表select a.sid,a.cid,a.score score1,b.cid cid2,b.score score2 from (select sid,cid,score from sc where cid=1) a join (select sid,cid,score from sc where cid=2) b on a.sid = b.sid;-- 查询score1&gt;score2的idselect c.sid,c.score1,c.score2 from (select a.sid,a.cid,a.score score1,b.cid cid2,b.score score2 from (select sid,cid,score from sc where cid=1) a join (select sid,cid,score from sc where cid=2) b on a.sid = b.sid) c where c.score1&gt;c.score2;-- 查询学生信息select s.sname,r.* from student s join (select c.sid,c.score1,c.score2 from (select a.sid,a.cid,a.score score1,b.cid cid2,b.score score2 from (select sid,cid,score from sc where cid=1) a join (select sid,cid,score from sc where cid=2) b on a.sid = b.sid) c where c.score1&gt;c.score2) r on s.id = r.sid;-- 方法二-- 把score2当成一个列select v1.sid,v1.score score1,(select v2.score score2 from sc v2 where v2.cid = 2 and v1.sid = v2.sid and v1.score&gt;v2.score) score2 from sc v1 where cid=1;-- 查询score2不为null的信息select * from (select v1.sid,v1.score score1,(select v2.score score2 from sc v2 where v2.cid = 2 and v1.sid = v2.sid and v1.score&gt;v2.score) score2 from sc v1 where cid=1) v where v.score2 is not null;-- 查询学生信息select s.sname,r.* from student s join (select * from (select v1.sid,v1.score score1,(select v2.score score2 from sc v2 where v2.cid = 2 and v1.sid = v2.sid and v1.score&gt;v2.score) score2 from sc v1 where cid=1) v where v.score2 is not null) r on s.id = r.sid;-- 结果+--------+------+--------+--------+| sname | sid | score1 | score2 |+--------+------+--------+--------+| 钱电 | 2 | 70.0 | 60.0 || 李云 | 4 | 50.0 | 30.0 |+--------+------+--------+--------+ 2.查询同时存在1 课程和2课程的情况 1234567891011121314151617-- 查询id=1的课程id,学生id以及分数select sid,cid,score from sc where cid=1;-- 查询id=2的课程id,学生id以及分数select sid,cid,score from sc where cid=2;-- 连接查询select a.sid,a.score score1,b.score score2 from (select sid,cid,score from sc where cid=1) a join (select sid,cid,score from sc where cid=2) b on a.sid = b.sid;-- 结果+------+--------+--------+| sid | score1 | score2 |+------+--------+--------+| 1 | 80.0 | 90.0 || 2 | 70.0 | 60.0 || 3 | 80.0 | 80.0 || 4 | 50.0 | 30.0 || 5 | 76.0 | 87.0 |+------+--------+--------+ 3.查询存在1 课程但可能不存在2课程的情况 123456789101112131415161718-- 查询id=1的课程id,学生id以及分数select sid,cid,score from sc where cid=1;-- 查询id=2的课程id,学生id以及分数select sid,cid,score from sc where cid=2;-- 连接查询select a.sid,a.score score1,b.score score2 from (select sid,cid,score from sc where cid=1) a left join (select sid,cid,score from sc where cid=2) b on a.sid = b.sid;-- 结果+------+--------+--------+| sid | score1 | score2 |+------+--------+--------+| 1 | 80.0 | 90.0 || 2 | 70.0 | 60.0 || 3 | 80.0 | 80.0 || 4 | 50.0 | 30.0 || 5 | 76.0 | 87.0 || 6 | 31.0 | NULL |+------+--------+--------+ 4.查询不存在1课程但存在2课程的情况 (不存在时显示为 null) 12345678910111213select b.sid,a.score score1,b.score score2 from (select sid,cid,score from sc where cid=1) a right join (select sid,cid,score from sc where cid=2) b on a.sid = b.sid;-- 结果+------+--------+--------+| sid | score1 | score2 |+------+--------+--------+| 1 | 80.0 | 90.0 || 2 | 70.0 | 60.0 || 3 | 80.0 | 80.0 || 4 | 50.0 | 30.0 || 5 | 76.0 | 87.0 || 7 | NULL | 89.0 |+------+--------+--------+ 5.查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩 123456789101112131415-- 查询平均成绩大于等于60分的同学id和它的平均成绩select sid,avg(score) avg_ from sc group by sid having(avg(score)&gt;60);-- 查询学生姓名select s.id,s.sname,r.avg_ from student s join (select sid,avg(score) avg_ from sc group by sid having(avg(score)&gt;60)) r on s.id = r.sid;-- 结果+------+--------+----------+| id | sname | avg_ |+------+--------+----------+| 1 | 赵雷 | 89.66667 || 2 | 钱电 | 70.00000 || 3 | 孙风 | 80.00000 || 5 | 周梅 | 81.50000 || 7 | 郑竹 | 93.50000 |+------+--------+----------+ 6.查询在 SC 表存在成绩的学生信息 1234567891011121314select s.id,s.sname,s.age from student s join (select distinct sid from sc) r on s.id = r.sid;-- 结果+------+--------+---------------------+| id | sname | age |+------+--------+---------------------+| 1 | 赵雷 | 1990-01-01 00:00:00 || 2 | 钱电 | 1990-12-21 00:00:00 || 3 | 孙风 | 1990-05-20 00:00:00 || 4 | 李云 | 1990-08-06 00:00:00 || 5 | 周梅 | 1991-12-01 00:00:00 || 6 | 吴兰 | 1992-03-01 00:00:00 || 7 | 郑竹 | 1989-07-01 00:00:00 |+------+--------+---------------------+ 7.查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩 1234567891011121314151617-- 查询学生的选课总数,课程总成绩以及学生idselect sid,count(cid) co_,sum(score) sum_ from sc group by sid;-- 查询学生姓名select s.sname,r.* from student s join (select sid,count(cid) co_,sum(score) sum_ from sc group by sid) r on s.id = r.sid;-- 结果+--------+------+-----+-------+| sname | sid | co_ | sum_ |+--------+------+-----+-------+| 赵雷 | 1 | 3 | 269.0 || 钱电 | 2 | 3 | 210.0 || 孙风 | 3 | 3 | 240.0 || 李云 | 4 | 3 | 100.0 || 周梅 | 5 | 2 | 163.0 || 吴兰 | 6 | 2 | 65.0 || 郑竹 | 7 | 2 | 187.0 |+--------+------+-----+-------+ 8.查询李姓老师的数量 12345678select count(*) from teacher where tname like &#x27;李%&#x27;;-- 结果+----------+| count(*) |+----------+| 1 |+----------+ 9.查询学过「张三」老师授课的同学的信息 123456789101112131415161718-- 查询张三的课程idselect c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;;-- 查询学生idselect sid from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;);-- 查询学生信息select * from student where id in (select sid from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;));-- 结果+------+--------+---------------------+------+| id | sname | age | sex |+------+--------+---------------------+------+| 1 | 赵雷 | 1990-01-01 00:00:00 | 男 || 2 | 钱电 | 1990-12-21 00:00:00 | 男 || 3 | 孙风 | 1990-05-20 00:00:00 | 男 || 4 | 李云 | 1990-08-06 00:00:00 | 男 || 5 | 周梅 | 1991-12-01 00:00:00 | 女 || 7 | 郑竹 | 1989-07-01 00:00:00 | 女 |+------+--------+---------------------+------+ 10.查询没有学全所有课程的学生信息 12345678910111213141516171819202122-- 查询课程总数select count(id) from course;-- 查询学生学习的课程总数select sid,count(cid) from sc group by sid;-- 查询学全所有课程的同学idselect sid from (select sid,count(cid) count_ from sc group by sid) a where a.count_ = (select count(id) from course);-- 查询没有学全的同学信息select * from student where id not in (select sid from (select sid,count(cid) count_ from sc group by sid) a where a.count_ = (select count(id) from course));-- 结果+------+--------+---------------------+------+| id | sname | age | sex |+------+--------+---------------------+------+| 5 | 周梅 | 1991-12-01 00:00:00 | 女 || 6 | 吴兰 | 1992-03-01 00:00:00 | 女 || 7 | 郑竹 | 1989-07-01 00:00:00 | 女 || 9 | 张三 | 2017-12-20 00:00:00 | 女 || 10 | 李四 | 2017-12-25 00:00:00 | 女 || 11 | 李四 | 2017-12-30 00:00:00 | 女 || 12 | 赵六 | 2017-01-01 00:00:00 | 女 || 13 | 孙七 | 2018-01-01 00:00:00 | 女 |+------+--------+---------------------+------+ 11.查询至少有一门课与学号为1的同学所学相同的同学的信息 12345678910111213141516171819-- 查询学号为1的同学所选的课程idselect cid from sc where sid = 1;-- 查询选了学号1的同学所选课程id的学生idselect distinct sid from sc where cid in (select cid from sc where sid = 1);-- 查询学生信息select s.id,s.sname,s.age from student s join (select distinct sid from sc where cid in (select cid from sc where sid = 1)) r on s.id = r.sid;-- 结果+------+--------+---------------------+| id | sname | age |+------+--------+---------------------+| 1 | 赵雷 | 1990-01-01 00:00:00 || 2 | 钱电 | 1990-12-21 00:00:00 || 3 | 孙风 | 1990-05-20 00:00:00 || 4 | 李云 | 1990-08-06 00:00:00 || 5 | 周梅 | 1991-12-01 00:00:00 || 6 | 吴兰 | 1992-03-01 00:00:00 || 7 | 郑竹 | 1989-07-01 00:00:00 |+------+--------+---------------------+ 12.查询和id=1的同学学习的课程 完全相同的其他同学的信息（重要） - 非常重要,非常重要,非常重要,非常重要,非常重要! 1234567891011121314151617181920212223-- 查询id=1的同学学习的课程idselect cid from sc where sid = 1;-- 查询id=1的同学学习的课程总数select count(cid) con_ from sc where sid=1;-- 查询选了id=1的同学没选的课程的学生idselect distinct sid from sc where cid not in (select cid from sc where sid = 1);-- 那么剩余的人都是选择了id=1的同学选择的课程,或者一门都没选的人.-- 查询剩下的人的id以及选择的课程总数select sid,count(cid) from sc where sid not in (select distinct sid from sc where cid not in (select cid from sc where sid = 1)) group by sid;-- 查询选择课程总数和id=1的人相同的sidselect sid from (select sid,count(cid) con_ from sc where sid not in (select distinct sid from sc where cid not in (select cid from sc where sid = 1)) group by sid) a where a.con_ = (select count(cid) con_ from sc where sid=1);-- 查询同学的信息select s.id,s.sname,s.age from student s join (select sid from (select sid,count(cid) con_ from sc where sid not in (select distinct sid from sc where cid not in (select cid from sc where sid = 1)) group by sid) a where a.con_ = (select count(cid) con_ from sc where sid=1)) r on s.id = r.sid;-- 结果+------+--------+---------------------+| id | sname | age |+------+--------+---------------------+| 1 | 赵雷 | 1990-01-01 00:00:00 || 2 | 钱电 | 1990-12-21 00:00:00 || 3 | 孙风 | 1990-05-20 00:00:00 || 4 | 李云 | 1990-08-06 00:00:00 |+------+--------+---------------------+ 13.查询没学过”张三”老师讲授的任一门课程的学生姓名 123456789101112131415161718-- 查询张三老师授课的idselect c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;;-- 查询学过&quot;张三&quot;老师课程的学生idselect sid from sc where cid in (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;);-- 查询学生姓名select s.sname from student s where id not in (select sid from sc where cid in (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;));-- 结果+--------+| sname |+--------+| 吴兰 || 张三 || 李四 || 李四 || 赵六 || 孙七 |+--------+ 14.查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 12345678910111213141516-- 查询学生id以及不合格的课程select sid,score from sc where score&lt;60;-- 查询不合格课程&gt;=2的学生idselect sid from (select sid,score from sc where score&lt;60) a group by sid having count(score)&gt;=2;-- 查询学生的id和平均成绩select sid,avg(score) avg_ from sc where sid in (select sid from (select sid,score from sc where score&lt;60) a group by sid having count(score)&gt;=2) group by sid;-- 查询学生姓名select s.id,s.sname,r.avg_ from student s join (select sid,avg(score) avg_ from sc where sid in (select sid from (select sid,score from sc where score&lt;60) a group by sid having count(score)&gt;=2) group by sid) r on s.id = r.sid;-- 结果+------+--------+----------+| id | sname | avg_ |+------+--------+----------+| 4 | 李云 | 33.33333 || 6 | 吴兰 | 32.50000 |+------+--------+----------+ 15.检索” 01 “课程分数小于 60，按分数降序排列的学生信息 123456789101112-- 查询01课程课程分数小于60的信息select sid,cid,score from sc where cid = 1 and score&lt;60;-- 查询学生信息并排序select s.id,s.sname,r.score from student s join (select sid,cid,score from sc where cid = 1 and score&lt;60) r on s.id = r.sid order by 3 desc;-- 结果+------+--------+-------+| id | sname | score |+------+--------+-------+| 4 | 李云 | 50.0 || 6 | 吴兰 | 31.0 |+------+--------+-------+ 16.按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 12345678910111213141516171819202122232425262728-- 求学生的平均成绩select sid,avg(score) avg_ from sc group by sid;-- 查询学生所有课程的成绩select v1.sid,v1.cid,v1.score,v2.avg_ from sc v1 join (select sid,avg(score) avg_ from sc group by sid) v2 on v1.sid = v2.sid order by 4 desc;-- 结果+------+------+-------+----------+| sid | cid | score | avg_ |+------+------+-------+----------+| 7 | 2 | 89.0 | 93.50000 || 7 | 3 | 98.0 | 93.50000 || 1 | 1 | 80.0 | 89.66667 || 1 | 2 | 90.0 | 89.66667 || 1 | 3 | 99.0 | 89.66667 || 5 | 2 | 87.0 | 81.50000 || 5 | 1 | 76.0 | 81.50000 || 3 | 1 | 80.0 | 80.00000 || 3 | 2 | 80.0 | 80.00000 || 3 | 3 | 80.0 | 80.00000 || 2 | 3 | 80.0 | 70.00000 || 2 | 1 | 70.0 | 70.00000 || 2 | 2 | 60.0 | 70.00000 || 4 | 1 | 50.0 | 33.33333 || 4 | 2 | 30.0 | 33.33333 || 4 | 3 | 20.0 | 33.33333 || 6 | 1 | 31.0 | 32.50000 || 6 | 3 | 34.0 | 32.50000 |+------+------+-------+----------+ 17.查询各科成绩前三名的记录 1234567891011121314151617select v1.sid,v1.cid,v1.score from sc v1 where exists (select 1 from sc v2 where v1.cid = v2.cid and v2.score&gt;v1.score having(count(*)&lt;3)) order by 2,3 desc;-- 结果+------+------+-------+| sid | cid | score |+------+------+-------+| 1 | 1 | 80.0 || 3 | 1 | 80.0 || 5 | 1 | 76.0 || 1 | 2 | 90.0 || 7 | 2 | 89.0 || 5 | 2 | 87.0 || 1 | 3 | 99.0 || 7 | 3 | 98.0 || 2 | 3 | 80.0 || 3 | 3 | 80.0 |+------+------+-------+ 18.查询每门课程被选修的学生数 12345678910select cid,count(sid) from sc group by cid;-- 结果+------+------------+| cid | count(sid) |+------+------------+| 1 | 6 || 2 | 6 || 3 | 6 |+------+------------+ 19.查询出只选修两门课程的学生学号和姓名 12345678910111213-- 只选修两门课的学生idselect sid from sc group by sid having(count(score)=2);-- 查询学生信息select s.id,s.sname from student s where id in (select sid from sc group by sid having(count(score)=2));-- 结果+------+--------+| id | sname |+------+--------+| 5 | 周梅 || 6 | 吴兰 || 7 | 郑竹 |+------+--------+ 20.查询男生、女生人数 123456789101112131415select sex,count(*) from student group by sex;-- 结果+------+----------+| sex | count(*) |+------+----------+| 女 | 8 || 男 | 4 |+------+----------+select count(*) 男,(select count(*) from student s2 where s2.sex = &#x27;女&#x27;) 女 from student s1 where s1.sex = &#x27;男&#x27;;-- 结果+-----+------+| 男 | 女 |+-----+------+| 4 | 8 |+-----+------+ 21.查询名字中含有「风」字的学生信息 1234567select * from student where sname like &#x27;%风%&#x27;;-- 结果+------+--------+---------------------+------+| id | sname | age | sex |+------+--------+---------------------+------+| 3 | 孙风 | 1990-05-20 00:00:00 | 男 |+------+--------+---------------------+------+ 22.查询同名同性学生名单，并统计同名同性人数 1234567select s.sname,s.sex,count(*) from student s group by s.sname,s.sex having count(*)&gt;1;-- 结果+--------+------+----------+| sname | sex | count(*) |+--------+------+----------+| 李四 | 女 | 2 |+--------+------+----------+ 23.查询 1990 年出生的学生名单 12345678910select * from student where year(age)=1990;-- 结果+------+--------+---------------------+------+| id | sname | age | sex |+------+--------+---------------------+------+| 1 | 赵雷 | 1990-01-01 00:00:00 | 男 || 2 | 钱电 | 1990-12-21 00:00:00 | 男 || 3 | 孙风 | 1990-05-20 00:00:00 | 男 || 4 | 李云 | 1990-08-06 00:00:00 | 男 |+------+--------+---------------------+------+ 24.查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 123456789select cid,avg(score) from sc group by cid order by 2 desc,1;-- 结果+------+------------+| cid | avg(score) |+------+------------+| 2 | 72.66667 || 3 | 68.50000 || 1 | 64.50000 |+------+------------+ 25.查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩 123456789101112-- 查询平均成绩大于85的学生idselect sid,avg(score) avg_ from sc group by sid having(avg(score)&gt;=85);-- 查询姓名select s.id,s.sname,r.avg_ from student s join(select sid,avg(score) avg_ from sc group by sid having(avg(score)&gt;=85)) r on s.id = r.sid;-- 结果+------+--------+----------+| id | sname | avg_ |+------+--------+----------+| 1 | 赵雷 | 89.66667 || 7 | 郑竹 | 93.50000 |+------+--------+----------+ 26.查询课程名称为「数学」，且分数低于 60 的学生姓名和分数 12345678910111213-- 查询数学课的idselect id from course where cname = &#x27;数学&#x27;;-- 查询分数低于60的学生id和分数select sid,score from sc join (select id from course where cname = &#x27;数学&#x27;) a on sc.cid = a.id where score&lt;60;-- 查询姓名select s.id,s.sname,r.score from student s join (select sid,score from sc join (select id from course where cname = &#x27;数学&#x27;) a on sc.cid = a.id where score&lt;60) r on s.id = r.sid;-- 结果+------+--------+-------+| id | sname | score |+------+--------+-------+| 4 | 李云 | 30.0 |+------+--------+-------+ 27.查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数 1234567891011121314151617181920212223-- 查询成绩在70分以上的学生id和课程idselect * from sc where score&gt;70;-- 查询课程名称select c.cname,a.* from course c join (select * from sc where score&gt;70) a on c.id = a.cid;-- 查询学生名称select s.sname,r.cname,r.score from student s join (select c.cname,a.* from course c join (select * from sc where score&gt;70) a on c.id = a.cid) r on s.id = r.sid;-- 结果+--------+--------+-------+| sname | cname | score |+--------+--------+-------+| 赵雷 | 语文 | 80.0 || 赵雷 | 数学 | 90.0 || 赵雷 | 英语 | 99.0 || 钱电 | 英语 | 80.0 || 孙风 | 语文 | 80.0 || 孙风 | 数学 | 80.0 || 孙风 | 英语 | 80.0 || 周梅 | 语文 | 76.0 || 周梅 | 数学 | 87.0 || 郑竹 | 数学 | 89.0 || 郑竹 | 英语 | 98.0 |+--------+--------+-------+ 28.查询存在不及格的课程 12345678910111213-- 查询存在不及格的课程idselect distinct cid from sc where score&lt;60;-- 查询课程信息select c.id,c.cname from course c join (select distinct cid from sc where score&lt;60) r on c.id = r.cid;-- 结果+------+--------+| id | cname |+------+--------+| 1 | 语文 || 2 | 数学 || 3 | 英语 |+------+--------+ 29.查询课程编号为 01 且课程成绩在 80 分及以上的学生的学号和姓名 123456789101112-- 查询课程号为1的学生id和成绩select sid,score from sc where cid = 1 and score &gt;= 80;-- 查询学生姓名select s.id,s.sname,r.score from student s join (select sid,score from sc where cid = 1 and score &gt;= 80) r on s.id = r.sid;-- 结果+------+--------+-------+| id | sname | score |+------+--------+-------+| 1 | 赵雷 | 80.0 || 3 | 孙风 | 80.0 |+------+--------+-------+ 30.假设成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 123456789101112131415-- 查询张三老师教的课程idselect c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;;-- 查询张三老师教的课程的最高分select max(score) from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;);-- 查询学生id和成绩select sid,score from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;) and score = (select max(score) from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;));-- 查询学生信息select s.id,s.sname,r.score from student s join (select sid,score from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;) and score = (select max(score) from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;))) r on s.id = r.sid;-- 结果+------+--------+-------+| id | sname | score |+------+--------+-------+| 1 | 赵雷 | 90.0 |+------+--------+-------+ 31.假设成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 1234567891011121314151617181920212223242526272829303132333435363738394041-- 修改sid=4的值mysql&gt; select * from sc;+------+------+-------+| sid | cid | score |+------+------+-------+| 1 | 1 | 80.0 || 1 | 2 | 90.0 || 1 | 3 | 99.0 || 2 | 1 | 70.0 || 2 | 2 | 60.0 || 2 | 3 | 80.0 || 3 | 1 | 80.0 || 3 | 2 | 80.0 || 3 | 3 | 80.0 || 4 | 1 | 90.0 || 4 | 2 | 90.0 || 4 | 3 | 90.0 || 5 | 1 | 76.0 || 5 | 2 | 87.0 || 6 | 1 | 31.0 || 6 | 3 | 34.0 || 7 | 2 | 89.0 || 7 | 3 | 98.0 |+------+------+-------+-- 查询张三老师教的课程idselect c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;;-- 查询张三老师教的课程的最高分select max(score) from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;);-- 查询学生id和成绩select sid,score from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;) and score = (select max(score) from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;));-- 查询学生信息select s.id,s.sname,r.score from student s join (select sid,score from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;) and score = (select max(score) from sc where cid = (select c.id from course c join teacher t on c.tid = t.id where t.tname = &#x27;张三&#x27;))) r on s.id = r.sid;-- 结果+------+--------+-------+| id | sname | score |+------+--------+-------+| 1 | 赵雷 | 90.0 || 4 | 李云 | 90.0 |+------+--------+-------+ 32.查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 123456789101112select distinct s.* from sc s join sc c on s.cid&lt;&gt;c.cid and s.score = c.score order by 1;-- 结果+------+------+-------+| sid | cid | score |+------+------+-------+| 1 | 1 | 80.0 || 2 | 3 | 80.0 || 3 | 2 | 80.0 || 3 | 3 | 80.0 || 3 | 1 | 80.0 |+------+------+-------+5 rows in set (0.00 sec) 33.统计每门课程的学生选修人数（超过 5 人的课程才统计） 123456789select cid,count(cid) from sc group by cid having count(cid) &gt; 5;-- 结果+------+------------+| cid | count(cid) |+------+------------+| 1 | 6 || 2 | 6 || 3 | 6 |+------+------------+ 34.检索至少选修两门课程的学生学号 12345678910111213select sid from sc group by sid having count(score)&gt;=2;-- 结果+------+| sid |+------+| 1 || 2 || 3 || 4 || 5 || 6 || 7 |+------+ 35.查询选修了全部课程的学生信息 12345678910111213141516-- 查询所有课程数量select count(id) from course;-- 查询选修了所有课程的学生idselect sid from sc group by sid having count(score) = (select count(id) from course);-- 查询学生信息select s.id,s.sname from student s join (select sid from sc group by sid having count(score) = (select count(id) from course)) r on s.id = r.sid;-- 结果+------+--------+| id | sname |+------+--------+| 1 | 赵雷 || 2 | 钱电 || 3 | 孙风 || 4 | 李云 |+------+--------+","categories":[],"tags":[{"name":"数据库笔试题","slug":"数据库笔试题","permalink":"http://beautifulboyy/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AF%95%E9%A2%98/"}]},{"title":"数据库DTL","slug":"mysql03","date":"2021-08-21T02:27:00.000Z","updated":"2021-08-23T07:00:48.333Z","comments":true,"path":"2021/08/21/mysql03/","link":"","permalink":"http://beautifulboyy/2021/08/21/mysql03/","excerpt":"","text":"DTLData Transaction Language - 数据事务语言 commit,begin,start transction,savepoint,rollback 事务只要使用客户端连接到mysql-server[mysql服务器],就会自动打开一个事务 在MYSQL中,所有的DML(insert,update,delete)操作在执行之后都会有一个commit操作[隐式的] commit - 提交事务 在ORACLE中,所有的DML(insert,update,delete)操作之后,如果没有手动commit,那么在另外一个事务中是读不到最新的更新数据的. 事务的定义: 就是指一组相关的SQL操作,我们所有的操作都是处在事务中的. 控制事务 - 就是控制事务的边界(事务的开始(begin) - 事务的结束(commit,rollback)) 一个事务的结束,代表着下一个事务的开始. 注意: 在数据库中**,执行业务的基本单位是事务,不是以某一条SQL** 数据库在默认情况下,事务都是打开的,也就是说它是一直处在事务中的,一个事务的结束,代表着下一个事务的开启 执行commit或者rollback指令时,会结束当前事务 [已经提交的事务将不能够被回滚 - 已经不处于同一个事务中了,而事务与事务之间是隔离的] 作用:用来保证数据的平稳性和可预测性. 事务的四大特性(ACID): Atomicity,原子性,事务是不可再分割的,要么同时成功,要么同时失败. 转账业务(账户+money,账户-money - 一组sql - 至于一个事务当中,并且要保证原子性.) Consistency,一致性,事务一旦结束,内存中的数据和数据库中的数据是保持一致的 example：A用户和B用户进行转账1000元，A账户减少1000和B账户增加1000的sql语句必须全部执行成功，不存在一半成功，一半失败。但是无论如何执行，两个账户金额的改变加起来一定1000元，这就是一致性(完整性)。 Isolation,隔离性,事务之间互不干扰,一多个用户并发访问数据库，比如同时操作一张表。数据库为每一个用户开启事务。每个事务相互独立，互不干扰。 Durability,持久性,事务一旦提交,则数据持久化到数据库中,永久保存 [涉及到数据库的备份和恢复的一些技术,冷备份,热备份…] 事务控制语句DTL - 事务控制语句 BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 事务控制语句的演示rollback 回滚前提 - 设置成手动提交事务 如果没有设置事务点,rollback撤销所有的dml操作 12345678910111213141516171819202122232425262728293031323334353637mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec)mysql&gt; delete from video_copy where id = 2;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.11 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec) 注意的是rollback只能撤销/回滚尚未提交的事务.如果一个事务已经提交了,那么是回滚不了的 1234567891011121314151617181920212223242526272829mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; delete from video_copy where id = 2;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.12 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec) 设置事务点命令 12savepoint 事务点名称rollback to 事务点名称 效果就是会撤销到设置事务点下方的dml操作.事务点之前的dml操作将不会撤销 12345678910111213141516171819202122232425mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; delete from video_copy where id = 1;Query OK, 1 row affected (0.00 sec)mysql&gt; savepoint a;Query OK, 0 rows affected (0.00 sec)mysql&gt; delete from video_copy where id=3;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from video_copy;Empty set (0.00 sec)mysql&gt; rollback to a;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+1 row in set (0.00 sec) mysql事务处理的方法自动开始事务 当我们mysql客户端连接到mysql服务器 - 自动开启 当执行完sql语句之后,自动会commit[事务的提交 - 意味着当前事务已经结束] 一个事务的结束意味着下一个事务的开始. commit/rollback - 结束事务. 手动开启事务执行dml操作之后,就不会自动提交事务[commit],需要手动commit 用 BEGIN, ROLLBACK, COMMIT来实现 1-1. BEGIN 开始一个事务 1-2. start transaction - 手动开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 直接用 SET 来改变 MySQL 的自动提交模式: 2-1. SET AUTOCOMMIT=0 禁止自动提交 2-2. SET AUTOCOMMIT=1 开启自动提交 注意:设置成禁止自动提交的操作的话,这个操作仅仅是针对当前的会话窗口有效. 演示A事务 - 执行了delete操作,但是还没有commit. 但是在A事务当中,查询的时候,是可以查询到delete的效果的 123456789101112131415161718192021222324mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec)mysql&gt; delete from video_copy where id=2;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec) 但是在另外一个事务B中,是看不到A事务中尚未提交的数据的[仍然是可以看到id=2这条数据的] 123456789101112mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec) 对A事务执行一个commit操作 12mysql&gt; commit;Query OK, 0 rows affected (0.11 sec) B事务仍然看不到A事务提交的数据 123456789mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec) B事务提交,也结束了当前的事务,自动开启一个新的事务,在新的事务中重新再查一次,可以看到A事务提交的结果了. 1234567891011mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec) 多事务的并发处理机制原因:多个事务同时操作一个表中的同一行数据(争抢临界资源),如果这些操作是.修改操作的话,就会产生并发问题,如果不处理,则会造成数据不一致的情况. 数据库可能产生的并发问题包括: 脏读 一个事务读取到了另外一个事务中尚未提交的数据. 是指一个事务正在访问数据,并且对这个数据进行修改,而这种修改还没有提交到数据库中,而另一个事务也访问了这个数据,并且使用了这个数据解决方法:一个事务在修改数据时,该数据不能被其他事务访问 所有的数据库都是拒绝脏读 - “会读到脏数据”. 不可重复读 是指一个事务多次读取同一条记录,如果此时另一个事务也访问并且修改了该数据,则就会出现多次读取出现数据不一致的情况,原来的数据变成了不可重复读取的数据 解决方法:只有在修改事务完全提交过后才可以读取到数据 幻读 是指一个事务修改表中的多行记录,但是此时另一个事务对该表格进行了插入数据的操作,则第一个事务会发现表格中会出现没有被修改的行,就像发生了幻觉一样 解决方法:在一个事务提交数据之前,其他事务不能添加数据 不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了.幻读的重点在于新增或者删除 演示脏读1mysql&gt; set session transaction isolation level read uncommitted; 只有这种隔离状态下会导致脏读 A事务 1234567891011121314mysql&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 3000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 3000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) A事务 123mysql&gt; update account set balance = 2000.0 where id = 1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 B事务:此时B事务读取数据时出现了脏读,读取了A事务还没有提交的数据. 12345678mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 2000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) 不可重复读A事务 1234567891011121314mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) A事务 123mysql&gt; update account set balance = 2000.0 where id = 1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 B事务:没有出现脏读 12345678mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.08 sec) A事务 12mysql&gt; commit;Query OK, 0 rows affected (0.10 sec) B事务:出现了不可重复读的情况,前后结果不一致. 12345678mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 2000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) 幻读A事务 123456789101112131415161718192021222324252627282930313233343536373839404142mysql&gt; use j03s;Database changedmysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 || 3 | jack | 1000.00 |+----+-------+---------+3 rows in set (0.00 sec)mysql&gt; update account set balance = 2000;Query OK, 3 rows affected (0.00 sec)Rows matched: 3 Changed: 3 Warnings: 0mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 2000.00 || 2 | tom | 2000.00 || 3 | jack | 2000.00 |+----+-------+---------+3 rows in set (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 2000.00 || 2 | tom | 2000.00 || 3 | jack | 2000.00 || 4 | lucy | 3000.00 |+----+-------+---------+4 rows in set (0.00 sec) B事务 1234567891011121314151617181920212223mysql&gt; use j03s;Database changedmysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 || 3 | jack | 1000.00 |+----+-------+---------+3 rows in set (0.00 sec)mysql&gt; insert into account values(4,&#x27;lucy&#x27;,3000);Query OK, 1 row affected (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.03 sec) A事务 1 B事务 1 A事务 1 B事务 1 事务隔离级别 READ UNCOMMITTED 这是事务最低的隔离级别,它允许另外一个事务可以看到这个事务未提交的数据. 解决第一类丢失更新的问题,但是会出现脏读,不可重复读. READ COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取,即另外一个事务不能读取该事务未提交的数据. 解决第一类丢失更新和脏读的问题,但是会出现不可重复读. REPEATABLE READ 保证一个事务相同条件下前后两次获取的数据是一致的. 解决第一类丢失更新,脏读,不可重复读问题. SERIALIZABLE 事务被处理为顺序执行. 解决所有问题 - 有点类似于锁表,但性能极其低下. 提醒:mysql默认的事务隔离级别为repeatable_read 总结 事务隔离级别 脏读 不可重复读 幻读 读取未交(read uncommitted) √ √ √ 读已提交(read committed) × √ √ 可重复读(repeatable read) × × √ 串行化(serializable) × × × 事务的演示准备工作 1234567drop table account;create table account( id int(7) primary key, name varchar(20), balance double(7,2));insert into account values(1,&#x27;admin&#x27;,1000.00),(2,&#x27;tom&#x27;,&#x27;20000.0&#x27;); READ UCOMMITTED开发中绝对拒绝使用这种隔离级别 设置事务的隔离级别READ UCOMMITTED - 一个事务才可以读取到另外一个事务尚未提交的数据. A事务 1234567891011121314mysql&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) A事务 123mysql&gt; update account set balance = 1000.0 where id=2;Query OK, 1 row affected (0.10 sec)Rows matched: 1 Changed: 1 Warnings: 0 B事务:读取到了脏数据,另外一个事务中尚未提交的数据 12345678mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) A事务 12mysql&gt; rollback;Query OK, 0 rows affected (0.12 sec) B事务:在同一个事务中,多次读取到的数据不一样 12345678mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) 总结:一旦事务设置成了读未提交的隔离级别.产生脏读以及不可重复读的效果 READ COMMITTED设置事务的隔离级别为read committed A事务 1234567891011121314mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) A事务 123mysql&gt; update account set balance=1000.0 where id=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 B事务:此时发现balance没有改变,没有产生脏读 12345678mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) A事务 12mysql&gt; commit;Query OK, 0 rows affected (0.11 sec) B事务:在当前事务中多次查询,发现读取到了不同的数据,不可重复读. 123456789mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) 总结: 一个事务只能读取到另外一个事务中已经提交的数据 不会出现脏读了,但仍然出现不可重复读 REPEATABLE READ可重复读 - 在同一个事务中,多次读取到的数据是一样的[不关心其他事务做了什么] - mysql的默认的隔离级别 A事务 1234567891011121314mysql&gt; set session transaction isolation level repeatable read;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level repeatable read;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) A事务 123mysql&gt; update account set balance=2000.0 where id=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 B事务:拒绝脏读 12345678mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) A事务 12mysql&gt; commit;Query OK, 0 rows affected (0.12 sec) B事务:可重复读 1234567891011121314151617181920mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 2000.00 |+----+-------+---------+2 rows in set (0.00 sec) 在同一个事务中,不关心其他事务是否对这个数据作任何改变,当前的事务中多次读取到的结果是一样的,如果想要读取到另外一个事务修改的数据,必须先结束自己当前的事务再去查询. SERIALIZABLE串行化 A事务 1234567891011121314mysql&gt; set session transaction isolation level serializable;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level serializable;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.33 sec) A事务:对数据库进行update操作,发现被锁住,无法继续进行下去,等待很长时间以后报错. 12mysql&gt; update account set balance = 2000 where id = 1;ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction B事务 12mysql&gt; commit;Query OK, 0 rows affected (0.00 sec) A事务:B事务提交事务以后A事务再进行update操作,发现可以顺利执行. 123mysql&gt; update account set balance = 2000 where id = 1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0","categories":[],"tags":[{"name":"DTL","slug":"DTL","permalink":"http://beautifulboyy/tags/DTL/"}]},{"title":"数据库DDL DML","slug":"mysql02","date":"2021-08-20T06:27:30.000Z","updated":"2021-08-21T02:26:30.064Z","comments":true,"path":"2021/08/20/mysql02/","link":"","permalink":"http://beautifulboyy/2021/08/20/mysql02/","excerpt":"","text":"DDLDDL [Data Definition Language] - 数据定义语言 SQL命令 create - 创建 创建表(table),视图(view),用户(user),函数(function),存储过程(procedure),数据库(database),约束(constraints) 以上构建的都是属于数据库DB的对象/单位 - DB的基本单位是table drop - 删除 删除表(table),,视图(view),用户(user),函数(function),存储过程(procedure),数据库(database),约束(constraints) 但是不能够删除具体行记录,行记录是由delete命令删除的. alter - 修改 修改列名,列的类型,修改约束 - 使用情况很少 rename to - 修改表名 comment - 创建列的时候加上注释 truncate - 清空整张表 ORM思想Object-Relational-Mapping - 对象关系映射 需要用到OO思想[第一步找出对象,分析对象的属性,分析对象的功能,考虑对象之间的关系]来进行实体类的设计 - 数据库的设计 掌握目标 - 看到实体类-&gt;表结构;看到表结构-&gt;实体类 映射规则: 实体类 - 表名 对象标识(id) - 主键(id) - primary key - 非空且唯一 普通属性 - 普通列[推荐俩者的名称保持一致.需要注意的是如果列是多个名称[匈牙利] - 小驼峰] 对象之间的关系 - 外键(foreign key) - 表与表之间是通过外键来进行关联.[进行关联查询的基础] 通常情况下某张表的外键是指向另外一张表的主键的. 对象之间的关系分析一个”小米商城”,利用OO思想,找出业务中的关键对象 登录,注册 - “用户User对象” - (id,phone,password,login_time,login_ip) 个人中心 - 其中有一块是用来负责展示用户的详情UserInfo 产品 产品详情 购物车 - id,商品id,商品名称,商品单价,num,小计算,总价,备注 订单 - 一个用户拥有多个订单,一个订单只能属于一个用户 产品分类表 1:N N:N 1:1User和UserInfo:一个用户匹配一个用户详情,一个用户详情仅属于一个用户 强调的是平等性 - 表设计中,外键可以出现在任何一方表中. 原则 - 能用单向关联解决的业务就不要使用双向关联 java实体类 12345678910111213141516171819202122232425262728293031先阶段的思想 - 实体类中没有外键的概念关系具有方向性单向关联 - 关系的维护仅仅在其中一方存在 // 情况一public class User&#123; private Integer id; private String phone; private String password; // 一个用户拥有一个用户详情对象 private UserInfo userInfo;&#125;public class UserInfo&#123; private Integer id; private String header; private Gender sex;&#125;// 情况二public class User&#123; private Integer id; private String phone; private String password;&#125;public class UserInfo&#123; private Integer id; private String header; private Gender sex; private User user;&#125; ORM思想的精髓 - 如何进行映射以及为什么需要这种思想 12345678910111213// 双向关联[不建议]public class User&#123; private Integer id; private String phone; private String password; private UserInfo userInfo;&#125;public class UserInfo&#123; private Integer id; private String header; private Gender sex; private User user;&#125; 表设计 情况一: user表 id phone password user_info_id 1 110 123456 2 2 111 123456 1 3 112 123456 3 user_info表 id header sex 1 xx.png f 2 tt.png m 3 zz.png f 情况二: user表 id phone password 1 110 123456 2 111 123456 3 112 123456 user_info表 id header sex user_id 1 xx.png f 2 2 tt.png m 1 3 yy.png f 3 1:N一个用户对象和购物车对象 一个用户可以拥有多个购物车对象,但是一个购物车对象只能属于一个用户 外键存储在多的那一方 实体类 123456789101112131415161718192021222324252627// 单向关联1public class User&#123; // 普通属性 // 一个用户可以拥有多个购物车对象 private Set&lt;Cart&gt; carts;&#125;public class Cart&#123; &#125;// 单向关联2public class User&#123; //普通属性&#125;public class Cart&#123; // // 一个购物车只能属于一个用户 private User user;&#125;// 双向关联public class User&#123; private Set&lt;Cart&gt; carts;&#125;public class Cart&#123; private User user;&#125; 推荐使用第一种单向关联的方式 表结构 user表 id phone password 1 110 123 2 114 123 3 115 123 购物车cart表 id product_id product_name user_id 1 1 mi01 3 2 2 mi02 1 3 3 mi02 2 N:N需要拆分成两个一对多 一个学生可以选择多门课程,一个课程可以被多个学生选择 一个客户可以购买多个商品,一个商品可以被多个用户购买 customer表 id cname 1 admin 2 tom product表 id pname price 1 mac 100000 2 xiaomi 8000 3 huawei 8000 4 联想 7000 需要建立第三方表,来确定customer表和product表的关系.N:N–&gt;拆分成两个1:N purchase表 -&gt; 购买表 采用的是联合主键[组合主键] 主键-primary key - 非空且唯一.作用:用来确定唯一元组[行] 所谓的”俩个1:n” - customer表和purcase表以及product表和purcase表 一个客户拥有多条购买记录[1:N] 一个产品拥有多条被购买记录[1:N] 主键列未必是单列[常见的id列] , N:N场景可以采取联合主键,主键列由俩列共同组成**(customer_id,product_id)** 外键列通常情况是引入另外一张表的主键列.在该表中.外键列有2列 分别是customer_id 引用了customer表中的id列 product_id引用了product表中的id列 customer_id product_id 1 1 1 2 2 1 2 3 2 4 另一种情况关于主键的选择.第三方表[用来维护关系的表],开发的时候,还是推荐给这张自己一个单独的主键列 id customer_id product_id 1 1 1 2 1 2 3 2 1 4 2 3 5 2 4 自关联当前表的外键列自关联到了自己表中的主键列 s_emp id first_name manager_id[上司id] 1 Carmen 2 Mark 1 3 tom 1 4 admin 2 5 jack 2 分析评论业务以抖音为例 - User - Video 关注评论功能.一个用户可以评论多个视频,一个视频可以被多个用户评论 - N:N User表 id phone password username 1 110 123 qwq 2 111 123 qaq 3 112 123 ovo Video表 一个用户可以发布多个视频,但是一个视频只能由一个用户去发布 1:N id 视频标题 视频点赞量 user_id 1 吴老师 100万+ 2 2 霍老师 2000+ 1 3 翟老师 18 1 评论表 - 重点体现出谁评论了哪个视频即可. 外键列是可以为空的 id 视频id user_id 评论内容 comment_pid 1 1 4 无语了 2 1 5 渣男 3 2 2 彼此彼此 4 1 6 就是啊 1 user_id=6的评论不是直接对视频进行评论的,属于第二层评论,它是对user_id=4的人进行评论的. 除了评论还有回复 第一层 - 评论表的数据 第二层 - 对第一层的评论继续评论 第三层 - 对第二层以及其以后的评论/回复 - 叫做回复 回复表 一个评论可以引起多个回复 - reply id comment_id content replay_id user_id 1 4 真不明白怎么会有这样的人 1 2 4 这种人真的无语了 1 2 结构: user_id=1的用户发视频 user_id=4: 无语了 ​ user_id=6: 就是啊 ​ user_id=1回复了user_id=6: 真不明白怎么会有这样的人 ​ user_id=2回复了user_id=1: 这种人真的无语了 表设计 - 三大范式表设计一定尽可能去遵守三大范式 作用:指导db的设计更加合理化,避免数据的冗余. 第一范式1NF:保证列的原子性,列不可再分割 1234567891011s_emp(id,name);但是发现外国的name比较特殊.发现name列是可再分割的.不符合1NF.需要对name进行切割s_emp(id,first_name,last_name);address只需要包含省市区school(id,name,address);1 苏州大学 江苏省苏州市工业园区2 常州大学 江苏省常州市武进区3 苏州科技学院 江苏省苏州市高新区school(id,name,province,city,area); 第二范式2NF:基于1NF,不存在非关键列部分依赖于关键列,非关键列要全部依赖于关键列. 关键列 - 主键列; 非关键列 - 非主键列. 12345678910111213141516171819202122-- student,course表 - 所有的信息合并到一张表了.--1. student信息以及course信息都会存在数据的冗余性-- 如何确定主键列[单列,组合形式] - 能够确定唯一的一条行记录 - sid,cid-- db设计中,并不是表的数量或者列的数量越少越好的 - 满足三大范式-- 关键列(sid,cid),非关键列(sname,cname)-- ①(sid,cid) -&gt; 唯一确定 sname 实际上如果关键列中的部分列sid就可以确定了sname的值 sname只需要由关键列(sid,cid)中的部分列[也就是sid列]就可以确定了. 存在了非关键列sname部分依赖于关键列,违背了2NF-- ②(sid,cid) -&gt; 唯一确定 cnamestudent_course(sid,sname,cid,cname)sid sname cid cname1 tom 1 java1 tom 2 python2 admin 1 java2 admin 3 jack为了满足2NFstudent(sid,sname);//学生表 sid-&gt;snamecourse(cid,cname);//课程表 cid-&gt;cnamesc(sid,cid,score);//选课表 (sid,cid)-&gt; score 第三范式3NF:基于2NF,不存在非关键列传递依赖于关键列,所有的非关键列要直接依赖于关键列 12345678910111213141516171819202122student(id,sname,uno,uname,address)1 tom x1001 苏州大学 江苏省2 jack x1002 社会大学 东北省3 james x1001 苏州大学 江苏省关键列只有id列①关键列id可以直接确定一个唯一的uno的②uno又可以直接确定唯一的一个uname③给定一个学生的id,也是可以确定一个唯一的unameid -&gt; uno -&gt; uname =&gt; id -&gt; unameuname是间接被id确定下来的-uname是间接依赖[通过一个uno传递依赖]于关建列id.违背了3NF,存在了非关键列传递依赖于关键列.所有的非关键列要直接依赖于关键列 - 所有的非关键列应该是直接被关键列来确定的.修改 - 拆分student(id,sname,uid);//uid就是大学的idid -&gt; uid(引用university表中的id列)university(id,uno,uname,adress)uid-&gt;uname 建表1234567891011CREATE TABLE 表名( 列名 数据类型[(长度)], 列2 数据类型[(长度)], ... ... 列 数据类型[(n)])ENGINE=InnoDB DEFAULT CHARSET=utf8;-- mysql5.7及其以上可以省略了ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 前提是my.ini文件配置好了-- 指定我们的数据的存储引擎InnoDB,表编码是utf8 数据类型列的数据类型就是用来限制你将来插入数据到该列的限制.该列是什么类型,就需要插入什么类型的数据 数字相关的 a. 整数 - int和bigint b. 小数 - float,double[使用最多],decimal 笔试题中:TINYINT(1个字节)或者smallint(2个字节) 字符串相关的 - mysql中字符串是用单引号表示的 a. char(n) - 固定长度 - 0-255 bytes[ascill] b. varchar(n) - 可变长度 - 0-65535 bytes[unicode的范围] c. text - 长文本数据 笔试题中:mysql中char和varchar的区别 123456数字5代表的是该列可以存储的字符串的个数.不是代表字节数char(5) - 定长字符的意思是即时该列仅仅保存一个字母&#x27;a&#x27;,那么在内存中,char的实际消耗的长度就是5个 - &quot;浪费&quot; 对char类型的列的读写操作效率高于varcharvarchar(5) - 可变长度[最大可保存的字符串的长度],实际存储了一个字母&#x27;a&#x27;.实际也就只消耗了一个1长度 - &quot;节约了内存&quot; - 按需分配.因此,开发中尽可能字符串使用varchar,而不使用char. 日期 a. date -&gt; 即使保存的是年月日时分秒,查询出来的也仅仅只会显示到年月日 b. datetime-&gt;年月日时分秒.即使保存的数据仅仅是年月日.但是查询出来的时候,可以显示年月日时分秒 建表demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253drop table tbl_product;create table tbl_product( id int(3), name varchar(20), create_time date, price double(10,2));-- 分析括号中的参数-- int(3)-并不会影响该列可插入数据的一个范围.范围仍然是int型的范围-- 为了看出来int(3),修改一下建表语句-- int(13)想要看出来效果,这个列一定要加上zerofill,不足位数的用0填充create table tbl_product( id int(13) zerofill, name varchar(20), create_time date, price double(7,2));mysql&gt; insert into tbl_product values(1234,&#x27;tom&#x27;,now(),123.45);mysql&gt; select * from tbl_product;+---------------+------+-------------+--------+| id | name | create_time | price |+---------------+------+-------------+--------+| 0000000001234 | tom | 2021-08-19 | 123.45 |+---------------+------+-------------+--------+总结:int(n)此处的n不会影响插入到该列的数据的大小.那么n是配合zerofill来进行的.查询的时候,不足n位的数字全部用0填充.-- 修改表结构-测试varchar(n)中的n - 个数create table tbl_product( id int(7), name varchar(2), create_time date, price double(10,2));-- 如果varchar(n)设置成了2,但是插入了&#x27;tom&#x27;,报错-- ERROR 1406 (22001): Data too long for column &#x27;name&#x27; at row 1mysql&gt; insert into tbl_product values(1,&#x27;tom&#x27;,now(),123.45);-- 总结:varchar(n) - 中的n是代表的是字符的个数[一个汉字就是代表一个]-- double(m,n)-- m代表的是总长度,n代表的是精度 - double(7,2)create table tbl_product( id int(7), name varchar(20), create_time date, price double(7,1));mysql&gt; insert into tbl_product values(2,&#x27;admin&#x27;,&#x27;2021-10-01&#x27;,123456.56789);-- double(7,2) -&gt; 7就是总的长度,2代表的精度[四舍五入] - 123456.56789 -- 插入失败了 - Out of range value for column &#x27;price&#x27; at row 1-- 插入失败的原因是123456.57 -&gt; 这个结果已经超过了总的长度7了.-- 修改double(7,1) -&gt; 123456.56789 -&gt; 123456.6 -&gt; 仍然没有超过7这个总的长度的. - 可以被插入进去的 分析括号中的参数. int(n) 并不会影响该列可插入数据的一个范围,范围仍然是int型的范围.n是配合zerofill来进行的.查询的时候,不足n位的数字全部用0填充. varchar(n)中的n代表的是字符的个数[一个汉字就代表一个],如果超过了就会报错. double(m,n)m代表的是总长度,n代表的是精度 例如double(7,2)最大可以插入的长度的例子是12345.67 1234567891011mysql&gt; show tables;mysql&gt; desc tables;-- 查看建表语句mysql&gt; show create table tbl_product CREATE TABLE `tbl_product` ( `id` int(7) DEFAULT NULL, `name` varchar(20) DEFAULT NULL, `create_time` date DEFAULT NULL, `price` double(3,2) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 删除表在不考虑外键因素的情况下,是可以直接删除表的. 1DROP TABLE 表名; 约束constraint作用:在插入到表中列的数据进行进一步的限制 约束类型 主键约束[primary key] - 非空且唯一,用来确定唯一的行记录 – pk 非空约束[not null] - 非空 - 该列不能为null,比如插入值或给定一个默认值 - nn 唯一约束[unique] - 唯一性 - nq 外键约束[foreign key] - 表与表之间的关系是通过外键来维护的,外键列一般是对应某张表的主键列,可以为null - fk 列级添加优点:比较简单,缺点:不能给约束取名字 语法: 1234567CREATE TABLE 表名(列名 数据类型[(长度)] [约束类型1],列2 数据类型[(长度)] [约束类型2],......列 数据类型[(n)])ENGINE=InnoDB DEFAULT CHARSET=utf8; 12345678drop table tbl_product;create table tbl_product( id int(7) primary key comment &#x27;产品的id&#x27;, name varchar(20) not null unique comment &#x27;产品的名称&#x27;, create_date date not null default &#x27;2021-7-20&#x27;, price double(7,2) not null);-- 注意类型为date的时候默认值不能为now();类型为datetime才可以为now() 演示约束 1234567891011121314151617181920212223insert into tbl_product(id,name,price) values(1,&#x27;tom&#x27;,123.567);mysql&gt; select * from tbl_product;+----+------+-------------+--------+| id | name | create_date | price |+----+------+-------------+--------+| 1 | tom | 2019-01-01 | 123.57 |+----+------+-------------+--------+-- 继续插入一个id也是1的值insert into tbl_product(id,name,price) values(1,&#x27;admin&#x27;,123.567);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;-- 违背了primary key主键约束的规则 - 重复了.-- not null-- 没有给price插入值,但是该列存在一个not null非空约束insert into tbl_product(id,name) values (2,&#x27;tom&#x27;);-- ERROR 1364 (HY000): Field &#x27;price&#x27; doesn&#x27;t have a default value-- unique 唯一性,表中已经存在了一行记录是tominsert into tbl_product(id,name,price) values(2,&#x27;tom&#x27;,12.3);-- name字段/列值重复了.ERROR 1062 (23000): Duplicate entry &#x27;tom&#x27; for key &#x27;name&#x27; 表级添加优点:可以给约束命名,列级是不支持给列取名称的. 但not null 非空约束以及default仅仅支持列级添加的方式 语法 1[constraint 约束名称] 约束类型(列) 123456789drop table tbl_product;create table tbl_product( id int(7), name varchar(20) not null, create_date date not null default &#x27;2019-1-1&#x27;, price double(7,2) not null, constraint tbl_product_id_pk primary key(id), unique(name)); 外键约束foreign key - 简称fk.用来确定表之间的关系的.外键通常是是在多的一方. 1.1:N或1:1 123456789101112131415161718192021222324252627282930drop table tbl_user;create table tbl_user( id int(7) primary key, username varchar(20) not null unique);insert into tbl_user values(1,&#x27;tom&#x27;);insert into tbl_user values(2,&#x27;admin&#x27;);drop table tbl_video;create table tbl_video( id int(7) primary key, title varchar(20), likes int(7), create_time datetime default now(), tbl_user_id int(7) references tbl_user(id));-- 一旦创建了约束,插入数据的时候需要注意的是.-- 外键列是允许为空的.insert into tbl_video values(1,&#x27;学好myql&#x27;,100,now(),1);insert into tbl_video values(2,&#x27;学好java&#x27;,100,now(),1);insert into tbl_video values(3,&#x27;学习jdbc&#x27;,100,now(),2);-- 注意.既然已经定义了外键的约束.那么插入数据的时候,引用的外键列的值在另外一张表中一定要有行记录的-- tbl_user表中是不存在id=3的行记录的insert into tbl_video values(3,&#x27;mysql太简单了&#x27;,100,now(),3);-- 报错ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`j03s`.`tbl_video`, CONSTRAINT `tbl_video_table_user_id_fk` FOREIGN KEY (`tbl_user_id`) REFERENCES `tbl_user` (`id`)) 2.N:N 123456789101112131415161718192021222324252627-- 评论表 一个用户可以对多个视频进行评论,一个视频可以被多个用户进行评论-- 拆分成两个1:N-- 组合主键+外键约束(表级添加)drop table tbl_comment;create table tbl_comment( user_id int(7), video_id int(7), content varchar(50), comment_id int(7), constraint tbl_comment_user_id_pk primary key(user_id,video_id), constraint tbl_comment_user_id_fk foreign key(user_id) references tbl_user(id), constraint tbl_comment_video_id_fk foreign key(video_id) references tbl_video(id)); -- 评论表拥有独立的主键id + 外键约束(列级添加)drop table tbl_comment;create table tbl_comment( id int(7) primary key, user_id int(7) references tbl_user(id), video_id int(7) references tbl_user(id), content varchar(50), comment_id int(7) references tbl_comment(comment_id));insert into tbl_comment(id,user_id,video_id,content) values(1,1,1,&#x27;好的,我会学会mysql的&#x27;);insert into tbl_comment values(2,2,1,&#x27;好的,我会学会mysql的&#x27;,1); 建议还是使用constraint,不然有错误都不知道. 建表补充由一张表来构建另一张表 保留原表的表结构+数据 1create table 表名 select 语句; 12345drop table video_copy;create table video_copy select * from tbl_video;drop table video_copy;create table video_copy select id,tilte from tbl_video; 保留原表的表结构,但是不需要原表的数据 12drop table video_copy;create table video_copy select id,title from tbl_video where 1=2; DMLinsert 插入数据 delete 删除数据 update 更新数据 插入语句 语法一:给表中所有的列添加数据 插入的列值要和建表语句中列顺序以及列的类型以及列的约束高度保持一致. 1INSERT INTO 表名 VALUES(列值1,列值2,列值3,..,列值N) 语法二:给表中的指定列插入数据 1INSERT INTO 表名(列名1,列名2) VALUES(列值1,列值2); insert into 表名 select 语句 把查询结果的数据插入到该表中 1234567-- 统计视频的被评论的用户量,并且保存到另外一张表中 video_id,comment_numdrop table comment_aly;create table comment_aly( video_id int(7), comment_num int(7));insert into comment_aly select video_id,count(user_id) from tbl_comment group by video_id; auto_incrementmysql中的主键的生成策略 - 自增长策略 - auto_increment[默认的是从1开始,步长为1] oracle中的主键的生成策略 - 自增长 - sequence 应用场景:以后插入的时候[除非是模拟数据],id肯定是后台自动生成 - 唯一性. 1234567drop table comment_aly;create table comment_aly( id int(7) primary key auto_increment, video_id int(7), comment_num int(7));insert into comment_aly(video_id,comment_num) select video_id,count(user_id) from tbl_comment group by video_id; mysql中提供了一个函数last_insert() 查看最后一个id插入的数据 1mysql&gt; select last_insert_id(); 希望模拟数据的时候接着使用这个自增长,那么修改自增长的初始值 12mysql&gt; alter table comment_aly auto_increment=8;insert into comment_aly(video_id,comment_num) values(1,3); 删除语句 清空表 - delete语句不带where 123delete from 表名;delete from video_copy; 带条件的删除 - 删除1条,不删除,删除多条 1234delete from 表名 where语句;-- 删除video_copy表中id=2的行记录delete from video_copy where id=2; 更新语句 更新的整张表的数据 - 不带where语句 123456789101112语法:-- 更新所有的行的单列update 表名 set 列名=新的列值;-- 更新所有的行的多列.update 表名 set 列1=新的列值1,列2=新的列值2,列n=新的列值n;-- 比如更新video_copy表中的likesupdate video_copy set likes=likes*1.1;-- 比如更新video_copy表中的likes和titleupdate video_copy set likes=200,title=&#x27;java无敌&#x27;; 更新指定条件的行记录 - where语句 12更新id=2的titleupdate video_copy set title=&#x27;python不错&#x27; where id=2; 约束注意点 先删除多的一方表,再删除的一的一方的表 删除行记录的时候,需要先把这个行记录在其他表中被引用的行记录要全部删除之后,才能删除自己. 创建表的时候,应该先创建一的一方,然后创建多的一方 删除表123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 删除表不是随意删除的 - 前提是创建了外键约束-- 先删除多的一方表,再删除的一的一方的表drop table tbl_comment;drop table tbl_user;drop table tbl_video;-- 用户表create table tbl_user( id int(7) primary key, username varchar(20) not null unique);insert into tbl_user values(1,&#x27;tom&#x27;);insert into tbl_user values(2,&#x27;admin&#x27;);-- 视频表create table tbl_video( id int(7) primary key, title varchar(20), likes int(7), create_time datetime default now(), -- 外键列命名方式 表名_另外一张表的引用列名[主键列] -- 外键列的数据类型和长度和你引用的地方保持一致 tbl_user_id int(7), -- 表级添加 constraint tbl_video_table_user_id_fk foreign key(tbl_user_id) references tbl_user(id));-- 一旦创建了约束,插入数据的时候需要注意的是.-- 外键列是允许为空的.insert into tbl_video values(1,&#x27;学好myql&#x27;,100,now(),1);insert into tbl_video values(2,&#x27;学好java&#x27;,100,now(),1);insert into tbl_video values(3,&#x27;学习jdbc&#x27;,100,now(),2);-- 评论表create table tbl_comment( id int(7) primary key, user_id int(7), video_id int(7), content varchar(50), comment_id int(7), constraint tbl_comment_user_id_fk foreign key(user_id) references tbl_user(id), constraint tbl_comment_video_id_fk foreign key(video_id) references tbl_video(id), constraint tbl_comment_id_fk foreign key(comment_id) references tbl_comment(id));insert into tbl_comment(id,user_id,video_id,content) values(1,1,1,&#x27;好的,我会学会mysql的&#x27;);insert into tbl_comment values(2,2,1,&#x27;好的,我会学会mysql的&#x27;,1); 分析删除表的顺序 12345678910-- 如果删除的是tbl_user或者tbl_video都会报错-- 报错的原因就是由外键约束存在导致的mysql&gt; drop table tbl_user;ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint failsmysql&gt; drop table tbl_video;ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint fails-- 应该要先删除子记录[外键所在的表中的记录],然后再删除父记录 - 先删除多的一方表,再删除的一的一方的表-- 多的一方的外键引用的是一的一方的主键. 删除行记录1234567891011121314151617-- id=2的用户是在tbl_comment中存在一条行记录的,它是被引用了.mysql&gt; delete from tbl_user where id=2;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tbl_comment`, CONSTRAINT `tbl_comment_user_id_fk` FOREIGN KEY (`user_id`) REFERENCES `tbl_user` (`id`))-- id=2的所有的评论的全部删除[删除子记录],然后再去删除id=2的用户mysql&gt; delete from tbl_comment where user_id=2;-- 然后才能去删除id=2的用户,已经把用户id=2这个用户的所有的评论全部删除了mysql&gt; delete from tbl_user where id=2;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tbl_video`, CONSTRAINT `tbl_video_table_user_id_fk` FOREIGN KEY (`tbl_user_id`) REFERENCES `tbl_user` (`id`))id=2的用户又发布了一条视频,它也在tbl_video表中被引用了.mysql&gt; delete from tbl_video where tbl_user_id=2;-- 等把id=2的用户的所有评论信息以及发布的视频全部删除完毕之后,才可以删除自己mysql&gt; delete from tbl_user where id=2; 约束的缺点外键约束 - 保证数据的完整性和一致性.缺点 - 表之间的关系越强烈[手动创建了约束条件] - 表之间的耦合越高. 在下周DB设计 - 不要手动创建约束 - 弱化表之间的关系 - “表的关系 - 心中” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960驰星CRM系统 - 学生信息,项目经理信息-- 假设一个项目经理可以教多个学生-- dev_id是外键列student(id,sname,school,dev_id);1 杨晓轩 文正养老学院 22 闫昊 八一农垦 13 刘静 八一农垦 2dev(id,dev_name,age);1 success 182 james 453 小强 19如果建表的时候create table student( //...foreign key(dv_id) references dev(id););-- 导致的后果,不能随意删除项目经理.项目经理只要有学生信息.就不能删除项目经理.-- 现实生活中 - success上台了,james开除了...mysql&gt; delete from dev where id=2;//删除失败了.因为james在student表中有子记录-- 要想删除james,需要删除他所有的学生.实际的业务 - 肯定不允许我去删除&quot;宝贵的学生信息&quot;-- 目标 - 1. 成功删除项目经理-- 2. 知道学生曾经是哪个老师带过的.-- 因此,在建表的时候,其实是允许数据的冗余性的.drop table t_student;drop table dev;create table dev( id int(7) primary key auto_increment,dev_name varchar(20),age int(3));insert into dev values(1,&#x27;success&#x27;,18);insert into dev values(2,&#x27;james&#x27;,45);create table t_student( id int(7) primary key auto_increment,sname varchar(20),school varchar(20),-- 此处没有进行约束的添加 - &quot;关系在心中即可&quot;dev_id int(7),-- 数据的冗余 - 防止项目经理的记录被删除dev_name varchar(20));insert into t_student values(1,&#x27;杨晓轩&#x27;,&#x27;文正养老学院&#x27;,2,&#x27;james&#x27;);insert into t_student values(2,&#x27;闫昊&#x27;,&#x27;八一农垦&#x27;,1,&#x27;success&#x27;);insert into t_student values(3,&#x27;刘静&#x27;,&#x27;八一农垦&#x27;,1,&#x27;success&#x27;);-- 虽然没有给dev_id列创建约束,业务分析可以确定该列就是用来&quot;维护俩表之间的关系的&quot;-- 查询学生的姓名以及项目经理的姓名以及年龄mysql&gt; select s.sname,d.dev_name,d.age from t_student s join dev d on s.dev_id=d.id;-- 开除james,没有约束,可以直接删除mysql&gt; delete from dev where id=2; 物理删除和逻辑删除 物理删除就是真正意义上的delete语句 逻辑删除 - 建议 - 比较安全 因为数据是不能随意删除的.数据是需要后台进行数据分析的.用户的端的删除大部分都是逻辑删除. 实际上就是每张表都会增加逻辑列. 1234567891011121314drop table xx_del;create table xx_del( id int(7) primary key, name varchar(20), status int(7));insert into xx_del values(1,&#x27;tom&#x27;,0);insert into xx_del values(2,&#x27;admin&#x27;,1);-- 首页 - 加载xx_del表中所有的信息 [加载status=1的信息]select * from xx_del where status = 1;-- 删除按钮 - 逻辑删除 - 执行updateupdate xx_del set status=0 where id=1;","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://beautifulboyy/tags/DDL/"},{"name":"DML","slug":"DML","permalink":"http://beautifulboyy/tags/DML/"}]},{"title":"mysql基础","slug":"mysql01","date":"2021-08-16T01:14:08.000Z","updated":"2021-08-20T06:26:41.324Z","comments":true,"path":"2021/08/16/mysql01/","link":"","permalink":"http://beautifulboyy/2021/08/16/mysql01/","excerpt":"","text":"数据库数据库Database - 简称DB 数据按照一定的数据结构来进行组织,存储和管理的仓库. 学习的数据库mysql - 目前最主流的关系型数据库[免费的.现在属于oracle公司的] 安装的版本&gt;=5.7.x -&gt; 发展[mysql5.5.x,mysql5.6.x,mysql.5.7.x,mysql8.x] - 版本不一样,语法存在差异. SQLSQL - Structured Query Language - 结构化查询语言 作用: 脚本文件 - 以.sql为脚本的文件 我们本质上就是通过sql语法/命令来操作我们的DB 功能分类 DQL(Data Query Language) - 数据查询语言 - sql的核心 select DML(Data Manipulation Language) - 数据操纵语言 insert update delete DDL(Data definition Language) - 数据定义语言 create alter drop DCL(Data Control Language) - 数据控制语言 grant[授权] revoke[取消授权] DTL(Data Transaction Language) - 数据事务语言 commit savepoint rollback 脚本文件mysql中的script文件是以.sql为后缀的文件. mysql - 数据库 - 由若干张表组成的仓库,数据是存储在一张二维表[关系]中的. 如果一个数据库存储数据的格式是一个行和列组成表 - 关系[表格]型数据库 生成若干张表 表中插入若干条数据. 准备工作登录mysql 1mysql -uroot -p123456 操作仓库新建仓库MYSQL就是通过仓库的形式来管理我们的数据的. 语法:CREATE DATABASE 仓库名; sql的语法大小写是不敏感的. 12ysql&gt; create database j03s;Query OK, 1 row affected (0.00 sec) 查看所有的仓库12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || j03s || mysql || performance_schema || sys |+--------------------+ 使用仓库1mysql&gt; use j03s; 查看所有的表1mysql&gt; show tables; 导入脚本12mysql&gt; source sql脚本文件的绝对路径;mysql&gt; source /Users/admin/Desktop/j03s_mysql_all/教学脚本/mysql_cn.sql; 该脚本文件中的表 123456789+----------------+| Tables_in_j03s |+----------------+| s_customer || s_dept || s_emp || s_ord || s_region |+----------------+ 继续导入 - 面试中常常使用到的一个脚本 12345678+----------------+| Tables_in_j03s |+----------------+| course || sc || student || teacher |+----------------+ 确认数据的编码建议修改编码之后,建议重启mysql服务 右击计算机 - 管理 - 服务 - 服务和应用程序 - 右边的窗口 - mysql - 右击重启 1mysql&gt; show variables like &#x27;char%&#x27;; 123456789101112+--------------------------+-----------------------------------------------------------+| Variable_name | Value |+--------------------------+-----------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.7.28-macos10.14-x86_64/share/charsets/ |+--------------------------+-----------------------------------------------------------+ 需要对每一项进行单独的设置 1mysql&gt;set character_set_client=utf8; mysql插入中文乱码 检测上面的编码 my.ini文件在哪里 1234567[client]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8 本身自己的cmd的编码 如果还有问题,卸载重来. 查询简单查询属于DQL命令 - select命令 query语法 查询的本质 查什么 到哪里查[必须先使用数据库,然后才能查看这个库下的表] 1234-- 查询整张表的某些列SELECT 列1,列2,列n FROM 表名;-- 查询整张表中的所有列,*代表所有的列SELECT * FROM 表名; 查询表结构1234567891011desc 表名;mysql&gt; desc student;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(10) | YES | | NULL | || sname | varchar(10) | YES | | NULL | || age | datetime | YES | | NULL | || sex | varchar(10) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+ 查询练习 查询student表中的姓名sname 1234567891011121314151617181920212223242526 select sname from student;2. 查询student表中的学生信息 ~~~mysql select * from student;3. 查询s_emp员工表中的first_name和last_name ~~~mysql select first_name,last_name from s_emp;4. 查询客户[s_customer]的姓名以及客户的电话号码 ~~~mysql select name,phone from s_customer;5. 查询s_emp中的title列 ~~~mysql select title from s_emp;6. 排重关键字distinct 列名 ~~~mysql select distinct title from s_emp; 条件查询query-conditional语法 如果查询语句后面不加where条件,查询的是整张表中的数据 需要对数据进行筛选,需要使用条件查询 语法 1234-- 查询满足条件表达式的数据SELECT 列1,列2,列nFROM 表名WHERE 条件表达式; 运算符 比较运算符 =,&gt;,&lt;,&gt;=,&lt;=,!= 其他运算符 2-1. in(集合列表) 2-2. not in(集合列表) 2-3. between … and … 在 … 和 …区间 - 是一个闭区间 is null - 判断某列是否为空,注意判断是否为空,不能使用= is not null - 判断某列是否不为空,不能使用!= 逻辑运算符 not and - 用来连接多个条件的,多个条件同时为true,才能返回结果 or - 用来连接多个条件的,只要有一个条件成立,就会返回结果. 条件查询练习 查询工资高于1200的员工的信息[id,first_name,salary] 1select id,first_name,salary from s_emp where salary &gt; 1200; 把部门编号为41,42,43的员工信息查询出来 12345678910111213141516 select id,first_name,dept_id from s_emp where dept_id in(41,42,43);3. 查询工资在1200~1450之间的员工的信息 ~~~mysql select id,first_name,salary from s_emp where salary between 1200 and 1450;4. 查询title[职称]为Stock Clerk的员工信息 ~~~mysql select id,first_name,title from s_emp where title = &#x27;Stock Clerk&#x27;;5. 查询有提成[commission_pct]的员工信息 ~~~mysql select id,first_name,commission_pct from s_emp where commission_pct is not null; 列别名和列的计算 可以给列重新命名 1234567891011121314-- 语法一:列1 列别名1 - 推荐使用的语法mysql&gt; SELECT 列1 列别名1,列2 列别名2 FROM 表名 [WHERE条件查询];mysql&gt; select id 编号,first_name 名字,salary 工资 from s_emp;-- 语法二: 列1 as 列别名1 - 不推荐使用mysql&gt;select id as 编号,first_name as 名字,salary as 工资 from s_emp;-- 语法三: mysql中可以使用双引号来保持/包裹格式-- 列1 &quot;列别名1&quot;mysql&gt; select id &quot;编号&quot;,first_name &quot;名字&quot;,salary &quot;工资&quot; from s_emp;-- 需求:希望列别名每个汉字间距一点[空一格]mysql&gt; select id &quot;编 号&quot;,first_name &quot;名 字&quot;,salary &quot;工 资&quot; from s_emp; mysql中的列支付计算 12-- 查询员工的年薪mysql&gt; select first_name,salary*12 年薪 from s_emp; 练习:查询员工的年薪,但是要包括提成 在mysql中null值直接进行计算,结果还是null值*,因此一般需要对null值进行处理,如果是数字列为null.需要作为0来进行处理 mysql中内置了很多函数 - 空值置换函数 - coalesce(m,n) 计算规则类似于java中的三元操作符m==null?n:m 1select id,first_name,salary*12*(1+coalesce(commission_pct,0)/100) 年薪 from s_emp; 模糊查询使用like关键字 % - 占位符 - 代表任意多个任意字符 _ 占位符 - 代表任意单个任意字符 模糊查询练习 比如查询teacher表中所有的李姓老师 1select * from teacher where tname like &#x27;李%&#x27;; 比如查询first_name第三个字母是e的员工信息 123456 select id,first_name from s_emp where first_name like &#x27;__e%&#x27;;3. 查询职称title中包含VP的并且工资高于1200的员工信息 ~~~mysql select id,first_name,title,salary from s_emp where title like &#x27;%VP%&#x27; and salary&gt;1200; 查询first_name以M开头的员工信息 1select id,first_name from s_emp where first_name like &#x27;M%&#x27;; 查询first_name中不包含字母n的员工信息 1select id,first_name from s_emp where first_name not like &#x27;%n%&#x27;; 找出非41,42,43部门的员工 1select id,first_name,dept_id from s_emp where dept_id not in(41,42,43); 转义字符了解即可 12mysql&gt; update s_emp set first_name=&#x27;Car_men&#x27; where id=1;mysql&gt; update s_emp set first_name=&#x27;Ma_rk&#x27; where id=4; 需求 - 查询first_name中包含_的员工信息 1234567mysql&gt; select first_name from s_emp where first_name like &#x27;%_%&#x27;;默认的转义字符mysql&gt; select first_name from s_emp where first_name like &#x27;%\\_%&#x27;;自定义转义字符mysql&gt; select first_name from s_emp where first_name like &#x27;%?_%&#x27; escape &#x27;?&#x27;; 列的拼接功能s_emp表中first_name[名]和last_name[姓] db设计满足三大范式.第一范式保证列的原子性 - 列不可再分割. 姓名 -姓一列+名一列 12-- 拼接的过程也使用到了内置函数concat(...) - 可变长列表mysql&gt; select concat(last_name,&#x27; &#x27;,first_name) 姓名 from s_emp; 排序12345-- 排序的语法SELECT 列1,列2,列nFROM 表名[WHERE 条件表达式][ORDER BY 列名] [asc | desc]; 练习 查看员工的信息,找出工资大于1200的,并且根据salary来升序 123456-- order by + 列名select id,first_name,salary from s_emp where salary&gt;1200 order by salary desc;-- order by + 列的序号 列的序号是查询语句中的列的序号,列的序号是从1开始的[推荐使用]select id,first_name,salary from s_emp where salary&gt;1200 order by 3 desc;-- order by + 列别名select id,first_name,salary _sal from s_emp where salary&gt;1200 order by _sal desc; 查看员工的信息,找出工资大于1200的,并且根据salary来降序.如果salary一样,那么继续根据first_name来进行一个升序. 1select first_name,salary from s_emp where salary&gt;1200 order by 2 desc,1; 找出年薪高于21000的员工的信息[包括提成的],并且根据年薪降序排. 1select first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp where salary*12*(1+coalesce(commission_pct,0)/100)&gt;21000 order by 2 desc; 利用子查询求解 1select * from (select id,first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp) temp where year_salary&gt;21000 order by 3 desc; 高级查询多表查询,表和表之间的关系 - 通过外键列来维护的. RDBMS专业术语 主键列 外键列 - 确定好外键列是进行多表查询的前提,通常外键列是交给多的一方进行维护的 关联查询传统的写法 错误的写法 - 笛卡尔积 123456789-- 查询员工(s_emp)的id,first_name以及这个员工所在的部门(s_dept)的id以及部门的名称mysql&gt; select id,first_name,id,name from s_emp,s_dept;ERROR 1052 (23000): Column &#x27;id&#x27; in field list is ambiguous如果查询的结果中出现多个表中同名的列,请你给表取别名,通过表别名.列名mysql&gt; select e.id,e.first_name,d.id,d.name from s_emp e,s_dept as d;总共出现了300条 = 25 * 12 进行筛选 - 去除错误的笛卡尔积 1mysql&gt; select e.id,e.first_name,d.id,d.name from s_emp e,s_dept as d where e.dept_id = d.id; 练习 3-1. 找出外键列 3-2. 去除笛卡尔积 12345-- 找出区域在&#x27;Asia&#x27;的所有的员工信息mysql&gt; select e.first_name,r.name from s_emp e,s_dept d,s_region r where r.name=&#x27;Asia&#x27; and r.id = d.region_id and e.dept_id=d.id;-- 缺点 - 如果表的数量一旦增多,发现哪些表和哪些之间是否有直接的关系.我们体验不会太好 查看学生的姓名,课程的名字,以及该课程授课的老师的名字以及该学生在这门课的得分情况 student,course,teacher,sc 1mysql&gt;select s.sname,c.cname,t.tname,_sc.score from student s,course c,teacher t,sc _sc where _sc.sid = s.id and _sc.cid = c.id and c.tid = t.id; join + on写法表 join 表 on 一的一方的主键 = 多的一方的外键. on的目的不是为了进行条件筛选 - 目的去除笛卡尔积 只要具有直接关系的俩张表才能够使用join进行连接 内连接 - 默认的inner join,但是inner可以省略不写 练习 查询部门id为31的部门名称以及该部门下的员工的名字和薪水 1select e.first_name,e.salary,d.name from s_emp e join s_dept d on d.id = e.dept_id; 找出区域在’Asia’的所有的员工信息 12345678910111213141516 select e.id,e.first_name,e.dept_id,d.name,r.name from s_emp e join s_dept d on e.dept_id = d.id join s_region r on d.region_id = r.id;3. 李老师的授课情况信息,包括教的学生的姓名,课程的名字,以及该课程授课的老师的名字以及该学生在这门课的得分情况 ~~~mysql select s.sname,c.cname,t.tname,sc.score from sc join student s on sc.sid = s.id join course c on c.id = sc.cid join teacher t on t.id = c.tid where t.tname like &#x27;李%&#x27;;4. 查看顾客的id,姓名以及该顾客拥有的订单信息[订单所有列] ~~~mysql select c.id,c.name,o.* from s_customer c join s_ord o on o.customer_id = c.id;5. 查看所有区域,以及这个区域上的部门信息 ~~~mysql select * from s_dept d join s_region r on d.region_id = r.id; 左连接和右连接 内连接 - inner join 查看顾客的id,姓名以及该顾客拥有的订单id - 拥有订单的客户才能够被查询出来 - inner join 12345678910111213141516171819202122232425262728mysql&gt;select c.id,c.name,o.id oid from s_customer c inner join s_ord o on c.id = o.customer_id;-- 总共查询得到16条数据-- inner join - 结果中少掉了207和215俩个客户 - 因为查看订单表s_ord,发现这俩个人就没有订单信息-- inner join - 内连接的写法,A表 join B表 - 如果A表中的记录在B表中不存在.那么关联查询之后.这个在B表中不存在的A表中的-- 这个记录也同样不会被关联查询出来.mysql&gt; select c.id,c.name,o.id oid from s_customer c inner join s_ord o on c.id = o.customer_id;+-----+----------------------------+-----+| id | name | oid |+-----+----------------------------+-----+| 201 | Unisports | 97 || 202 | OJ Atheletics | 98 || 203 | Delhi Sports | 99 || 204 | Womansport | 100 || 205 | Kam&#x27;s Sporting Goods | 101 || 206 | Sportique | 102 || 208 | Muench Sports | 103 || 208 | Muench Sports | 104 || 209 | Beisbol Si! | 105 || 210 | Futbol Sonora | 106 || 211 | Kuhn&#x27;s Sports | 107 || 212 | Hamada Sport | 108 || 213 | Big John&#x27;s Sports Emporium | 109 || 214 | Ojibway Retail | 110 || 204 | Womansport | 111 || 210 | Futbol Sonora | 112 |+-----+----------------------------+-----+16 rows in set (0.00 sec) 分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344mysql&gt; select c.id,c.name from s_customer c;+-----+----------------------------+| id | name |+-----+----------------------------+| 201 | Unisports || 202 | OJ Atheletics || 203 | Delhi Sports || 204 | Womansport || 205 | Kam&#x27;s Sporting Goods || 206 | Sportique || 207 | Sweet Rock Sports || 208 | Muench Sports || 209 | Beisbol Si! || 210 | Futbol Sonora || 211 | Kuhn&#x27;s Sports || 212 | Hamada Sport || 213 | Big John&#x27;s Sports Emporium || 214 | Ojibway Retail || 215 | Sporta Russia |+-----+----------------------------+15 rows in set (0.00 sec)mysql&gt; select o.id,o.customer_id from s_ord o;+-----+-------------+| id | customer_id |+-----+-------------+| 97 | 201 || 98 | 202 || 99 | 203 || 100 | 204 || 101 | 205 || 102 | 206 || 103 | 208 || 104 | 208 || 105 | 209 || 106 | 210 || 107 | 211 || 108 | 212 || 109 | 213 || 110 | 214 || 111 | 204 || 112 | 210 |+-----+-------------+16 rows in set (0.00 sec) 左连接 - left join A表 join B表 - 以left join左边的表为基准表.右边的表非基准表.如果基准表中的记录在非基准表不存在.但是也能够查询出来. 如果这个客户没有订单信息,那么也要将这个客户的信息查询出来 12345678910111213141516171819202122232425mysql&gt; select c.id,c.name,o.id oid from s_customer c left join s_ord o on c.id = o.customer_id;+-----+----------------------------+------+| id | name | oid |+-----+----------------------------+------+| 201 | Unisports | 97 || 202 | OJ Atheletics | 98 || 203 | Delhi Sports | 99 || 204 | Womansport | 100 || 205 | Kam&#x27;s Sporting Goods | 101 || 206 | Sportique | 102 || 208 | Muench Sports | 103 || 208 | Muench Sports | 104 || 209 | Beisbol Si! | 105 || 210 | Futbol Sonora | 106 || 211 | Kuhn&#x27;s Sports | 107 || 212 | Hamada Sport | 108 || 213 | Big John&#x27;s Sports Emporium | 109 || 214 | Ojibway Retail | 110 || 204 | Womansport | 111 || 210 | Futbol Sonora | 112 || 207 | Sweet Rock Sports | NULL || 215 | Sporta Russia | NULL |+-----+----------------------------+------+18 rows in set (0.00 sec) 右连接 - right join A表 join B表 - 以right join右边的表为基准表.左边的表非基准表.如果基准表中的记录在非基准表不存在.但是也能够查询出来. 1select c.id,c.name,o.id oid from s_ord o right join s_customer c on c.id = o.customer_id; 自关联 - 自己关联自己 – 员工s_emp表中的manager_id - 上司的id -&gt; 绑定的就是s_emp表中的id 12345678910111213141516171819202122232425262728293031mysql&gt; select id,first_name,manager_id from s_emp;+----+------------+------------+| id | first_name | manager_id |+----+------------+------------+| 1 | Car_men | NULL || 2 | LaDoris | 1 || 3 | Midori | 1 || 4 | Ma_rk | 1 || 5 | Audry | 1 || 6 | Molly | 2 || 7 | Roberta | 2 || 8 | Ben | 2 || 9 | Antoinette | 2 || 10 | Marta | 2 || 11 | Colin | 3 || 12 | Henry | 3 || 13 | Yasmin | 3 || 14 | Mai | 3 || 15 | Andre | 3 || 16 | Elena | 6 || 17 | George | 6 || 18 | Akira | 7 || 19 | Vikram | 7 || 20 | Chad | 8 || 21 | Alexander | 8 || 22 | Eddie | 9 || 23 | Radha | 9 || 24 | Bela | 10 || 25 | Sylvie | 10 |+----+------------+------------+25 rows in set (0.00 sec) 练习 123-- 查询员工的名字,以及这个员工的上司的名字 - 一个上司拥有多个下属的.-- 效果:这个员工没有上司,也要能够查询出来.mysql&gt; select e1.first_name 员工名字,e2.first_name 上司 from s_emp e1 left join s_emp e2 on e2.id = e1.manager_id 分组查询语法 123456SELECT 语句FROM 表WHERE 语句GROUP BY 语句[HAVING 组函数判断]ORDER BY 语句 多行函数 count函数 - 统计个数 1234567891011121314-- 统计s_emp的员工的个数mysql&gt; select count(*) from s_emp;-- 除了可以写*,那么还可以推荐写idmysql&gt; select count(e.id) from s_emp e;-- 重复的数据也算1个mysql&gt; select count(title) from s_emp;-- 统计职称,重复的数据,只要统计一次mysql&gt; select count(distinct title) from s_emp;-- 如果遇到null值,忽略null值的统计mysql&gt; select count(commission_pct) from s_emp; avg,sum,min,max - 忽略null值 12-- 统计学生的得分情况mysql&gt;select avg(score),sum(score),min(score),max(score) from sc; group by 统计各个部门编号,以及整个部门的员工数量 1mysql&gt; select dept_id,ount(*) from s_emp group by dept_id; 统计部门人数大于等于3的部门的编号以及人数信息 1mysql&gt; select dept_id,count(*) from s_emp group by dept_id having count(*)&gt;=3; 统计部门[41,42,42]人数大于等于4的部门的编号以及人数信息 1mysql&gt; select dept_id,count(*) from s_emp where dept_id in(41,42,43) group by dept_id having count(*)&gt;=4; 统计部门[41,42,43]人数大于等于3的部门的编号以及人数信息,并且根据部门编号降序排列 1mysql&gt; select dept_id,count(*) from s_emp where dept_id in(41,42,43) group by dept_id having count(*)&gt;=3 order by 1 desc; 分组练习 经常分组统计 - 分组+统计.也是可以只进行分组的动作. 12345-- 统计每个职称的人数 - 分组+统计了mysql&gt; select title,count(id) from s_emp group by title;-- 只是分组 - 除了可以使用distinct来去重.那么我们也可以直接使用分组进行去重.mysql&gt; select title from s_emp group by title; 统计部门的名称,编号以及该部门上的员工的数量 1234567891011mysql&gt; select d.id,d.name,count(e.id) from s_emp e join s_dept d on e.dept_id = d.id group by d.id,d.name;-- 注意点,写group by 容易发生错误的地方.-- mysql5.7以后对group by的写法要求变得高了.推荐.-- 如果select后面除了存在组函数以外,还存在其他列.那么group by后面的列一定要和select后面的列高度保持一致.-- 1. select 列1,列2,组函数 from 表 group by 列1,列2-- 但是如果select后面只有组函数select count(e.id) from s_emp e join s_dept d on e.dept_id = d.id group by d.id; 统计每个客户的订单数量[超过1的统计出来],没有订单的客户也要能够统计出来 1mysql&gt; select c.id,c.name,count(o.id) from s_customer c left join s_ord o on c.id = o.customer_id group by c.id,c.name having count(o.id)&gt;1; 统计每个区域的部门的数量 1mysql&gt; select r.id,r.name,count(d.id) from s_region r join s_dept d on r.id = d.region_id group by r.id,r.name; 统计每个区域上的员工的数量 12mysql&gt;select r.name,r.id,count(e.id) from s_region r join s_dept d on r.id = d.region_id join s_emp eon e.dept_id = d.id group by r.name,r.id; 统计每个学生的课程的总分,平均分 12345mysql&gt; select v.sid,sum(v.score),avg(v.score) from sc v group by v.sid;-- 统计每个学生的id,姓名以及他的课程的总分,平均分mysql&gt; select s.id,s.sname,sum(v.score),avg(v.score) from student s left join sc v on s.id = v.sidgroup by s.id,s.sname; 统计每个老师授课的课程的数量 1mysql&gt; select t.id,t.tname,count(c.id) from teacher t join course c on t.id = c.tid group by t.id,t.tname; 统计每个课程的最低分,最高分,平均分 12mysql&gt; select c.id,c.cname,min(v.score),max(v.score),avg(v.score) from course c join sc v on c.id = v.cid group by c.id,c.cname; 统计李老师的学生数量 1234mysql&gt; select t.id,t.tname,count(v.sid) from teacher t join course c on t.id = c.tidjoin sc v on v.cid = c.id where t.tname like &#x27;李%&#x27;group by t.id,t.tname; 子查询子查询是效率不如关联查询.但是子查询更加灵活.能用关联查询解决的查询,肯定也是可以通过子查询去解决. 但是子查询可以解决关联查询解决的查询.使用原则优先使用关联查询. 注意点:子查询必须要使用()括号 三个维度 子查询作为外部查询的列. 子查询作为外部查询的where语句中 子查询可以看做是一张”虚拟表/临时表”,可以对这个”虚拟表”再次进行查询. 子查询作为外部查询的where语句中12345678910-- 查询和&#x27;Ben&#x27;在同一个部门的员工first_name,dept_id;-- 分解 - 找出&#x27;Ben&#x27;的部门idmysql&gt; select dept_id from s_emp where first_name=&#x27;Ben&#x27;;//43-- 找出43部门的所有的员工,但是不包含Benmysql&gt; select first_name,dept_id from s_emp where first_name!=&#x27;Ben&#x27; and dept_id=43;-- 整合到一块儿mysql&gt; select first_name,dept_id from s_emp where first_name!=&#x27;Ben&#x27; and dept_id=(select dept_id from s_emp where first_name=&#x27;Ben&#x27;); 子查询作为外部查询的列123456-- 查询客户的id,客户的姓名,以及该客户的订单个数mysql&gt; select c.id,c.name,(select count(o.customer_id) from s_ord o where c.id=o.customer_id) 订单数量from s_customer c;-- 查询部门的id,部门的名称,以及这个部门上的员工的个数mysql&gt; select d.id,d.name,(select count(e.id) from s_emp e where e.dept_id = d.id) 员工数 from s_dept d; 子查询可以看做是一张”虚拟表/临时表”,可以对这个”虚拟表”再次进行查询12345678910111213141516171819202122-- 用子查询来实现 - 查询和&#x27;Ben&#x27;在同一个部门的员工first_name,dept_id-- (select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27;)结果必须返回单个值mysql&gt; select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27;) from s_emp e;和下面的这个效果是一样的mysql&gt; select e.first_name,e.dept_id from s_emp e;-- 修改-- 思路 e.first_name,子查询e.dept_id - 判断成立 - 有值,否则为null-- e.dept_id是否和&#x27;Ben&#x27;是一个部门的.select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27; and e.dept_id=e1.dept_id) didfrom s_emp e;-- 把上面的查询的结果作为&quot;虚拟表&quot; - 别名 - core_select * from ( select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27; and e.dept_id=e1.dept_id) did from s_emp e) core_ where core_.did is not null and core_.first_name&lt;&gt;&#x27;Ben&#x27;; exists和not exists用法 exists - 是否存在.只要存在,那么就返回true - 顺利被查询出来 not exists - 不存在 如果是false,反而会被顺利查询出来 案例 1234-- exists(子查询 - 如果有结果,返回true,否则返回false)mysql&gt;select first_name from s_emp where exists(select 1 from s_emp where 1=1);mysql&gt;select first_name from s_emp where not exists(select 1 from s_emp where 1=2); 练习 查询和’Ben’在同一个部门的员工first_name,dept_id 1select e1.first_name,e1.dept_id from s_emp e1 where exists (select 1 from s_emp e2 where e1.dept_id = e2.dept_id and e2.first_name = &#x27;Ben&#x27;) and e1.first_name&lt;&gt;&#x27;Ben&#x27;; 找出各个部门工资排名前二的员工 “e-我”这个部门中,如果还有人工资比我高.那么这个数量不能超过1个. 1select e1.first_name,e1.salary,e1.dept_id from s_emp e1 where exists(select 1 from s_emp e2 where e1.dept_id = e2.dept_id and e2.salary&gt;e1.salary having count(*)&lt;=1) order by 3; not exists来实现的 12345不存在&#x27;我e&#x27;这个部门中,有人的工资比我高.并且这个数量超过1个.mysql&gt; select e.dept_id,e.first_name,e.salary from s_emp e where not exists( select 1 from s_emp e1 where e.dept_id = e1.dept_id and e1.salary&gt;e.salary having count(*)&gt;1) order by 1; 找出各个部门中工资最高的 1select e1.first_name,e1.salary,e1.dept_id from s_emp e1 where exists(select 1 from s_emp e2 where e1.dept_id = e2.dept_id and e2.salary &gt; e1.salary having count(*) &lt; 1) order by 3; 这块不是特别懂!!!要多做做题 mysql函数字符串函数 instr(str,substr) - 返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0) mysql下标索引从1开始的 1mysql&gt;select instr(&#x27;ppopo&#x27;,&#x27;o&#x27;);//3,找不到则返回0 lpad(str,len,padstr) - 用字符串padstr填补str左端直到字串长度为len并返回 1mysql&gt; select lpad(&#x27;parttime&#x27;,22,&#x27;nice&#x27;);//niceniceniceniparttime rpad(str,len,padstr) - 用字符串padstr填补str右端直到字串长度为len并返回 1mysql&gt;select rpad(&#x27;abc&#x27;,6,&#x27;do&#x27;);//abcdod left(str,len) - 返回字符串str的左端len个字符 1mysql&gt; select left(&#x27;sakurayo&#x27;,2);//sa right(str,len) - 返回字符串str的右端len个字符 1mysql&gt; select right(&#x27;sakurayo&#x27;,2);//yo substring(str,pos,len) - 返回字符串str的位置pos起len个字符 1mysql&gt; select substring(&#x27;sakura&#x27;,3,2);//ku substring(str,pos) - 返回字符串str的位置pos起后面的子串 1mysql&gt; select substring(&#x27;sakura&#x27;,3);//kura ltrim(str) - 返回删除了左空格的字符串str 1mysql&gt; select ltrim(&#x27; qq &#x27;); //qq rtrim(str) - 返回删除了右空格的字符串str 1mysql&gt; select rtrim(&#x27; qq &#x27;);// qq space(n) - 返回由n个空格字符组成的一个字符串 1mysql&gt; select space(4); replace(str,from_str,to_str) - 用字符串to_str替换字符串str中的子串from_str并返回 1mysql&gt; select replace(&#x27;skura&#x27;,&#x27;ku&#x27;,&#x27;sasasa&#x27;);//ssasasara reverse(str) - 颠倒字符串str的字符顺序并返回 1mysql&gt; select reverse(&#x27;sakura&#x27;);//arukas insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串 12mysql&gt; select insert(&#x27;Carmen&#x27;,2,5,&#x27;*****&#x27;);//C*****mysql&gt; select insert(&#x27;Carmen&#x27;,3,2,&#x27;*&#x27;); //Ca*en lower(str) - 返回小写的字符串str 1mysql&gt; select lower(&#x27;AbcD&#x27;);//abcd upper(str) - 返回大写的字符串str 1mysql&gt; select upper(&#x27;abCd&#x27;);//ABCD char_length(str) - 不管汉字还是数字或者是字母都算是一个字符。 12mysql&gt; select char_length(&#x27;sqwe&#x27;);//4mysql&gt; select char_length(&#x27;s我e&#x27;);//3 length(str);//汉字占3个,其他占1个. 12mysql&gt; select length(&#x27;sqwe&#x27;);//4mysql&gt; select length(&#x27;s我e&#x27;);//5 concat(a,b…n);//字符串 s1,s2 等多个字符串合并为一个字符串 1mysql&gt; select concat(&#x27;hello!&#x27;,&#x27;看我!&#x27;,&#x27;你在&#x27;,&#x27;害怕&#x27;,&#x27;什么&#x27;);//hello!看我!你在害怕什么 列中的应用123456789101112131415161718192021222324252627282930-- 将first_name列的数据全部反转mysql&gt; select first_name,reverse(first_name) from s_emp;-- 这些函数是允许嵌套使用的mysql&gt; select first_name,upper(reverse(first_name)) from s_emp;-- 练习 - 模拟银行账户的输出方式-考虑该列是中文的情况.-- 查询效果-- Car_men C******-- 吴亦凡 吴**-- Mark M**-- concat函数 - 字符串的拼接mysql&gt; select first_name,concat(substring(first_name,1,1),rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 显示账户 from s_emp;-- replace函数-- replace(str,oldStr,newStr);mysql&gt; select first_name,replace(first_name,substring(first_name,2),rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 账户 from s_emp;-- 直接使用rpad函数-- rpad(str,拼接之后总的长度,appendStr);mysql&gt;select first_name,rpad(substring(first_name,1,1),char_length(first_name),&#x27;*&#x27;) 账户 from s_emp;-- 使用insert函数-- insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串-- insert函数的基本使用mysql&gt; select insert(&#x27;abcde&#x27;,2,3,&#x27;*&#x27;);//a*emysql&gt; select first_name,insert(first_name,2,char_length(first_name)-1,rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 账户 from s_emp; 数字函数 abs(n) - 求绝对值 mod(n,m) - 取模运算,返回n被m除的余数(同%操作符) floor(n) - 返回不大于n的最大整数值 - 向下取整 ceiling(n) - 返回不小于n的最小整数值 - 向上取整 round(n[,d]) - 返回n的四舍五入值,保留d位小数(d的默认值为0) 123mysql&gt;select round(3.5);mysql&gt;select round(3.456,2);//3.46 pow(x,y) - 返回值x的y次幂 sqrt(n) - 返回非负数n的平方根 pi() - 返回圆周率 rand() - 返回在范围**[0到1.0)**内的随机浮点值 truncate(n,d) - 保留数字n的d位小数并返回 - 直接截取 练习 求1~3之间的随机整数 12mysql&gt; select floor(rand()*3+1);mysql&gt; select truncate(rand()*3+1,0); 计算年薪 - 保留小数点2位 1select first_name,truncate(salary*12*(1+coalesce(commission_pct,0)/100),2) 年薪 from s_emp; 日期函数查询当前系统的日期 - select now(); dayofweek(date) - 返回日期date是星期几(1=星期天,2=星期一,……7=星期六,odbc标准) weekday(date) - 返回日期date是星期几(0=星期一,1=星期二,……6= 星期天) year(date) - 返回date的年份(范围在1000到9999) month(date) - 返回date中的月份数值 dayofmonth(date) - 返回date是一月中的第几日(在1到31范围内) hour(time) - 返回time的小时数(范围是0到23) minute(time) - 返回time的分钟数(范围是0到59) second(time) - 返回time的秒数(范围是0到59) period_add(p,n) - 增加n个月到时期p并返回(p的格式yymm或yyyymm) 1234mysql&gt; select period_add(&#x27;202108&#x27;,3);-- 需求把s_emp表中的start_date往后延1个月mysql&gt; select start_date,period_add(date_format(start_date,&#x27;%Y%m&#x27;),1) from s_emp; 注意:p可以是字符串,一定要满足一定的格式,或者可以直接使用date类型. period_diff(p1,p2) - 返回在时期p1和p2之间月数(p1和p2的格式yymm或yyyymm) p1-p2 curdate() - 以’yyyy-mm-dd’或yyyymmdd格式返回当前日期值(根据返回值所处上下文是字符串或数字) curtime() - 以’hh:mm:ss’或hhmmss格式返回当前时间值(根据返回值所处上下文是字符串或数字) now() - 以’yyyy-mm-dd hh:mm:ss’或yyyymmddhhmmss格式返回当前日期时间(根据返回值所处上下文是字符串或数字) last_day(date) - date日期所在月的最后一天是什么时候 datediff(d1,d2) - 两个日期d1,d2之间相差的天数 timestampdiff(type,d1,d2) - type - year,month,day… mysql中,虽然日期date_format函数来转成字符串类型的,mysql内部为了简化我们的写法,有的时候有的函数. 只要你传入的字符串满足一定的格式,那么它就会自动被转成日期函数. 补充1234567891. date_add(date,interval n type)2. date_sub(date,interval n type)type:yearmonthdayhourminutesecond 日期格式化date_format(date,format) - 把日期转换成指定模板的字符串. 根据format字符串格式化date值 (在format字符串中可用标志符: %m 月名字(january……december) %w 星期名字(sunday……saturday) %d 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(sun……sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(jan……dec) %j 一年中的天数(001……366) %H 24时制小时(00……23) %k 小时(0……23) %h 12时小时(01……12) %i 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [ap]m) %t 时间,24 小时(hh:mm:ss) %s 秒(00……59) %p am或pm %w 一个星期中的天数(0=sunday ……6=saturday ） 1mysql&gt; select start_date,date_format(start_date,&#x27;%Y-%m-%d %H:%i:%s&#x27;) from s_emp; 日期练习 找出员工的工作月数 - 和当前的日比较的 1mysql&gt; select first_name,start_date,timestampdiff(month,start_date,now()) 月份 from s_emp; 查询员工的工作天数 123mysql&gt; select first_name,start_date,timestampdiff(day,start_date,now()) 天数 from s_emp;mysql&gt; select first_name,start_date,abs(datediff(start_date,now())) 天数 from s_emp; 计算一年前,当前,一年后的日期 date_add(date,interval n type) date_sub(date,interval n type) 123mysql&gt; select date_sub(now(),interval 1 year) 一年前,now() 当前,date_add(now(),interval 1 year) 一年后;mysql&gt; select date_add(now(),interval -12 month) 一年前,now() 当前,date_add(now(),interval 12 month) 一年后; 当前日期前6个月的最后一天 1mysql&gt; select last_day(date_sub(now(),interval 6 month)); 把员工的入职日期格式化为年/月/日 1234mysql&gt; select start_date,date_format(start_date,&#x27;%Y-%m-%d&#x27;) from s_emp;-- 1990年05月03日mysql&gt; select start_date,date_format(start_date,&#x27;%Y年%m月%d日&#x27;) from s_emp; 找出5月份入职的员工 1mysql&gt; select first_name,start_date from s_emp where month(start_date)=5; 类型的转换日期转字符串数据查询出来之后显示用的. date_format(date,模板); 字符串转日期插入数据的时候,需要将日期列的字符串转换成日期类型,才能够插入到date类型列. mysql中只要你的字符串满足默认支持的格式.那么就会默认转成date类型. 123456789-- date列insert into test_date values(3,&#x27;xx&#x27;,&#x27;2019-09-08&#x27;);//ok &#x27;2019-09-08&#x27;insert into test_date values(4,&#x27;xx&#x27;,&#x27;2019/10/08&#x27;);//ok &#x27;2019/10/08&#x27;insert into test_date values(5,&#x27;xx&#x27;,&#x27;20191105&#x27;);//ok &#x27;20191105&#x27;insert into test_date values(5,&#x27;xx&#x27;,&#x27;2018-11-05 13:08:09&#x27;);//ok假设如果指定的是一个非法的字符串模板mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;05/11/2023&#x27;);ERROR 1292 (22007): Incorrect date value: &#x27;05/11/2023&#x27; for column &#x27;d1&#x27; at row 1 解决一个非法模板的字符串 - mysql不能把这个形式的字符串自动转换成date/datetime类型 str_to_date(str,pattern) 123str的格式也必须要和pattern是匹配 - 实现str-date类型的转换mysql&gt; insert into test_date values(6,&#x27;xx&#x27;,str_to_date(&#x27;05/11/2023&#x27;,&#x27;%d/%m/%Y&#x27;)); date和datetimedate - 年月日 datetime - 年月日时分秒 mysql中列如果是一个日期,常用的俩个类型分别是date和datetime 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051drop table test_date;create table test_date( id int(7), name varchar(20), d1 date);-- 插入数据insert into test_date values(1,&#x27;admin&#x27;,now());-- 插入指定的日期到表中mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;20191105&#x27;);-- 列是date,但是插入数据包含时分秒的mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;2018-11-05 13:08:09&#x27;);-- 查询出来的d1列的内容默认显示的日期的格式%Y-%m-%dmysql&gt; select * from test_date;+------+-------+------------+| id | name | d1 |+------+-------+------------+| 1 | admin | 2021-08-17 |+------+-------+------------+drop table test_datetime;create table test_datetime( id int(7), name varchar(20), d1 datetime);insert into test_datetime values(1,&#x27;tom&#x27;,now());-- 效果,如果列设置成了datetime,查询出来的模板是-%Y-%m-%d %H:%i:%smysql&gt; select * from test_datetime;+------+------+---------------------+| id | name | d1 |+------+------+---------------------+| 1 | tom | 2021-08-17 10:12:18 |+------+------+---------------------+-- 插入一个指定的日期 - 仅仅包含年月日mysql&gt; insert into test_datetime values(5,&#x27;xx&#x27;,&#x27;2019-09-08&#x27;);-- 时分秒是自动归05 | xx | 2019-09-08 00:00:00 mysql&gt;insert into test_datetime values(5,&#x27;xx&#x27;,&#x27;2019/09/08 13:12:18&#x27;);5 | xx | 2019-09-08 13:12:18","categories":[],"tags":[{"name":"DQL","slug":"DQL","permalink":"http://beautifulboyy/tags/DQL/"}]},{"title":"注解","slug":"java16","date":"2021-08-15T11:33:33.000Z","updated":"2021-08-15T11:40:49.480Z","comments":true,"path":"2021/08/15/java16/","link":"","permalink":"http://beautifulboyy/2021/08/15/java16/","excerpt":"","text":"注解jdk5.0开始引入了注解的机制. 框架的配置,框架的使用 - 1. 基于xml的配置方式 2. 基于注解的配置/开发方式 - 简洁 学习注解的目的是为了以后能够知道我们框架的使用中遇到注解,知道这个注解背后是个大概什么底层即可. 内置注解 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 @SuppressWarnings(“all”) - 抑制所有的警告 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 自定义注解 使用@interface来修饰注解,自动以的注解默认都会继承java.lang.Annotation @Target - 指定注解可以在什么地方被使用 类,方法,参数,接口,局部变量,属性,构造 值可以设置成枚举类型java.lang.annotation.ElementType中的枚举常量 123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; @Retention(RetentionPolicy.RUNTIME) 可以在程序的运行过程中通过反射的技术来得到注解的信息. 注解中只有方法的概念,没有属性的概念. 反射获取注解的值有办法来判断类或者方法是否加入了注解 有办法通过反射技术来获取类/方法上加入注解的属性值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package tech.aistar.day16.anno;import java.lang.reflect.Method;import java.util.Arrays;/** * 本类用来演示: 反射获取注解的值 * * @author: success * @date: 2021/8/13 2:39 下午 */public class MyAnnoTest &#123; public static void main(String[] args) &#123; //1. 判断某个类或者某个方法上是否有注解 //有注解 - 标志 - 对这个有注解的类该干嘛干嘛... //注解还配置了属性值 - 需要取出属性值,然后再进行进一步的处理... //类 Class&lt;?&gt; c = UseMyAnno.class; //1. 判断类上是否加入了MyAnno注解 boolean flag = c.isAnnotationPresent(MyAnno.class); if(flag)&#123; System.out.println(c.getSimpleName()+&quot;加入了注解!&quot;); //获取注解的属性值 - 前提是有 MyAnno myAnno = c.getAnnotation(MyAnno.class); //获取属性值 String[] arr = myAnno.value(); System.out.println(Arrays.toString(arr)); &#125;else&#123; System.out.println(c.getSimpleName()+&quot;上没有加入注解!&quot;); &#125; System.out.println(&quot;====方法上的注解的信息 - 反射技术===&quot;); try &#123; Method m = c.getDeclaredMethod(&quot;add&quot;); if(m.isAnnotationPresent(MyAnno.class))&#123; System.out.println(&quot;方法上有注解!&quot;); MyAnno myAnno = m.getAnnotation(MyAnno.class); String[] arr = myAnno.value(); System.out.println(Arrays.toString(arr)); &#125;else&#123; System.out.println(&quot;方法上没有注解...&quot;); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Mybatis注解开发方法mybatis底层使用到的是jdbc技术 - 和数据库打交道的技术 12345678910jdbc步骤很繁琐,步骤比较多~打开Connection con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;);String sql=&quot;delete from user&quot;;PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery();关闭rs.close();pstmt.close();con.close(); mybatis就是会对jdbc的代码进行一个封装 12345678public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll();&#125; 注解本身是不会完成任何的业务逻辑的 123456789101112通过反射的技术-&gt;select * from user 工具类&#123; Connection con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;); String sql=&quot;反射技术获取的&quot;; PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); 关闭 rs.close(); pstmt.close(); con.close();&#125;","categories":[],"tags":[{"name":"注解","slug":"注解","permalink":"http://beautifulboyy/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"面试题汇总","slug":"Interview-questions","date":"2021-08-13T13:18:04.000Z","updated":"2021-08-25T05:28:59.857Z","comments":true,"path":"2021/08/13/Interview-questions/","link":"","permalink":"http://beautifulboyy/2021/08/13/Interview-questions/","excerpt":"","text":"面试题汇总抽象类和接口的异同 相同点 抽象类和接口都属于抽象的数据类型,不能被实例化,只能被继承或实现. 抽象类和接口都可以包含抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法,但是如果这个子类是抽象的,就可以选择实现也可以选择不实现. 不同点 抽象类的关键字是abstract,接口的关键字是interface. 抽象类中允许存在构造方法,普通方法以及抽象方法.接口中不允许出现构造方法,允许出现抽象方法以及由default修饰的普通方法[jdk8.x]. 抽象类中允许定义普通属性,接口中只能定义公开静态的常量属性. 一个子类中最多只能继承一个抽象类,而一个实现类可以同时实现多个接口. int和Integer之间的区别 Integer是int的包装类型;int是基本数据类型. Integer变量必须实例化后才能使用;int变量不需要. Integer实际是对象的引用,指向此new的Integer对象;int是直接存储数据值. Integer的默认值是null;int的默认值是0. 泛型不支持int,但是支持Integer. int存储在栈中,Integer对象的引用存储在栈空间中,对象的数据存储在堆空间中. == 和 equals的区别 == - 基本数据类型比较,比较的是基本类型的值. equals - 对象类型比较,如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这时候仍然使用到的是==比较.如果重写了equals方法,就看equals提供的是哪些属性一致的时候,才返回true. synchronized和Lock的区别synchronized和lock都属于独占锁. 实现层面不同.synchronized是java关键字,jvm层面实现加锁和释放锁.Lock是一个接口,在代码层面实现加锁和释放锁. 是否自动释放锁.synchronized在线程代码执行完或出现异常时自动释放锁.Lock不会自动释放锁,需要在finally{}代码块中显式地释放锁. 是否一致等待.synchronized线程拿不到锁时会一直等待.Lock可以设置尝试获取锁或者获取锁失败一定时间超时 获取锁成功是否可知.synchronized无法得知是否获取锁成功.Lock可以通过tryLock判断是否获取锁成功. 功能复杂性.synchronized加锁可重入,不可中断,非公平.Lock可重入,可中断,可公平和不公平,细分读写锁提高效率. String,StringBuilder,StringBuffer的异同 相同点:三者之间都是用final修饰的,都是不可以被继承的. 不同点 String是不可变的字符串,线程安全,比较耗费系统资源和内存.性能是三者之中最低的. StringBuilder是可变的字符串,线程不安全,效率最高. StringBuffer是可变的字符串,线程安全,效率低于StringBuilder,但是高于String 方面 区别 可变与不可变 String类是不可变的,StringBuffer和StringBuilder是可变的. 线程是否安全 String类线程安全,StringBuilder类线程非安全,StringBuffer线程安全 效率 String&lt;StringBuffer&lt;StringBuilder final和finally和finalize三者之间的区别final: 修饰的局部变量一旦赋值成功,不可改变. 修饰的属性一旦赋值成功,不可改变. 修饰的类不可被继承 修饰的方法不可被重写 finally 一般是和try…catch搭配使用的,try块无论是否出现异常,finally块中代码都会执行. finally块中一般写的是释放或者关闭资源的代码. finalize finalize是Object类中提供的方法,当GC想去回收一个垃圾对象之前,会去调用这个对象的finalize方法,是由jvm去调用的. 该方法未必一定会被调用的到. HashMap和HashTable的区别 线程安全 - HashMap是非线程安全的,HashTable是线程安全的,HashTable内部的方法基本都经过synchronized修饰. 效率 - 由于线程安全问题,HashMap的效率高于HashTable 对于null key和null value的支持 - HashMap允许将null作为一个key或者value,而HashTable不允许. 初始容量大小和每次扩容大小的不同 创建时如果不指定容量初始值,HashTable的默认初始大小为11,之后每次扩容容量变为原来的2n+1.而HashMap默认初始大小为16,之后每次扩容容量变为原来的2倍. 创建时如果给定了容量初始值,HashTable会直接使用给定的初始值,而HashMap会将其扩充为2的幂次方大小. 底层数据结构 - JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化,当链表大于阈值(默认为8)时,将链表转化为红黑树,以减少搜索时间.HashTable没有这样的机制. 注:HashTable是保留类不建议使用,推荐在单线程环境下使用HashMap,多线程环境下使用ConcurrentHashMap. 方法的重载和方法的重写 方法的重载 重载的前提是在同一个类中 重载的方法方法名必须相同 重载的方法参数列表必须不相同 重载的方法与修饰符无关. 重载的方法返回类型可以不一样,也可以一样 方法的重写 重写的前提是要有继承关系 重写的方法方法名必须相同 重写的方法参数列表必须高度保持一致 重写的方法访问修饰符的安全性可以小于或等于父类 重写的方法返回类型可以小于或者等于父类 事务隔离级别 READ UNCOMMITTED - 读未提交 READ COMMITTED - 读已提交","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"反射技术","slug":"java15","date":"2021-08-12T03:18:20.000Z","updated":"2021-08-29T14:44:30.135Z","comments":true,"path":"2021/08/12/java15/","link":"","permalink":"http://beautifulboyy/2021/08/12/java15/","excerpt":"","text":"反射 反射式编程（英语：reflective programming）或反射（英语：reflection)或者内省 是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。[1]用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 通俗讲 - 通过反射技术在程序的运行过程中,来获取类/接口的信息[修饰符,类的名称,父类],属性的信息[修饰符,数据类型,属性名],方法的信息[修饰符,数据类型,名称]等. 在运行的时候才知道我操作的是哪个类. 掌握目录: 3-1. 通过反射技术来动态获取属性的信息以及操作属性[反射的技术来对属性的值进行设置和获取] 3-2. 通过反射技术来动态调用类中的构造方法以及获取构造方法的信息[修饰符,方法名,参数列表] 3-3. 通过反射技术来动态获取类里面的方法的信息[修饰符,数据类型,方法名以及方法参数列表]以及反射调用方法 api包 - java.lang.reflect 反射优势 - “很流氓” - 破坏封装性 学好反射和设计模式,帮助我们未来读懂一些框架源码.所有的框架底层都是基于反射技术来实现的. java.lang.Class class实例 - 一个类无论被实例化多少次,那么它在jvm中的class实例永远只有一个. 它是学习反射技术的必备的类 - 提供了很多api来完成掌握目标中的动作 所有被类加载器加载到内存中的类都是属于Class的对象 - Class是用来描述类的类[用来描述类的元信息] 我们的类在Class面前,就是Class的一个对象而已. 获取类的Class实例的方式 类名.class 调用java.lang.Object类提供的方法Class&lt;?&gt; getClass(); 框架底层喜欢的使用一种,更加灵活 Class类中提供的static Class&lt;?&gt; forName(“类的全限定名”);//需要抓取一个非运行时异常java.lang.ClassNotFoundException类型找不到异常 基本类型.class 1234567891011121314151617181920212223242526272829303132333435package tech.aistar.day16;/** * @Author liuWenXiu * @Date 2021/8/12 19:52 * @description Class创建 */public class ClassDemo &#123; public static void main(String[] args) &#123; // 1.类名.class Class&lt;?&gt; c1 = Point.class; System.out.println(c1); //class tech.aistar.day16.Point Point p = new Point(); // 2.Object类提供的getClass方法 Class&lt;?&gt; c2 = p.getClass(); System.out.println(c2); //class tech.aistar.day16.Point System.out.println(c1 == c2); //true // 3.Class类提供的static Class&lt;?&gt; forName(&quot;类的全限定名&quot;) // 非运行时异常 try &#123; Class&lt;?&gt; c3 = Class.forName(&quot;tech.aistar.day16.Point&quot;); System.out.println(c3); //class tech.aistar.day16.Point System.out.println(c2 == c3); //true &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // 4.基本类型.class System.out.println(int.class); //int System.out.println(String.class); //class java.lang.String System.out.println(boolean.class); //boolean &#125;&#125; 反射相关api Field getField(String name); //根据属性的名称来获取公有的Field对象 Filed[] getFields(); // 获取类里面的公有的Field属性数组 Fileld getDeclaredField(String name); // 根据属性的名称来得到Filed对象 Field[] getDeclaredFields(); // 获取类里面的所有的Field属性数组 String getName();//获取类的全限定名 String getSimpleName();//获取类的简称 T newInstance();//调用空参构造 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes); 根据指定的参数类型来得到指定的构造对应的实例Constructor对象. 如果什么参数都不传入,拿到的就是空参构造对应的Constructor对应的实例. Constructor&lt;?&gt;[] getDeclaredConstructors(); 直接获取类中的所有的构造,每个构造对应一个Constructor. Method getDeclaredMethod(String methodName,Class&lt;?&gt;… parameterTypes); 如果获取的方法有形参,那么需要把形参的数据类型也写上. Method][] getDeclaredMethods(); Fieldjava.lang.reflect.Field api int getModifiers();返回由该 Field对象表示的字段的Java语言修饰符，作为整数。 1234//默认的 - 0//public -1//private - 2//protected - 4 Class&lt;?&gt; getType();//返回属性的数据类型 String getName();//属性的名称 void set(Object obj,Object value);//通过属性对应的Field对象来告知JVM,应该把value设置到哪个obj对象上去. void get(Object obj); // 通过属性对应的Field对象来获取属性的值 void setAccessible(boolean on);//反射操作私有属性,必须要设置为true,否则会抛出-java.lang.IllegalAccessException 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package tech.aistar.day16;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * @Author liuWenXiu * @Date 2021/8/12 20:10 * @description 反射技术来操作属性 */public class FieldDemo &#123; public static void main(String[] args) &#123; // 首先获取Class实例 Class&lt;?&gt; c = Point.class; // 获取Field对象 Field[] fields = c.getDeclaredFields(); for (Field field : fields) &#123; // 1. int getModifiers() 返回Field对象表示的字段java语言修饰符作为整数 //默认的-0 public-1 private-2 protected-4 //System.out.println(field+&quot;:&quot;+field.getModifiers()); // 想要打印输出具体的private等,需要调用下面的方法啊 // Modifier.toString()方法 System.out.print(Modifier.toString(field.getModifiers())+&quot; &quot;); // 2.获取属性的数据类型 Class&lt;?&gt; c1 = field.getType(); System.out.print(c1.getSimpleName()+&quot; &quot;); // 3. 获取属性的名称 System.out.println(field.getName()); &#125; System.out.println(&quot;-----------------------&quot;); try &#123; Point p = new Point(); Field x = c.getDeclaredField(&quot;x&quot;); System.out.print(Modifier.toString(x.getModifiers()) + &quot; &quot;); System.out.print(x.getType().getSimpleName()+&quot; &quot;); System.out.println(x.getName()); // 4.void set(Object obj,Object value); 通过属性对应的Filed对象来告知jvm应该把value设置到哪个对象上 // 可能会报异常java.lang.IllegalAccessException // 这个是因为属性可能是私有的,所以需要进行一个操作 // 5.void setAccessible(boolean on); x.setAccessible(true); x.set(p,21); System.out.println(p); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Constructor调用空参构造直接调用java.lang.Class提供的方法T newsIntance(); java.lang.reflect.Constructor提供了方法 1234public T newInstance(Object... initargs)Constructor&lt;?&gt; c1 = c.getDeclaredConstructor();Point p2 = (Point) c1.newInstance();//可变长列表的方法 调用带参构造java.lang.reflect.Constructor - 提供的方法 public T newInstance(Object … initargs) 构造demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package tech.aistar.day16;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * @Author liuWenXiu * @Date 2021/8/12 20:43 * @description 反射调用构造 */public class ConstructorDemo &#123; public static void main(String[] args) &#123; // 首先获取Class实例 Class&lt;?&gt; c = Point.class; // 第一种方式:直接利用反射调用空参构造 // 这种方法只能调用空参的构造,要抛出异常并且进行类型转换 try &#123; Point p1 = (Point) c.newInstance(); System.out.println(p1); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; // 第二种方式:利用可变长参数列表获取Constructor实例 try &#123; // 2.1 无参 - 同样需要抛出异常并强制类型转换 Constructor&lt;?&gt; c1 = c.getDeclaredConstructor(); Point p2 = (Point) c1.newInstance(); System.out.println(p2); // 2.2 一参 - 参考Point类的一参构造 //private Point(int x) Constructor&lt;?&gt; c2 = c.getDeclaredConstructor(int.class); //注意这个实参是正好与形参的Class对应的 // 还需要注意的是一个一参构造的修饰符是private,所以需要设置权限 c2.setAccessible(true); // 调用一参构造 Point p3 = (Point) c2.newInstance(10); // 这里的实参也是要对应的填入相应的值 System.out.println(p3); // 2.3 两参 - 参考Point类的两参构造 // public Point(int x, String y) Constructor&lt;?&gt; c3 = c.getDeclaredConstructor(int.class,String.class); Point p4 = (Point) c3.newInstance(10,&quot;sak&quot;); System.out.println(p4); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 常用方法 int getModifiers();//获取修饰符对应的数字 String getName();//构造方法的名称 - [类的全限定名] void setAccessible(boolean on);//如果设置true,直接调用私有的的构造方法 它可以破坏单例!!!! Class&lt;?&gt;[] getParameterTypes(); // 获取构造方法的形参类型 1234567891011121314151617181920212223Constructor&lt;?&gt;[] constructors = c.getDeclaredConstructors();if(null!=constructors &amp;&amp; constructors.length&gt;0)&#123; // 遍历 for (Constructor&lt;?&gt; constructor : constructors) &#123; // 1.1 打印修饰符 System.out.print(Modifier.toString(constructor.getModifiers())+&quot; &quot;); // 1.2 打印构造名称 System.out.print(constructor.getName()+&quot;(&quot;); // 1.3 打印形参列表 Class&lt;?&gt; [] types = constructor.getParameterTypes(); if(null!=types &amp;&amp; types.length&gt;0)&#123; // 遍历形参列表 for (int i = 0; i &lt; types.length; i++) &#123; //调整格式 if(i!=types.length-1)&#123; System.out.print(types[i].getSimpleName()+&quot;,&quot;); &#125;else&#123; System.out.print(types[i].getSimpleName()); &#125; &#125; &#125; System.out.println(&quot;)&quot;); &#125; Methodjava.lang.reflect.Method 常用方法 int getModifiers();返回由该 method对象表示的字段的Java语言修饰符，作为整数。 Class&lt;?&gt; getReturnType();//返回方法的返回类型 String getName();//方法的名称 Class&lt;?&gt;[] getParameterTypes();//返回方法的参数列表. Object invoke(Object obj,Object… args);//反射调用方法 void setAccessible(boolean on);//调用私有方法需要调用之前来设置可见性 - true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day16;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Type;/** * @Author liuWenXiu * @Date 2021/8/13 11:00 * @description 反射获取方法的信息 */public class MethodInfoDemo &#123; public static void main(String[] args) &#123; Class&lt;?&gt; c = Point.class; Method[] methods = c.getDeclaredMethods(); if(null!=methods &amp;&amp; methods.length&gt;0)&#123; // 遍历 for (Method method : methods) &#123; // 打印信息 // 修饰符 System.out.print(Modifier.toString(method.getModifiers())+&quot; &quot;); // 返回类型 - 返回类型是Class的 System.out.print(method.getReturnType().getSimpleName()+&quot; &quot;); // 方法名 System.out.print(method.getName()+&quot;(&quot;); // 参数列表 Class&lt;?&gt;[] types = method.getParameterTypes(); if(null!=types &amp;&amp; types.length&gt;0)&#123; // 遍历打印参数列表 for (int i = 0; i &lt;types.length ; i++) &#123; if(i!=types.length-1)&#123; System.out.print(types[i].getSimpleName()+&quot;,&quot;); &#125;else &#123; System.out.print(types[i].getSimpleName()); &#125; &#125; &#125; System.out.println(&quot;)&quot;); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package tech.aistar.day16;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @Author liuWenXiu * @Date 2021/8/13 11:40 * @description 反射调用方法 */public class MethodInvokeDemo &#123; public static void main(String[] args) &#123; // 1.首先构建实例 Class&lt;?&gt; c = Point.class; // 2.通过反射创建对象 try &#123; Point p = (Point) c.newInstance(); // 获取Method // 1. 公有非静态无参无返回值方法 // public void test() Method m1 = c.getDeclaredMethod(&quot;test&quot;); // 调用方法 m1.invoke(p); // 2. 公有非静态有参有返回值方法 // public String test(int) Method m2 = c.getDeclaredMethod(&quot;test&quot;,int.class); String s = (String) m2.invoke(p,10); System.out.println(s); // 3.公有非静态两参无返回值方法 // public void test(int,String) Method m3 = c.getDeclaredMethod(&quot;test&quot;,int.class,String.class); m3.invoke(p,10,&quot;saku&quot;); // 4.私有非静态无参无返回值类型方法 // private void testPrivate() Method m4 = c.getDeclaredMethod(&quot;testPrivate&quot;); m4.setAccessible(true); m4.invoke(p); // 5.公有静态有参无返回值方法 // public static void test(String) Method m5 = c.getDeclaredMethod(&quot;test&quot;,String.class); m5.invoke(null,&quot;sa&quot;); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Modifierjava.lang.reflect 传入一个修饰符对应的数字,来返回修饰的具体的中文的名称 1234567891011121314151617181920212223public static String toString(int mod) &#123; StringBuilder sb = new StringBuilder(); int len; if ((mod &amp; PUBLIC) != 0) sb.append(&quot;public &quot;); if ((mod &amp; PROTECTED) != 0) sb.append(&quot;protected &quot;); if ((mod &amp; PRIVATE) != 0) sb.append(&quot;private &quot;); /* Canonical order */ if ((mod &amp; ABSTRACT) != 0) sb.append(&quot;abstract &quot;); if ((mod &amp; STATIC) != 0) sb.append(&quot;static &quot;); if ((mod &amp; FINAL) != 0) sb.append(&quot;final &quot;); if ((mod &amp; TRANSIENT) != 0) sb.append(&quot;transient &quot;); if ((mod &amp; VOLATILE) != 0) sb.append(&quot;volatile &quot;); if ((mod &amp; SYNCHRONIZED) != 0) sb.append(&quot;synchronized &quot;); if ((mod &amp; NATIVE) != 0) sb.append(&quot;native &quot;); if ((mod &amp; STRICT) != 0) sb.append(&quot;strictfp &quot;); if ((mod &amp; INTERFACE) != 0) sb.append(&quot;interface &quot;); if ((len = sb.length()) &gt; 0) /* trim trailing space */ return sb.toString().substring(0, len-1); return &quot;&quot;;&#125; Properties 属于集合框架的类 - 属于Map[I] java.util.Properties extends java.util.Hashtable[哈希表,多线程安全的] 作用:通过io流把本地的.properties文件读取到内存中,然后映射到Properties对象. Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射. File - 本地磁盘的文件在java内存中的映射的那个对象. 存储数据的格式是一个键值对的形式 123# key=value - key不要重复username=tompassword=123 根据key来获取value的方法 1String getProperty(String key); Arrayjava.lang.reflect Array类提供静态方法来动态创建和访问Java数组 - 反射技术操作java数组 常用方法 static int getLength(Object array)返回指定数组对象的长度，如 int 。 static Object get(Object array, int index)返回指定数组对象中的索引组件的值。 static Object newInstance(Class&lt;?&gt; componentType, int length)创建具有指定组件类型和长度的新数组。 static void set(Object array, int index, Object value)将指定数组对象的索引组件的值设置为指定的新值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package tech.aistar.day16;import java.lang.reflect.Array;/** * @Author liuWenXiu * @Date 2021/8/13 14:04 * @description 反射操作java数组 */public class ArrayDemo &#123; public static void main(String[] args) &#123; Integer[] arr1 = &#123;1,3,4,5,7&#125;; String[] arr2 = &#123;&quot;saku&quot;,&quot;rose&quot;,&quot;jack&quot;&#125;; // 利用反射技术打印数组元素 printArr(arr1); System.out.println(&quot;-----&quot;); printArr(arr2); &#125; /** * 利用反射技术打印数组元素 * 注意点:Integer[] 和String[] 数组都是继承于Object的,不是继承于Object[] * @param arr */ public static void printArr(Object arr)&#123; // 1.获取数组的长度 int len = Array.getLength(arr); // 2.打印输出 for (int i = 0; i &lt; len; i++) &#123; // 反射技术通过下标去取元素 Object obj = Array.get(arr,i); System.out.println(obj); &#125; &#125; /** * 利用反射技术实现数组的扩容 * @param arr * @return */ public static Object extendsArr(Object arr)&#123; // 创建数组的条件:数组的元素类型,数组的长度 // 1.获取长度 int oldLen = Array.getLength(arr); // 2.获取元素类型 Class&lt;?&gt; c = arr.getClass().getComponentType(); // 3.通过反射创建新的数组 Object newArr = Array.newInstance(c,oldLen*2); // 4.赋值 for (int i = 0; i &lt; oldLen; i++) &#123; Object o = Array.get(arr,i); Array.set(newArr,i,o); &#125; return newArr; &#125;&#125; 面试题 - Arrays和Array的区别拓展应用反射可以破坏双重锁单例1234567891011121314151617181920212223242526272829public class ReflectPoSingleton &#123; public static void main(String[] args) &#123; //1. 获取单例的Class实例 try &#123; Class&lt;?&gt; c = Class.forName(&quot;tech.aistar.design.singleton.version03.Singleton03&quot;); //2. 获取空参构造对应的Constructor实例 Constructor&lt;?&gt; c1 = c.getDeclaredConstructor(); //3. 调用私有的空参构造 c1.setAccessible(true); //4. 调用 Singleton03 s1 = (Singleton03) c1.newInstance(); //反射连续调用俩次私有的空参构造 Singleton03 s2 = (Singleton03) c1.newInstance(); System.out.println(s1 == s2);//false &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反射不可以破坏枚举单例分析-NoSuchMethodException 123//记载类,初始化静态属性,调用空参构造 Class&lt;?&gt; c5 = Class.forName(&quot;tech.aistar.design.singleton.version05.Singleton05&quot;);Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(); 12345678控制台效果比较繁琐的操作的事情,费时费力的事情//不存在一个空参构造的方法让我们去调用java.lang.NoSuchMethodException: tech.aistar.design.singleton.version05.Singleton05.&lt;init&gt;() at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.getDeclaredConstructor(Class.java:2178) at tech.aistar.day16.ReflectPoSingleton.main(ReflectPoSingleton.java:36) 控制台 hello.java 123public enum hello&#123; INSTANCE&#125; 1234确认jdk-bin-jad.exe - 没有下载 - http://varaneckas.com/jad/javac hellojad -s java hello反编译之后出来之后 hello(String.class,int.class) 解决方案1Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,int.class); 分析 - IllegalArgumentException12345678910//加载这个类Class&lt;?&gt; c5 = Class.forName(&quot;tech.aistar.design.singleton.version05.Singleton05&quot;);Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,int.class);//java.lang.NoSuchMethodException - 抛出一个不存在这个方法cc.setAccessible(true);//Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: // Cannot reflectively create enum objectsSingleton05 s05 = (Singleton05) cc.newInstance(); 原因剖析newInstance方法 1234567891011@CallerSensitivepublic T newInstance(Object ... initargs)throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException&#123;//判断是否为枚举类型,如果是枚举类型直接抛出了这个异常了.if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)&#123; throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);&#125;return inst;&#125; 结论 - 不允许我们用反射的技术来构建枚举类型的实例,底层会进行类型的判断,发现如果是枚举类型对应的class实例,直接抛出异常","categories":[],"tags":[{"name":"反射","slug":"反射","permalink":"http://beautifulboyy/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"枚举类型","slug":"java14","date":"2021-08-10T00:16:32.000Z","updated":"2021-08-10T14:48:44.282Z","comments":true,"path":"2021/08/10/java14/","link":"","permalink":"http://beautifulboyy/2021/08/10/java14/","excerpt":"","text":"枚举类型枚举常量 - 类型安全的常量 - 公共的静态的常量[final]属性 - 不可改变的. jdk5.0开始提供的,以前的作用就是用来替代常量接口的. 常量接口 1234567891011public interface IConsts&#123; // 最全的写法 // 公开的静态的常量属性[接口中只能定义这种类型的属性] public static final int CAR = 1; // 精简的写法 public int CAR = 1; // 最精简的写法 int CAR = 1;&#125; 关键字使用enum关键字来定义一个枚举类型的 switch()中的参数类型可以是byte,short,int,char,enum,String,Byte,Short,Integer 特点 枚举常量在定义时使用,隔开.最后一个枚举常量不需要使用逗号.如果最后一个枚举常量下面还有代码的话,需要使用分号隔开. 允许存在构造方法,但是访问修饰符不能是public或者protected. 枚举类型是不能被实例化的. 枚举类型中可以提供普通属性 每个枚举类型默认都会自动继承java.lang.Enum&lt;E extends Enum&gt; 枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法. 枚举类型不支持再去继承另外一个枚举类型 枚举烈性不支持再去手动继承另外一个类.","categories":[],"tags":[{"name":"枚举","slug":"枚举","permalink":"http://beautifulboyy/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"进程和线程","slug":"java13","date":"2021-08-09T10:17:57.000Z","updated":"2021-08-15T12:23:38.511Z","comments":true,"path":"2021/08/09/java13/","link":"","permalink":"http://beautifulboyy/2021/08/09/java13/","excerpt":"","text":"进程和线程一个程序至少一个进程,一个进程至少一个线程.线程不能单独运行,它一定是运行在进程的内部的. Java程序的启动 启动java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言] 开启一个JVM进程 - jvm.exe[windows中的可执行文件,C语言写的程序字节编译成了.exe可执行文件] 当JVM进程启动之后,同时开启两个线程 - 分别是main主线程以及一个GC线程[后台守护线程] 守护线程 - 如果后台只剩下守护线程在执行的时候,进程就会结束. -&gt; 进程的结束不需要等到守护线程全部执行完才会结束. main线程负责执行main方法中的程序 - main方法中的程序全部执行完之后,main线程运行结束.GC线程负责进行垃圾对象的回收. 进程正在执行中的应用程序: 是并发执行的程序在执行过程中分配和管理资源的基本单位,是一个动态概念. 竞争计算机系统资源的基本单位。 - “多任务操作系统” - “多个进程在**”同时”**在运行” - CPU分配资源 - “分时分片” - CPU调度的基本单位 线程是进程的一个执行单元，是进程内部调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 一个进程可以拥有多个线程的同一个进程内部的多个线程是可以共享进程资源的 线程的创建[传统方式] 写一个类去继承java.lang.Thread类 - 重写里面的run方法 12345678910111213141516171819202122232425262728public class Thread01 extends Thread&#123; @Override public void run() &#123; // 获取当前线程的名称 System.out.println(Thread.currentThread().getName()); &#125;&#125;class TestThread01&#123; public static void main(String[] args) &#123; // 1.创建线程 Thread t1 = new Thread01(); // 面向父类编程 Thread t2 = new Thread01(); // A.当线程对象一旦被创建成功,线程处于新建状态/瞬态 // 2.设置线程属性 // 设置线程的属性一定是在启动线程之前完成的 t1.setName(&quot;线程01&quot;); t2.setName(&quot;线程02&quot;); // 3.启动线程 t1.start(); t2.start(); // B.一旦调用了start方法,表示线程已经处于就绪态[并不是运行态] // C.运行态 - 程序正常运行的过程 // D.Dead[死亡状态] - 结束状态 - 线程执行结束了 &#125;&#125; 注意要点: 目前接触的线程状态 新建状态/瞬态: 线程对象被创建new成功时的状态 就绪态: 启动线程时调用start方法后的状态 运行态: 程序正常运行的状态 死亡态: 线程执行结束的状态 设置线程的属性一定在启动线程之前完成. 如果没有给线程设置名称,那么系统会自动默认给线程分配名称.格式: Thread-数字 线程的启动调用的是start方法,重写的是run方法.底层是让jvm调度线程,所以run方法是由jvm进行调度的. 并不是先启动哪个线程,就一定会先去执行哪个线程 - 线程的执行是由cpu控制的 - 不是人为进行控制的.所以程序的运行结果不是一定的. 写一个类去实现java.lang.Runnale接口 - 重写里面的run方法 123456789101112131415161718192021222324252627282930313233package tech.aistar.day15.thread01;/** * @Author liuWenXiu * @Date 2021/8/9 18:46 * @description 线程的创建 - 实现Runnable接口 */public class Thread02 implements Runnable&#123; @Override public void run() &#123; // 获取当前线程的名称 System.out.println(Thread.currentThread().getName()); &#125;&#125;class TestThread02&#123; public static void main(String[] args) &#123; // 1.线程的创建 Runnable r = new Thread02(); // 构造:public Thread(Runnable target) Thread t1 = new Thread(r); Thread t2 = new Thread(r); // 2.设置线程属性 t1.setName(&quot;线程-1&quot;); t2.setName(&quot;线程-2&quot;); // 3.启动线程 t1.start(); t2.start(); &#125;&#125; 写一个类去实现java.util.concurrent包下的Callable接口 - 重写里面的call方法. 12345678910111213141516171819202122232425262728293031323334 ~~~ #### Thread和Runnable的区别* Thread:**共享代码,不共享资源** ~~~java public class DiffDemo &#123; public static void main(String[] args) &#123; // 创建线程 Thread t1 = new T1(); Thread t2 = new T1(); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125; &#125; class T1 extends Thread&#123; // 定义一个属性 private Integer tickets = 10; @Override public void run() &#123; for (int i = 10; i &gt; 0 ; i--) &#123; if(tickets &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;正在购票,剩余:&quot;+(--tickets)); &#125; &#125; &#125; &#125; 123456789101112131415161718192021运行结果:线程1正在购票,剩余:9线程2正在购票,剩余:9线程1正在购票,剩余:8线程1正在购票,剩余:7线程1正在购票,剩余:6线程1正在购票,剩余:5线程1正在购票,剩余:4线程1正在购票,剩余:3线程1正在购票,剩余:2线程1正在购票,剩余:1线程1正在购票,剩余:0线程2正在购票,剩余:8线程2正在购票,剩余:7线程2正在购票,剩余:6线程2正在购票,剩余:5线程2正在购票,剩余:4线程2正在购票,剩余:3线程2正在购票,剩余:2线程2正在购票,剩余:1线程2正在购票,剩余:0 线程的调度不是人为控制的,所以每次的结果可能都是不同的.这个运行结果表示每个线程都拥有各自的资源[指的tickets],它不是共享的. 只有当资源设置成静态的时候才能进行资源共享 1private static Integer tickets = 10; 1234567891011运行结果:线程1正在购票,剩余:9线程2正在购票,剩余:8线程1正在购票,剩余:7线程2正在购票,剩余:6线程1正在购票,剩余:5线程2正在购票,剩余:4线程2正在购票,剩余:2线程1正在购票,剩余:3线程2正在购票,剩余:1线程1正在购票,剩余:0 这个结果表示线程拥有的资源是共享的,因为tickets是静态的,静态资源是类加载的时候被分配空间以及初始化,在内存中只有1份.并且这种情况可能仍旧可能出现两个线程在操作同一份tickets的情况,因为没用锁. 123456789101112131415161718class T1 extends Thread&#123; // 定义一个属性 //private static Integer tickets = 10; private Integer tickets = 10; @Override public void run() &#123; for (int i = 10; i &gt; 0 ; i--) &#123; if(tickets &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;正在购票,剩余:&quot;+(--tickets)); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021运行结果:线程2正在购票,剩余:9线程1正在购票,剩余:9线程1正在购票,剩余:8线程2正在购票,剩余:8线程1正在购票,剩余:7线程2正在购票,剩余:7线程2正在购票,剩余:6线程1正在购票,剩余:6线程2正在购票,剩余:5线程1正在购票,剩余:5线程2正在购票,剩余:4线程1正在购票,剩余:4线程2正在购票,剩余:3线程1正在购票,剩余:3线程1正在购票,剩余:2线程2正在购票,剩余:2线程2正在购票,剩余:1线程1正在购票,剩余:1线程2正在购票,剩余:0线程1正在购票,剩余:0 Runnable:共享代码,共享资源 123456789101112131415161718192021222324252627public class DiffDemo &#123; public static void main(String[] args) &#123; // 创建线程 Runnable r = new T2(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125;class T2 implements Runnable&#123; // 定义一个属性 private Integer tickets = 10; @Override public void run() &#123; for (int i = 10; i &gt; 0 ; i--) &#123; if(tickets &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;正在购票,剩余:&quot;+(--tickets)); &#125; &#125; &#125;&#125; 1234567891011运行结果:线程1正在购票,剩余:9线程1正在购票,剩余:7线程1正在购票,剩余:6线程1正在购票,剩余:5线程1正在购票,剩余:4线程1正在购票,剩余:3线程1正在购票,剩余:2线程2正在购票,剩余:8线程1正在购票,剩余:1线程2正在购票,剩余:0 线程安全的类和线程非安全的类 StringBuilder - 线程非安全的字符串类; StringBuffer - 线程安全的字符串类 ArrayList - 线程非安全的集合; Vector - 线程安全的集合 HashMap - 线程非安全的集合; Hashtable - 线程安全的集合 以上线程安全的类,它们的api方法都使用了synchronized进行修饰.在某个时刻只能由一个线程去访问,其他线程都是出于等待状态. 实例 - 使用类型安全的类1234567891011121314151617181920212223242526272829303132package tech.aistar.day15.thread01;import java.util.Vector;/** * @Author liuWenXiu * @Date 2021/8/9 19:21 * @description 线程安全与线程非安全的类 */public class SafeThreadDemo &#123; public static void main(String[] args) &#123; // 创建线程 Runnable r = new TS(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); &#125;&#125;class TS implements Runnable&#123; //线程安全的类 private Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); @Override public void run() &#123; for (int i = 0; i &lt; 100000 ; i++) &#123; vector.add(i); &#125; System.out.println(&quot;大小:&quot;+Thread.currentThread().getName()+&quot;:&quot;+vector.size()); &#125;&#125; 123456789运行结果:(随机展示了三种情况)大小:Thread-0:175656大小:Thread-1:200000大小:Thread-0:200000大小:Thread-1:200000大小:Thread-1:174163大小:Thread-0:200000 问:是否能理解为什么数值可以不为200000 在实际运行时,很少能有两个结果都为200000的情况.因为实际时很难做到完成的同步,通常都是第一个打印的结果比第二个打印的结果小(但具体是线程1先打印还是线程2先打印也是不一定的).因为在运行的时候,可能会有一个运行的比较快,然后另一个还没运行完. 老师的例子:小红和小蓝有一个共用的工资卡[Vector],到了发工资的时候,两个人同时发工资,小红五千五千地转钱到这个工资卡,而小蓝则是一千一千的转钱到工资卡.转钱的动作是同时进行的,小红在转十万的同时,小蓝也在向工资卡里面转钱. 有三种情况:第一种情况是小红转完了小蓝还没有转完,小红查看时发现卡里有她自己转的十万,还有小蓝转的几万.第二种情况是小红转完的同时小蓝也转完了,他俩查看的时候都发现卡里正好有二十万.第三种情况是小红转的太慢了,小蓝转完了的时候小红还没转完,小蓝查看的时候有他自己转的十万,还有小红转的几万. 最终的结果不是由一个线程在做贡献,两个线程都在做贡献 实例 - 使用类型不安全的类线程非安全的类 - 不要让它设置成一个共享资源 123456789// 线程不安全的类private ArrayList&lt;Integer&gt; vector = new ArrayList&lt;&gt;();@Overridepublic void run() &#123; for (int i = 0; i &lt; 100000 ; i++) &#123; vector.add(i); &#125; System.out.println(&quot;大小:&quot;+Thread.currentThread().getName()+&quot;:&quot;+vector.size());&#125; 123运行结果:Exception in thread &quot;Thread-0&quot; java.lang.ArrayIndexOutOfBoundsException: 163大小:Thread-1:100136 两者之间的对比: Vector类中的add方法是由synchronized修饰的,要么是由线程1执行,要么是由线程2执行,不可能两个线程同时进入到这个add方法. 而ArrayList类中add方法没有由synchronized修饰,两个线程会同时进入到add方法,明明应该是添加了两个元素,但其中一个线程的值会覆盖另外一个线程的值,导致实际上仅仅是向容器中添加了一个元素.并且每次add方法调用时,底层的size就会自增,但是集合中的有效个数却会少掉一个,导致有效数据&lt;size,因此报错. 常用方法 static Thread currentThread(); //返回当前正在执行的线程的引用对象 String getName(); // 返回线程的名称 void start(); // 启动线程,本质上当线程.start时底层会让jvm去启动线程,我们的程序是没有资格和能力去真正的把一个线程给启动起来的. CPU调度JVM线程 - JVM调用线程 void setName(String name); // 给线程设置名称 synchronized关键字 java语言的关键字 可以用来给对象,方法或者代码块加锁 当它锁定一个方法[同步方法]或者一个代码块[同步代码块]的时候,同一时刻最多只有一个线程执行这段代码 当两个并发线程访问同一个对象object中的这个加锁同步代码块时,一个时间内只能有一个线程得到执行,另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块. 基础方法在java中,每个对象有且仅有一个同步锁,并且同步锁是依赖于对象存在的.当我们调用对象的synchronized修饰的同步方法的时候,就是获取了该对象的同步锁. 修饰普通方法 - 对象锁 - 不同的对象拥有独立的”一把锁”,每个对象的”锁”是不冲突的. 修饰静态方法 - 类锁 - 作用于这个类下的所有对象 - 这个类实例化出来的所有对象竞争的是同一把锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day15.syn;/** * @Author liuWenXiu * @Date 2021/8/10 18:46 * @description */public class SynHello extends Thread&#123; @Override public void run() &#123; //add3(); add4(); &#125; public synchronized void add3()&#123; System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125; public static synchronized void add4()&#123; System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125;&#125;class TestSynHello&#123; public static void main(String[] args) &#123; Thread t1 = new SynHello(); Thread t2 = new SynHello(); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; 使用synchronized修饰非静态方法时是对象锁,每个对象拥有独立的锁,而t1和t2是两个不同的对象,所以不影响结果. 使用synchronized修饰静态方法时是类锁,这个类实例化出来的对象t1和t2竞争的都是同一把锁,所以结果改变,真正实现了将add方法锁住. 还有一个点就是对于Runnable而言,即使是使用synchronized修饰非静态方法,但利用Runnable创建线程new的对象是相同的,所以也是能锁住的. 修饰代码块synchronized(this) - 对象锁 修饰代码块synchronized(类名.class) - 类锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.day15.syn;/** * @Author liuWenXiu * @Date 2021/8/10 19:15 * @description synchronized修饰代码块 * 场景:没有必要锁住整个方法,仅仅只需要锁住需要同步的代码即可. */public class SynLockDemo extends Thread&#123; @Override public void run() &#123; add2(); &#125; public void add()&#123; synchronized (SynLockDemo.class)&#123; System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125; &#125; public void add2()&#123; synchronized (this)&#123; System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125; &#125;&#125;class TestSynLockDemo&#123; public static void main(String[] args) &#123; Thread t1 = new SynLockDemo(); Thread t2 = new SynLockDemo(); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; 领悟到对象锁和类锁之间的区别就ok啦. 1234567891011121314151617181920212223public class SynLock2Demo implements Runnable&#123; private Object obj = new Object(); // 要记得初始化 @Override public void run() &#123; add(); &#125; private void add() &#123; synchronized (obj)&#123; // 这个obj在这里的含义和this是一样哒 System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125; &#125;&#125; synchronized特性 原子性 原子性代表一个操作或者多个操作,要么执行全部并且执行的过程中不能被任何因素打断,要么就不执行. 123456比如i++;i+=2;i=i+1;这些操作都不是原子操作,它们要经过[读取,计算,赋值]这三个操作.三个步骤中的任何一个步骤在执行的时候都可能被其他线程打断.int x = 10; // 这就是一个原子操作double x = 3.0d; // 这不是原子操作long x = 20L; // 这也不是原子操作. 可见性 多个线程访问同一个资源的时候,这个资源的状态信息等对其他线程都是可见的. 线程在遇到synchronized时,会清空本地工作内存,然后重新去主存拷贝最新的值. 有序性 在同一个时刻,只能由一个线程进入. 可重入性. 当一个线程申请到锁资源并且执行完毕之后释放,仍然有机会再去申请曾经申请过的锁资源. JMMJMM - Java内存模型(Java memory model) JMM规定所有的变量都存储在主内存中,包括实例变量[类中的非静态属性],静态变量,但是不包括局部变量和方法参数. 每个线程都有自己的工作内存,线程的工作内存保存了该线程用到的变量和主内存的副本拷贝,线程对变量的操作都在工作内存中进行.线程不能直接读写主内存中的变量 不同的线程之间也无法访问对方工作内存中的变量,线程直接变量值的传递需要通过主内存来完成. 原子性实例1234567891011121314151617181920212223public class PlusNoAtomicity implements Runnable&#123; // 定义一个属性 int i = 0; @Override public void run() &#123; for (int j = 0; j &lt; 100 ; j++) &#123; add(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; public void add()&#123; i++; &#125;&#125;class TestPlusNoAtomicity&#123; public static void main(String[] args) &#123; Runnable r = new PlusNoAtomicity(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); &#125;&#125; 12345运行结果:Thread-0:200Thread-1:200因为自加100次很快,两个线程都在一瞬间完成了,导致结果两个都是200. 如果将循环的次数修改为十万次 1234567@Override public void run() &#123; for (int j = 0; j &lt; 10000 ; j++) &#123; add(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; 123456运行结果:Thread-0:14203Thread-1:15055Thread-0:13494Thread-1:13695 那么结果为什么不是两个二十万??? 这就要设计到JMM,前面也提到了,JMM规定所有的变量都存储在主内存中,因此i是存储在主内存中的,而每个线程都有自己的工作内存,存储了主内存的副本拷贝 ,对变量的操作都在工作内存中进行.所以在i++进行时,线程将i的副本保存进工作内存,在工作内存中进行自增,然后刷新会主存. 这幅图同样也解释了为什么两个的结果都不是二十万. i++过程 - 多线程安全问题重点前提: 线程是不能够操作对主存中的数据进行直接的操作的,必须是在本地的工作内存中去完成的.完成之后,刷回主存的 线程之间是隔离的.每个线程去执行方法的时候,都会在本地开辟一块区域[栈帧 - 线程栈],每个线程在本地工作内存中 对资源的修改,那么这个资源的信息,状态对其他线程都是不可见的. add方法没有使用synchronized进行修饰,导致在实现的过程中有线程会使用脏数据. 脏数据 - 本地工作内存中的变量的数据和主存中的变量的数据的值已经不一样,违背了”JMM中的缓存一致性”的原则. 1234567891011121314151617i++ 不是一个原子性操作的意思就是在它的中间的过程中,可以被被其他线程打断①T1线程从主存中拷贝变量的副本到本地的工作内存中 - read读取(i=0) =&gt; T1 `T1线程让出了CPU执行权力.T0线程获取执行权力 - 从主存拷贝变量的副本(i=0)` =&gt; T0 `T0线程直接进行了计算,赋值,重新刷回到主存[i=1]` =&gt; T0 `T0线程刷回i到主存之后,此时主存的i=1,T0线程让出cpu执行权` ②在本地的工作内存中对i进行计算,计算完之后,再把自增的数据重新赋值个i =&gt; T1 `T1线程继续执行②,由于之前T1线程并没有执行结束,因此它不会从已经更新的主存中重新去拷贝i的副本` `所以T1线程继续执行的时候,使用的仍然是自己本地工作内存中的那个变量i[read下来的,初始值仍然是0]` `T1线程i = i + 1,刷回到主存[i=1]` `因为线程是隔离的,T1线程它是不知道T0线程对i进行了修改的.`③把最终的本地工作内存中的i的计算结果 - [当前线程执行完毕之后]刷回到主存中[时间是不固定的.但是当前线程执行完毕之后,它肯定会刷回到主存] =&gt; T1 [如果是单线程环境下,当T1线程把最终的结果刷回到主存之后,第二次再次调用add()方法的时候,那么T1线程仍然会再次从主存中 获取变量的副本,重复执行①②③) 隐约的信号:如果线程T1没有执行结束,那么它是不会从主存中重新拉取值的 看到的效果是 - 俩个线程都同时操作了i++,但是主存中的i实际上是只加了1次的结果. 如何解决问题使用synchronized对i++所在的方法进行修饰 当某个对象调用add方法,得到锁资源的时候,会先清空本地工作内存.清空的目的是为了让后面的操作重新从主存中拷贝最新的值. 123public synchronized void add()&#123; i++;&#125; 1234运行结果:Thread-0:18895Thread-1:20000可能线程0走的比较快线程1还没走完线程0就走完了,所以结果不到20000 123运行结果:Thread-0:20000Thread-1:20000 因为add方法进行了同步 - synchronized进行了修饰了.在某个时刻,只能由一个线程[获得锁资源的]进去执行 [读取,计算,赋值] - 三个步骤中.其他线程是不可能介入的.因为没有获取锁资源的线程都在外部进行同步阻塞. 当正在执行的线程释放锁资源之前,它会将本地工作内存中的改变刷回到主存. 工作内存的改变什么时候同步到主存单线程单线程 - 单线程执行方法结束的时候 多线程 线程释放锁资源的时候 线程切换的时候 可见性实例12345678910111213141516171819202122232425262728293031323334/** * @Author liuWenXiu * @Date 2021/8/10 14:12 * @description */public class VisibilityDemo &#123; private int x; // 写 public void writeX()&#123; x = 5; &#125; public void readX()&#123; while (x!=5)&#123; &#125; if(x == 5) System.out.println(&quot;----stopped----&quot;); &#125;&#125;class TestVisibilityDemo&#123; public static void main(String[] args) &#123; VisibilityDemo vb = new VisibilityDemo(); // 创建一个写线程 Thread t1 = new Thread(()-&gt;&#123; vb.writeX(); &#125;); Thread t2 = new Thread(() -&gt; &#123; vb.readX(); &#125;); &#125;&#125; 先写再读12345678t1.start();// 睡一会try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;t2.start(); 12运行结果:----stopped---- 写线程运行时拷贝主存中的x,默认初值为0,然后将x赋值为5,并且刷新回主存,过了一秒以后读线程再运行,拷贝主存中的x,[一秒钟的时间写线程早就运行完了],x的值就为5,所以打印stopped. 先读再写首先我们需要知道一个道理,多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是不可见的. 12345678910 //如果先读后写t2.start();//读try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;t1.start();//写 所以在本实例中,如果先启动读线程,读线程拷贝主存中的数据x=0,然后一直在死循环中,等待了一秒钟以后,写线程启动,拷贝主存中的x=0,将其赋值为5并刷新回主存,此时主存中的x=5,但是读线程并不知道,它也不会从主存中重新拷贝值,一直停留在死循环中. 1234567public void readX()&#123; while (x!=5)&#123; System.out.println(&quot;&quot;); &#125; if(x == 5) System.out.println(&quot;----stopped----&quot;);&#125; 123456public void println(String x) &#123; synchronized (this) &#123; print(x); newLine(); &#125; &#125; 如果readX方法如上所示,结果又会不同.因为println方法中使用到了锁,对象在获得锁资源的时候,会先清空本地工作内存,强制从主存中去拷贝已经更新的变量. 所以在这个实例中,每次打印数据后读线程都会清空本地缓存,从主存中拷贝更新后的变量,所以当写线程把主存中变量的值修改以后,读线程能够知道变量已经改变了,从而退出死循环. 如何解决问题 使用synchronized来保证可见性. 使用volatile来修饰实例变量 强制让程序遵守”缓存一致性”协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去. volatile关键字的作用 保证可见性 volatile是不会造成阻塞的. 禁止指令重排 12345678910Student s = new Student();指令重排 - JVM指令优化之后①给对象分配空间②空间地址立即给s,s保存到栈③对象的初始化volatile Student s = new Student();//禁止指令重排①给对象分配空间③对象的初始化②空间地址立即给s,s保存到栈 不能保证原子性 volatile和synchronized的区别 volatile只能作用于变量,而synchronized可以作用于变量,方法和代码块. 多线程访问volatile不会发射是那个阻塞,而synchronized可能发生阻塞[锁]. volatile能够保证数据的可见性,但不能保证原子性.而synchronized关键字都可以保证 volatile关键字主要解决的是多个线程之间的可见性,而synchronized关键字保证的是多个线程访问资源的同步性. volatile可以禁止jvm指令重排,而synchronized不能. synchronized的底层原理了解即可. 每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。 进程和线程的区别 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 进程与进程之间是独立的. 同一个进程内部的多个线程是可以共享进程资源的. 资源拥有：同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的。 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。 -进程重量级的单位(创建,切换,销毁 - 费时) -线程轻量级的单位(创建,切换,销毁 - 比较高) 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程是处理器调度的基本单位，但是进程不是。 两者均可并发执行。 一个线程只属于一个进程，但是一个进程可以拥有多个线程，但至少一个线程资源分配给进程，同一进程中所有线程共享该进程的所有资源。 线程生命周期 New：新建状态/瞬态，当线程对象创立后，即进入了新建状态，如：Thread t = new MyThread() Runnable：就绪状态，当调用线程对象的start()方法（t.start()），线程就进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待cpu调度执行，并不是说执行了t.start()此线程立即就会执行 Running：运行状态，当cpu开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。 Blocked：阻塞状态，处于运行状态中的线程由于某种原因，暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态 Dead：死亡状态(结束状态)，线程执行完了或者因异常退出了run()方法，该线程结束生命周期 （1）就绪状态是进入到运行状态的唯一入口（2）线程想要进入到运行状态执行，首先必须处于就绪状态中（3）根据阻塞产生的原因，阻塞状态又可以分为三种： 【1】等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态 【2】同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态 【3】其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态.之前获取键盘输入. 守护线程GC - 运行在后台的 - 负责回收垃圾对象 核心: **线程结束的时候不需要关心后台的守护线程是否也运行结束,线程是不会等后台的守护线程全部运行结束才结束.**当后台只有守护线程在执行的时候,就可以认为线程可以结束了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day15.thread02;/** * @Author liuWenXiu * @Date 2021/8/11 9:12 * @description 守护线程的使用 */public class DaemonDemo &#123; public static void main(String[] args) &#123; Thread t1 = new T1(); Thread t2 = new T2(); // 将打印数字的线程设置成后台守护线程 // 如果后台只剩下守护线程在执行就可以结束了 // 不需要等待所有的守护线程运行结束才结束 t2.setDaemon(true); t1.start(); t2.start(); &#125;&#125;class T1 extends Thread&#123; @Override public void run() &#123; for (int i = 65; i &lt;=90 ; i++) &#123; System.out.println((char)i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class T2 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Lock - 同步代码Lock是一个接口,下面有很多的实现类. lock需要手动申请锁(对象锁) lock是锁代码块 lock出现异常的时候是不会主动释放资源的. Lock提供的方法 void lock(); // 手动上锁 boolean tryLock(); // 如果获取锁失败,则直接返回false,如果获取锁成功,返回true boolean tryLock(long time,TimeUnit unit); // 如果在尝试获取锁的过程中等待超过了time,就会导致获取锁失败. 面试题 - synchronized和Lock的区别synchronized和lock都属于独占锁 实现层面不一样.synchronized是Java关键字,jvm层面实现加锁和释放锁.Lock是一个接口,在代码层面实现加锁和释放锁. 是否自动释放锁.synchronized在线程代码执行完或出现异常时自动释放锁.Lock不会自动释放锁,需要在finally{}代码块中显式地释放锁. 是否一直等待.synchronized会导致线程拿不到锁一直等等待.Lock可以设置尝试获取锁或者获取锁失败一定时间超时. 获取锁成功是否可知.synchronized无法得知是否获取锁成功.Lock可以通过tryLock获得加锁是否能够. 功能复杂性.synchronized加锁可重入,不可中断,非公平.Lock可重入,可中断,可公平和不公平,细分读写锁提高效率. 读锁 - java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock - 共享锁 - 允许多个线程去读. 写锁 - java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock - 互斥锁 - 一次只能由一个线程去写. 123不可中断synchronized - A线程竞争到锁资源 - 顺利进入同步代码块执行 - 只要A资源不释放这个锁资源.B线程只能在外面等待.可中断Lock -&gt; A线程顺利执行同步代码,B线程如果tryLock方法话,那么B线程不断尝试获取锁资源.如果设置了超时等待时间.B线程等太久.已经超过了设置的时间.B线程将不会再傻乎乎继续等待下去[可中断],B线程就有可能去干别的事情了. 线程的通信重要方法synchronized wait(); Object类中的方法,必须放在循环体和同步代码块中,执行该方法的线程会释放锁,然后进入线程等待池等待再次被唤醒,再放入锁池中竞争同步锁. notify(); Object类中的方法,随机唤醒一个线程. notifyAll(); Object类中的方法,唤醒所有线程 lock Condition new Condition(); 创建等待度列 void await(); 当前线程会进入到阻塞状态,必须要等其他线程唤醒. void signal(); 哪个线程的Contion对象去调用signal()方法,哪个线程就会被唤醒. 生产者消费者问题单个生产者和单个消费者 生产者线程 - 负责生产产品-box[把产品放入到box] 消费者线程 - 负责消费产品-box[从box中去获取产品] 通信的流程 俩条线程并发执行 - 调用的是不同的方法 假设消费者线程先执行 - 直接从box中去获取产品.但是此时此刻box中尚无产品. 消费者线程就需要调用wait方法 - 自己会释放锁资源,消费者线程进入到线程等待池[意味着当前的线程会进入到等待阻塞的状态] -getter方法 假设生产者线程 - setter方法 先执行了.发现box中没有产品的,顺利放入一个产品到box中的.但是放完之后.生产者还是会继续执行.继续执行的时候又会调用 setter方法.这个时候,不能允许生产者线程连续再放 - 就得调用生产者线程的wait方法,同时还需要唤醒消费者线程过来消费. 消费者线程一旦消费成功,它还是会继续执行自己的getter方法.发现box中没有了.回到第2个步骤 demo1 - synchronized实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package tech.aistar.day15.thread02;/** * @Author liuWenXiu * @Date 2021/8/11 10:35 * @description */public class Communication &#123; public static void main(String[] args) &#123; Box box = new Box(); Thread product = new ProductThread(box); Thread customer = new CustomerThread(box); product.setName(&quot;生产者&quot;); customer.setName(&quot;消费者&quot;); product.start(); customer.start(); &#125;&#125;class Box&#123; private int content; //产品 private boolean flag; public synchronized int getContent() &#123; if(!flag)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; flag = false; notifyAll(); return content; &#125; public synchronized void setContent(int content) &#123; if(flag)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; flag = true; this.content = content; notifyAll(); &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125;&#125;class ProductThread extends Thread&#123; private Box box; private int i = 0; //产品 public ProductThread(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; while (true)&#123; System.out.println(Thread.currentThread().getName()+&quot;=&gt;放&quot;+(++i)+&quot;个&quot;); box.setContent(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class CustomerThread extends Thread&#123; private Box box; public CustomerThread(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; while (true)&#123; System.out.println(Thread.currentThread().getName()+&quot;=&gt;取&quot;+box.getContent()+&quot;个&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; demo2 - lock实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package tech.aistar.day15.homework_0811;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author liuWenXiu * @Date 2021/8/11 18:44 * @description 生产者消费者问题 - 利用Lock和Condition解决 * 假设盒子能容纳最大产品数量为10,生产者每次随机生产1-10个产品,并且只有在盒子为空时生产者才能生产产品. * 消费者只能在产品数目不为0时进行消费,并且必须有多少买多少. */public class ProducerAndCustomer &#123; private Lock lock = new ReentrantLock(); // 有几个线程就创建几个Condition private Condition producer = lock.newCondition(); private Condition consumer = lock.newCondition(); private int content; //盒子里的产品个数 // 生产方法 public void produce()&#123; while (true)&#123; try &#123; lock.lock(); // 生产者只有在盒子中产品数目等于0时进行生产 // 如果盒子里的数目不为0,那么让生产者进入阻塞状态 if(content!=0)&#123; producer.await(); &#125; // 否则进行产品的生产 content = (int) (Math.random()*10 + 1); System.out.println(&quot;生产者生产了&quot;+content+&quot;个产品&quot;); Thread.sleep(1000); // 唤醒消费者线程 consumer.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; // 消费方法 public void consume()&#123; while (true)&#123; try &#123; lock.lock(); // 如果盒子里的数目小于等于0表示盒子空了,消费者不能再消费啦 if(content==0)&#123; consumer.await(); &#125; // 消费 System.out.println(&quot;消费者消费了&quot;+content+&quot;个产品&quot;); content = 0; Thread.sleep(1000); // 唤醒生产者线程 producer.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125;class TestProducerAndCustomer&#123; public static void main(String[] args) &#123; ProducerAndCustomer pc = new ProducerAndCustomer(); Thread t1 = new Thread(()-&gt;&#123; pc.produce(); &#125;); Thread t2 = new Thread(()-&gt;&#123; pc.consume(); &#125;); t1.setName(&quot;生产者&quot;); t2.setName(&quot;消费者&quot;); t1.start(); t2.start(); &#125;&#125; 三个线程循环打印abc ABC 123打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package tech.aistar.day15.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author liuWenXiu * @Date 2021/8/11 14:43 * @description * 同程公司笔试题 - 循环打印abc ABC 123 abc ABC 123 * * * * 打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程 * * * * 使用Lock中的同步队列 - 解决方案 - **唤醒指定的等待队列上的某个线程.** */public class CommunicationLockDemo &#123; private Lock lock = new ReentrantLock(); // 有几个线程就创建几个队列 // 打印小写字母的队列 private Condition c1 = lock.newCondition(); // 打印大写字母的队列 private Condition c2 = lock.newCondition(); // 打印数字的队列 private Condition c3 = lock.newCondition(); // 定义一个标记 private int count = 0; // 打印小写字母的方法 public void printLower()&#123; while (true)&#123; try &#123; lock.lock(); // 首先判断状态 // 如果count=0则运行,否则进入阻塞状态 if(count!=0)&#123; c1.await(); &#125; // 否则运行 打印小写的abc System.out.print(&quot;abc&quot;); // 打完后等一秒 Thread.sleep(1000); // 修改count的值 count = 1; // 唤醒打印大写字母的线程 c2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭锁资源 lock.unlock(); &#125; &#125; &#125; // 打印大写字母的方法 public void printUpper()&#123; while (true)&#123; try &#123; // 首先判断 count = 1时打印大写字母 lock.lock(); if(count!=1)&#123; c2.await(); &#125; // 否则打印 System.out.print(&quot;ABC&quot;); Thread.sleep(1000); count = 2; c3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public void printNum()&#123; while (true)&#123; try &#123; lock.lock(); if(count!=2)&#123; c3.await(); &#125; System.out.print(123); Thread.sleep(1000); count = 0; c1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; CommunicationLockDemo demo = new CommunicationLockDemo(); Thread t1 = new Thread(()-&gt;&#123; demo.printLower(); &#125;); Thread t2 = new Thread(()-&gt;&#123; demo.printUpper(); &#125;); Thread t3 = new Thread(()-&gt;&#123; demo.printNum(); &#125;); t1.start(); t2.start(); t3.start(); &#125;&#125; 面试题 - 常用方法区别wait方法和sleep方法的区别 wait方法一定是出现字synchronized同步代码内部的,而sleep是可以放在同步代码中也可以放在不是同步代码的代码中. 执行wait方法的线程会释放锁并释放cpu,而执行sleep方法只会释放cpu不会释放锁. - 核心区别 sleep方法线程会自动进入到其他阻塞状态,一旦睡眠结束,会自动从阻塞状态恢复到可就绪态,等待cpu的到来,然后到运行态.wait方法线程会自动进入到等待阻塞状态,自己不会主动醒过来,必须是其他线程调用notify或者notifyAll,然后会进入到锁定状态,再次尝试去获取锁. 官方答案 sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。 yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。 wait：Object类的方法(notify()、notifyAll() 也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁 join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 join方法的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day15.thread02;/** * @Author liuWenXiu * @Date 2021/8/11 9:33 * @description */public class JoinDemo &#123; public static void main(String[] args) &#123; Thread mother = new Mother(); mother.start(); &#125;&#125;class Mother extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;妈妈在烧饭&quot;); System.out.println(&quot;妈妈发现酱油没啦..&quot;); System.out.println(&quot;妈妈让儿子去打酱油&quot;); Thread son = new Son(); son.start(); try &#123; son.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;妈妈继续烧饭!!&quot;); &#125;&#125;class Son extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;儿子去打酱油啦&quot;); for (int i = 3; i &gt; 0 ; i--) &#123; System.out.println(&quot;还有&quot;+i+&quot;分钟儿子就回来啦&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;儿子回来啦&quot;); &#125;&#125; 死锁“哲学家就餐问题” 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程. 死锁产生的条件 互斥条件: 指进程对所分配到的资源进行排他性使用,即在一段时间内某资源只由一个进程占用.如果此时还有其他进程请求资源,则请求者只能等待,直到占有资源的进程使用完毕释放. 请求和保护条件: 指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已经被其他进程占有,此时请求进程阻塞,但又对自己已经获得的其他资源保持不放. 不剥夺条件: 指进程已获得的资源,在未使用完之前,不能被剥夺,只能使用完时自己释放. 环路等待条件: 发生死锁时,必然存在一个进程–资源的环形链,即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 只要打破四个条件的一个,就可以防止死锁. 死锁是不可避免,但是需要写程序的破坏四个条件中的一个. 静态域容易产生死锁. 四种常见的线程池线程池的返回值ExecutorService简介 ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程 Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务 Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。 Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行 Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。","categories":[],"tags":[{"name":"进程","slug":"进程","permalink":"http://beautifulboyy/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://beautifulboyy/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"泛型","slug":"java12","date":"2021-08-06T08:11:53.000Z","updated":"2021-08-09T14:49:02.992Z","comments":true,"path":"2021/08/06/java12/","link":"","permalink":"http://beautifulboyy/2021/08/06/java12/","excerpt":"","text":"泛型Generic定义 java在1.5之后加入了泛型的概念.泛型,即”参数化类型”. 泛型的本质是为了参数化类型(将类型参数化传递),在不创建新的类型的情况下,通过泛型指定的不同类型来控制形参具体限制的类型. 也就是说在泛型使用过程中,操作的数据类型被指定为一个参数. 这种参数类型可以用在类,接口和方法中,分别被称为泛型类,泛型接口,泛型方法. 泛型只能是对象类型.可以是自定义对象类型比如User,Student等,也可以是内置对象类型如String,Integer,Character等[一定是包装类型]. 泛型符号 符号 含义 E 元素 K,V 键值对 N 数字 T 类型 ? 通配符 集合为例子理解泛型的好处123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day14;import java.util.ArrayList;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/7 13:57 * @description 泛型的好处 */public class GenericDemo &#123; public static void main(String[] args) &#123; // 1. jdk5.0之前创建集合的方式 List list = new ArrayList(); // 1.1元素的添加 // 集合可以添加任意对象类型元素 list.add(Object o) list.add(10); // 之类添加的不是基本类型10,而是java.lang.Integer list.add(&quot;qwq&quot;); list.add(2000L); // 1.2元素的获取 // 获取元素时必须要进行类型的强制转换 list.get(index)返回类型为Object // 过程中就有可能转换失败,java.lang.ClassCastException类型转换异常 //String temp = (String) list.get(0); //error Integer i = (Integer) list.get(0); String s = (String) list.get(1); // 2.jdk5.0~jdk7.0创建集合的方法 List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); // 2.1元素的添加 // 集合只能添加指定对象类型元素 list.add(Integer i) list1.add(10); list1.add(20); // 2.2元素的获取 // 不需要进行强制类型转换 list.get(index)返回类型为Integer Integer i1 = list1.get(0); // 3.jdk7.0以后创建集合的方式 - 与第二种方式很相近 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list2.add(&quot;ok&quot;); list2.add(&quot;java&quot;); String s1 = list2.get(0); &#125;&#125; jdk5.0之前:集合可以添加任意对象类型元素 [jdk5.0,jkd7.0):采用了类型安全的集合框架,在编译期间确定了集合中添加的数据类型,在添加元素时只能添加指定类型的元素,获取元素时也不需要进行强制类型转换 jdk7.0:泛型只有在编译期间的概念,在运行期间将会被擦除.所以删除了ArrayList尖括号的类型. 泛型的好处 加入了泛型之后,可以保证代码的健壮性 加入了泛型之后,取值时不需要进行强制类型转换 加入了泛型之后,代码变得更加简洁. 泛型没有多态12345多态的语法 - 多态的引用面向父类编程/面向借口哦编程编译时类型 对象名 = new 运行时类型();父类 对象 = new 子类();接口 对象 = new 实现类(); Class实例12345Book book1 = new Book();System.out.println(book1.getClass()); //class tech.aistar.review.BookBook book2 = new Book();System.out.println(book2.getClass()); //class tech.aistar.review.BookSystem.out.println(book1.getClass() == book2.getClass()); //true 一个类无论被实例化多少次,它在JVM中的Class对象/实例永远都只有一个. 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day14;import tech.aistar.review.Book;import java.util.ArrayList;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/7 14:13 * @description 泛型只有编译期间的概念, 在运行期间将会被擦除. * * */public class GenericRuntimeDemo &#123; public static void main(String[] args) &#123; // 面向父类编程 // java.lang.Integer extends java.lang.Number // java.lang.Long extends java.lang.Number Number n1 = new Integer(10); Number n2 = new Long(20L); // jdk5.0~jdk7.0 //List&lt;Number&gt; list = new ArrayList&lt;Integer&gt;(); //error // 这样写编译会报错,说明泛型是没有多态的,不能用父类去接子类. // 原因:泛型只有编译期间的概念,在运行期间将会被擦除 List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); List&lt;Long&gt; list2 = new ArrayList&lt;Long&gt;(); // 获取对象的运行时类型 - Class实例 Class&lt;?&gt; c1 = list1.getClass(); Class&lt;?&gt; c2 = list2.getClass(); System.out.println(c1 == c2); //true System.out.println(c1); //class java.util.ArrayList System.out.println(c2); //class java.util.ArrayList // 由此可见,获取运行时类型始终都是ArrayList,和&lt;Integer&gt;,&lt;Long&gt;是无关的. // 所以泛型仅仅是在编译期间有效,在运行期间是无效的. &#125;&#125; 泛型只有编译期间的概念 - 泛型仅仅是在编译期间是有效的. 在编译期间一旦确定了泛型,那么在编译期间就只能向这个容器中添加对应类型的数据,否则编译报错. 运行期间将会被擦除 - 泛型是不存在运行时类型的. 泛型通配符 ? extends T - 只能是T类型或者T类型的子类 - 指定类型的上限[常用] ? super T - 只能是T类型或者T类型的父类 - 指定类型的下限 小测试1234567891011List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();list1.add(1);list1.add(2);list1.add(3);list1.add(4);List&lt;Long&gt; list2 = new ArrayList&lt;&gt;();list2.add(10L);list2.add(20L);list2.add(30L);list2.add(40L); 定义一个方法,打印上面两种集合 1234567public static void print(List&lt;? extends Number&gt; list)&#123; Iterator&lt;? extends Number&gt; iter = list.iterator(); while(iter.hasNext())&#123; Number n = iter.next(); System.out.println(n); &#125;&#125; 注意一下:自己写的时候hasNext忘记加括号了,这是调用的方法,要记得! 泛型类定义类的时候,给定一个泛型,真正使用的时候再确定具体的类型. 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.day14.generic;/** * @Author liuWenXiu * @Date 2021/8/9 21:10 * @description 泛型类 */public class GenericClassDemo&lt;T&gt; &#123; // 定义一个属性 private T type; public GenericClassDemo() &#123; &#125; // 将类型参数化传递 public GenericClassDemo(T type) &#123; this.type = type; &#125; // 泛型方法 public T getType() &#123; return type; &#125; public void setType(T type) &#123; this.type = type; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;GenericClassDemo&#123;&quot;); sb.append(&quot;type=&quot;).append(type); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 1234567891011public class TestGenericClassDemo &#123; public static void main(String[] args) &#123; GenericClassDemo&lt;String&gt; g1 = new GenericClassDemo&lt;&gt;(&quot;haya&quot;); System.out.println(g1); GenericClassDemo&lt;Integer&gt; g2 = new GenericClassDemo&lt;&gt;(); g2.setType(12); System.out.println(g2); &#125;&#125; 泛型类的继承 子类继承父类时不指定具体的类型 子类继承父类时指定具体的类型 12345678910111213141516// 泛型父类class Sup&lt;T&gt;&#123; &#125;// 不指定具体类型的子类class Sub01&lt;T&gt; extends Sup&lt;T&gt;&#123; &#125;// 指定具体类型的子类class Sub02&lt;Product&gt; extends Sup&lt;Product&gt;&#123; &#125;// 指定具体类型的子类可以省略前面的&lt;&gt;class Sub02 extends Sup&lt;Product&gt;&#123; &#125; 泛型方法如果泛型加在类上面,对整个类内部有泛型的地方都会有影响. 可能某个类中就那么几个方法需要使用到泛型,没有必要定义泛型类,只需要定义泛型方法即可 如果很多个方法都使用到了泛型,就有必要定义一个泛型类. 1234567891011121314151617181920212223242526272829303132package tech.aistar.day14.generic;/** * @Author liuWenXiu * @Date 2021/8/9 21:16 * @description 泛型方法 */public class GenericMethodDemo &#123; // 非静态方法 - 无返回类型 public &lt;T&gt; void test01(T t)&#123; System.out.println(&quot;test01...&quot;+t); &#125; // 非静态方法 - 有返回类型 public &lt;T&gt; T test02(T t)&#123; System.out.println(&quot;test02...&quot; + t); return t; &#125; // 静态方法 - 无返回类型 public static&lt;T&gt; void test03(T t)&#123; System.out.println(&quot;test03...&quot;+t); &#125; // 静态方法 - 有返回类型 public static &lt;T&gt; T test04(T t)&#123; System.out.println(&quot;test04...&quot;+t); return t; &#125;&#125; 12345678910111213141516171819package tech.aistar.day14.generic;/** * @Author liuWenXiu * @Date 2021/8/9 21:17 * @description 泛型是类型安全的 */public class TestGenericMethodDemo &#123; public static void main(String[] args) &#123; // 根据传入的实参 确定方法的参数T GenericMethodDemo gm = new GenericMethodDemo(); gm.test01(&quot;ww&quot;); Integer i = gm.test02(12); // 这里已经知道了返回类型是Integer GenericMethodDemo.test03(&quot;hahaha&quot;); String s = GenericMethodDemo.test04(&quot;ok&quot;); &#125;&#125; 泛型的应用1234567ObjectInputStream/ObjectOuputStream - 操作对象类型的字节文件输入流和对象类型的文件字节输出流 Object in.readObject()/out.writeObject(Object obj);Jdk没有对readObject方法进行优化,每次调用完之后,进行强制类型的转换操作的. 思考 - 无论是保存/读取User对象或者Book对象 - 用一个方法去实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344package tech.aistar.util;import java.io.*;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/9 21:25 * @description */public class IOUtil &#123; /** * 利用泛型实现 保存任意对象 * @param list 保存的对象集合 * @param &lt;T&gt; 数据类型 * @param path 保存的地址 */ public static &lt;T&gt; void writeList(List&lt;T&gt; list,String path)&#123; try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; // 写入 out.writeObject(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static &lt;T&gt; List&lt;T&gt; readList(String path)&#123; List&lt;T&gt; list = null; try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) &#123; list = (List&lt;T&gt;) in.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return list; &#125;&#125; 1234567891011121314151617181920212223242526272829package tech.aistar.day14.generic;import jdk.internal.org.objectweb.asm.tree.InnerClassNode;import tech.aistar.day13.Book;import tech.aistar.util.IOUtil;import java.util.ArrayList;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/9 21:31 * @description 测试IOUtil中的方法 */public class TestIOUtil &#123; public static void main(String[] args) &#123; String path = &quot;src/tech/aistar/day14/generic/temp.txt&quot;; List&lt;Book&gt; books = new ArrayList&lt;&gt;(); books.add(new Book(1,&quot;1001&quot;,&quot;java&quot;,1000.d)); books.add(new Book(2,&quot;1002&quot;,&quot;php&quot;,200.d)); books.add(new Book(3,&quot;1003&quot;,&quot;c#&quot;,300.d)); List&lt;Book&gt; newList = IOUtil.readList(path); for (Book book : newList) &#123; System.out.println(book); &#125; &#125;&#125; 如果List newList = IOUtil.readList(path);这里的Book写成其他类型,就会报类型转换异常:java.lang.ClassCastException. 泛型的具体应用场景:在接口的制定中,很多接口具有相同的或者相似的功能. 12345678910111213141516171819//dao层接口 - data access object - 数据访问对象层 - 数据持久层//这一层专门和数据库[crud增删改查操作][文件_IO流操作]打交道// 老师的业务接口public interface ITeacherDao&#123; // 保存教师 void save(Teacher teacher);&#125;// 学生的业务接口public interface IStudentDao&#123; void save(Student student);&#125;//再去写俩个具体的实现类分别是TeacherDaoImpl.java以及StudentDaoImpl.java//这俩个实现类中 - 具体的代码,现阶段知识点 - 把单个java对象保存到文件中[IO流技术].//未来 - 肯定是要把java对象保存到db中 - 持久化的操作[java内存中的对象保存到DB中]//关于dao层 - java如何操作数据库 - 原生技术jdbc,dao层框架 - Hibernate框架以及mybatis框架//比如现在选取的是所谓的Hibernate框架 Hibernate框架把java的内存对象保存到DB中 123session.beginTransaction();//开启一个事务session.save(user);//具体的调用的是这个框架中的保存方法session.getTransaction().commit();//提交一个事务 TeacherDaoImpl伪代码 12345678public class TeacherDaoImpl implements ITeacherDao&#123; @Override public void save(Teacher teacher)&#123; session.beginTransaction();//开启一个事务 session.save(teacher);//具体的调用的是这个框架中的保存方法 session.getTransaction().commit();//提交一个事务 &#125;&#125; StudentDaoImpl伪代码 12345678public class StudentDaoImpl implements IStudentDao&#123; @Override public void save(Student student)&#123; session.beginTransaction();//开启一个事务 session.save(student);//具体的调用的是这个框架中的保存方法 session.getTransaction().commit();//提交一个事务 &#125;&#125; 发现在未来使用框架的时候,会发现很多步骤都是重复的.可能就涉及到具体的对象那一行的代码才会不一样而已. 关键代码:session.save(具体的java对象) 所以考虑抽象出一个顶级的业务类接口 - IBaseDao 12345public interface IBaseDao&lt;T&gt; &#123; //顶级的业务接口中应该存储的就是各个子接口中共性的方法 //这些方法都有共同点 - 大部分的代码是一样的,仅仅是操作的对象不一样而已. void save(T t);&#125; 实现类BaseDaoImpl.java 12345678910public class BaseDaoImpl&lt;T&gt; implements IBaseDao&lt;T&gt; &#123; @Override public void save(T t) &#123;// session.beginTransaction();//开启一个事务// session.save(t);//具体的调用的是这个框架中的保存方法// session.getTransaction().commit();//提交一个事务 System.out.println(t); &#125;&#125; IStudentDao继承了顶级的业务接口 123public interface IStudentDao extends IBaseDao&lt;Student&gt;&#123; void taoKe();//子接口中特有的方法&#125; ITeacherDao继承了顶级的业务接口 1234public interface ITeacherDao extends IBaseDao&lt;Teacher&gt;&#123; void buKe();//子接口中特有的方法&#125; 两个具体的实现类,需要继承顶级的BaseImpl.java,因为save方法已经实现好了,不需要再次实现. 12345678910111213public class StudentDaoImpl extends BaseDaoImpl&lt;Student&gt; implements IStudentDao&#123; @Override public void taoKe() &#123; System.out.println(&quot;逃课...&quot;); &#125;&#125;public class TeacherDaoImpl extends BaseDaoImpl&lt;Teacher&gt; implements ITeacherDao&#123; @Override public void buKe() &#123; System.out.println(&quot;补课...&quot;); &#125;&#125; 单元测试 123456789101112public class TestBase &#123; public static void main(String[] args) &#123; Student s = new Student(1,&quot;tom&quot;); IStudentDao studentDao = new StudentDaoImpl(); studentDao.save(s); Teacher teacher = new Teacher(1,&quot;仓考试&quot;); ITeacherDao teacherDao = new TeacherDaoImpl(); teacherDao.save(teacher); &#125;&#125;","categories":[],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://beautifulboyy/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"输入输出流","slug":"java11","date":"2021-08-05T00:31:12.000Z","updated":"2021-08-06T12:34:02.251Z","comments":true,"path":"2021/08/05/java11/","link":"","permalink":"http://beautifulboyy/2021/08/05/java11/","excerpt":"","text":"输入输出流Filejava.io.File[C] - File包含文件或者文件夹[目录directory] 作用:用来操作File本身的元信息,比如支持File的创建,删除,获取File的名称,获取File的路径信息,但它并不支持文件里面的内容的读写操作.[文件内容的读写操作是交给IO流去实现的] 支持本地File以及远程File的操作 File对象 - Java程序将磁盘上的文件加载内存中然后映射到File对象上 - File是内存中的磁盘上的映射. 构造方法 File(String path); // 利用一个路径来构建一个File实例,这个路径可以是文件的路径,也可以是文件夹的路径 路径分为相对路径和绝对路径: 绝对路径 - windows操作系统是以盘符号开头的路径,Linux/max以/开头的路径 相对路径 - 不是以盘符号或者/开头的路径 File(File parent, String child); //child是文件名 常用方法 boolean createNewFile(); // 创建一个文件[该方法需要抓取异常] String getAbsolutePath(); // 获取该File的绝对路径 String getName(); // 获取File的名称 String getParent(); // 获取该File的父目录的路径[如果创建时是绝对路径,那么就是绝对路径,如果是相对路径,那么就是相对路径] String getPath(); // 获取File的路径[如果创建时是绝对路径,那么就是绝对路径,如果是相对路径,那么就是相对路径] boolean exists(); // 判断File是否存在 boolean delete(); // 删除文件或者文件夹 6-1. 文件是否可以直接被删除 6-1-1. 如果是空目录 - 直接删除 6-1-2 如果是非空目录 - 删除失败 - [可以通过递归算法来实现删除非空目录] boolean mkdir(); // 创建单层次的目录,一次只能创建一个目录 boolean mkdirs(); // 既可以创建单层次的目录,又可以同时创建多个不存在的目录 boolean isFile(); // 判断File实例是否为文件实例 boolean isDirectory(); // 判断File实例是否为文件夹实例 String[] list(); // 返回的是File的名称,返回的是传入的路径下的第一层内容 File[] listFiles(); // 返回第一层的File实例 File[] listFiles(FilenameFilter filter); // 找到指定后缀/前缀满足条件的这么一个File实例 创建文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package tech.aistar.day13;import java.io.File;import java.io.IOException;/** * @Author liuWenXiu * @Date 2021/8/5 16:33 * @description FileDemo */public class FileDemo &#123; public static void main(String[] args) &#123; createNewFile(&quot;src/tech/aistar/day13/temp.txt&quot;); &#125; /** * 创建新的文件 * @param path */ public static void createNewFile(String path)&#123; // 1. 构建File实例 File f = new File(path); // 2.判断f是否存在 if(f.exists())&#123; // 如果存在则打印提示并退出方法 System.out.println(f+&quot;已经存在啦&quot;); return; &#125; // 3.实现新的创建 // 调用createNewFile方法,需要抓取异常,并且调用该方法会返回一个布尔类型的值,表示是否创建成功 try &#123; if(f.createNewFile())&#123; // 1. 获取文件名称 System.out.println(&quot;文件名称:&quot;+f.getName()); // 2.获取名称绝对路径 System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath()); // 3.获取创建时的路径 System.out.println(&quot;创建时路径:&quot;+f.getPath()); // 4.获取文件的父目录 System.out.println(&quot;文件父目录:&quot;+f.getParent()); // 5.获取文件 System.out.println(&quot;文件:&quot;+f); &#125;else &#123; System.out.println(&quot;创建失败&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456结果:文件名称:temp.txt文件绝对路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\temp.txt创建时路径:src\\tech\\aistar\\day13\\temp.txt文件父目录:src\\tech\\aistar\\day13文件:src\\tech\\aistar\\day13\\temp.txt 123public static void main(String[] args) &#123; createNewFile(&quot;E:\\\\cxstudy\\\\workspace\\\\j03_student02\\\\src\\\\tech\\\\aistar\\\\day13\\\\qaq.txt&quot;);&#125; 123456结果:文件名称:qaq.txt文件绝对路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt创建时路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt文件父目录:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13文件:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt 删除文件/文件夹1234567891011121314151617181920public static void deleteFileOrFolder(String path)&#123; // 1.构建File实例 File f = new File(path); // 2.判断file是否存在 if(!f.exists())&#123; // 如果不存在则打印提示不存在 System.out.println(f+&quot;不存在!&quot;); return; &#125; // 3.删除文件 // 如果是空目录是可以直接删除的,如果是费空目录,则删除失败 // 调用delete方法 同样会返回一个布尔类型的结果 if(f.delete())&#123; System.out.println(f+&quot;删除成功!&quot;); &#125;else &#123; System.out.println(f+&quot;删除失败!&quot;); &#125;&#125; 创建文件夹版本一1234567891011121314151617public static void createFolder(String path)&#123; // 1.构建file实例 File f = new File(path); // 2.判断文件夹是否存在 if(f.exists())&#123; // 如果存在则打印实体并返回 System.out.println(f+&quot;已经存在啦!&quot;); return; &#125; // 3.创建文件夹 // 调用mkdir方法,返回一个布尔类型的值 if(f.mkdir())&#123; System.out.println(f+&quot;创建成功!&quot;); &#125;else&#123; System.out.println(f+&quot;创建失败&quot;); &#125;&#125; 版本二123456789101112131415public static void createFolder2(String path)&#123; // 1.构建File实例 File f = new File(path); // 2.判断是否存在 if(f.exists())&#123; System.out.println(f+&quot;已经存在啦&quot;); return; &#125; // 3.创建 if(f.mkdirs())&#123; System.out.println(f+&quot;创建成功&quot;); &#125;else&#123; System.out.println(f+&quot;创建失败&quot;); &#125;&#125; mkdir和mkdirs之间的区别是,mkdir只能创建一个目录,而mkdirs可以创建嵌套的目录. list方法 - 返回文件名称123456789101112131415161718public static void lists(String path)&#123; // 1.构建实例 File file = new File(path); // 2.判断是否存在 if(!file.exists())&#123; // 如果不存在则打印提示并返回 System.out.println(file+&quot;不存在!&quot;); return; &#125; // 3.list获取名称 String[] infos = file.list(); if(null!=infos &amp;&amp; infos.length&gt;0)&#123; // 需要进行判断,因为不能确保这个有数据 for (String s : infos) &#123; System.out.println(s); &#125; &#125;&#125; listFiles - 返回File对象12345678910111213141516File[] files = file.listFiles();if(null!= files &amp;&amp; files.length&gt;0)&#123; // 确保数据的有效性 // 遍历输出 for (File file1 : files) &#123; // System.out.println(file1); if(file1.isDirectory())&#123; // 如果是目录则输出绝对路径 System.out.println(file1.getAbsolutePath()); &#125; if(file1.isFile())&#123; // 如果是文件则输出文件名 System.out.println(file1.getName()); &#125; &#125;&#125; listFiles(FilenameFilter filter) - 返回指定后缀的文件步骤: 首先创建一个类实现FilenameFilter接口,该接口是一个函数式接口. 12345678910111213141516171819public class SuffixFilenameFilter implements FilenameFilter &#123; private String suffix; public SuffixFilenameFilter(String suffix) &#123; this.suffix = suffix; &#125; @Override public boolean accept(File dir, String name) &#123; // 在什么情况下返回true什么情况下返回false // dir表示的是父类的绝对路径 // name表示的是文件名 //System.out.println(dir+&quot;:&quot;+name); if (name.endsWith(suffix)) return true; return false; &#125;&#125; 面向接口编程,形参是FilenameFilter可以传入它的实现类 12345File[] files = f.listFiles(new SuffixFilenameFilter(&quot;.txt&quot;));// 获取以.txt为结尾的文件并打印其名称for (File file : files) &#123; System.out.println(file.getName());&#125; 练习 传入一个目录,输出这个目录下的所有内容.如果是文件,直接输出名称.如果是文件夹,输出绝对路径 12345678910111213141516171819202122232425262728/** * 递归获取某个路径下的所有文件 * @param path */public static void listAllFiles(String path)&#123; // 1.创建实例 File f = new File(path); // 指定出口 - 递归的出口是如果该路径是文件,则打印文件名称并返回 if(f.isFile())&#123; System.out.println(f.getName()); return; &#125; // 如果不是文件,那么就是目录,需要获取该目录的所有Files File[] files = f.listFiles(); // 判断合法性 if(null != files &amp;&amp; files.length&gt;0)&#123; // 遍历files,判断如果是文件则打印文件名,如果是目录则打印目录绝对路径并且递归调用 for (File file : files) &#123; if(file.isFile())&#123; System.out.println(file.getName()); &#125;else if(file.isDirectory())&#123; System.out.println(file.getAbsolutePath()); listAllFiles(file.getAbsolutePath()); &#125; &#125; &#125;&#125; 删除一个非空目录[递归] IO流流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式[数据在传输之前,需要进行转换,转换成无结构的字节/字符序列]进行有序的输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入(Input)输出(Output) 流可以想象成是数据传输的管道. 磁盘中数据加载/读入到内存中 - 输入 java内存中数据写出到磁盘中 - 输出 流的分类 按照流的方向 - 输入流和输出流 按照流的读取单位 字节流 - 按照单个字节单个字节进行读写文本文件或者二进制文件 字符流 - 按照单个字符进行读写,只能操作文本字符文件 按照流的功能 节点流 - 又称为基础流,具备真正操作文件的能力 拓展流 - 又称为过滤流或包装流,拓展流只能让流的功能更加强大而已,拓展流脱离了节点流的话,是不允许的.拓展流的使用必须要建立在节点流的基础之上. 字节流字节输入流java.io.InputStream[C] - 字符输入流的顶级的抽象的父类 java.io.FileInputStream[C] - 文件字节输入流,操作文件的读操作. - 典型的节点流 java.io.ObjectInputStream[C] - 操作对象类型的字节输入流 - 典型的包装流 java.io.FilterInputStream[C] - 过滤流 java.io.BufferedInputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DateInputStream[C] - 操作基本数据类型的字节输入流 InputStream常用方法 void close(); // 关闭流,流本身就是一个对象[占内存 - 昂贵的资源] abstract int read(); // 单个字节单个字节的读取,如果读不到,返回-1 int read(byte[] b); // 从输入流读取一些字节数,并将它们存储到缓冲区b 字节输出流java.io.OutputStream[C] - 字节输出流的顶级的抽象父类 java.io.FileOutputStream[C] - 文件字节输出流,操作文件的写操作 - 典型的节点流 java.io.ObjectOutputStream[C] - 操作对象类型的字节输出流 - 典型的包装流 java.io.FilterOutputStream[C] - 过滤流 java.io.BufferedOutputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DataOutputStream[C] - 操作基本数据类型的字节输出流 OutputStream常用方法 void close(); //关闭流 abstract void write(int b); // 将制定的字节写入此输出流 void write(byte[] b,int off,int len); IO流的编程步骤 确定流 - 选什么流 确定源头和目标 - 从哪里读,写到哪里去 循环读取,循环写出 - while 关闭流 文件的拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/6 17:31 * @description IO - 读取文件中的内容 * 文件的拷贝 */public class HelloIO &#123; public static void main(String[] args) &#123; /* IO流步骤: 1. 选择流 2. 确定源头和目标 3. 循环读取/循环写出 4. 关闭流 */ // 面向父类编程 InputStream in = null; OutputStream out = null; try &#123; // 选择流,确定源头 in = new FileInputStream(&quot;src/tech/aistar/day13/FileDemo.java&quot;); out = new FileOutputStream(&quot;src/tech/aistar/day13/FileDemo_copy.java&quot;); int len = -1; //读取的内容 // 循环读取 while (true)&#123; len = in.read(); // 当没有内容的时候,就会返回-1 if(len == -1) break; //System.out.print((char) len); // 英文,符号,字母可以打印出来 但是中文打印的是乱码 // 因为中文在&quot;utf-8&quot;编码是三个字节 // 中文在&quot;gbk&quot;编码下是两个字节 // 进行拷贝 out.write(len); //out在写出去的时候会自动处理中文 &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null!=in)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(null!=out)&#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意一下最后要关闭流,并且在关闭流之前先判断流是否为null. 自定义缓冲数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/5 20:20 * @description 使用自定义缓冲数组读取数据 * 减少了java程序和磁盘的IO交互的次数 */public class ByteArrayDemo &#123; public static void main(String[] args) &#123; InputStream in = null; OutputStream out = null; try &#123; in = new FileInputStream(&quot;src/tech/aistar/day13/Book.java&quot;); // 创建缓冲数组 - 具体的大小要根据业务需求而定 byte[] buf = new byte[3*1024]; int len = -1; // 循环读取 while (true)&#123; len = in.read(buf); // 返回的是读取的字节数 if(len == -1) break; // 打印buf的结果 String str = new String(buf); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null!=in)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334结果:[只截取了部分结果]package tech.aistar.day13;import java.io.Serializable;/** * @Author liuWenXiu * @Date 2021/7/31 16:05 * @description */public class Book implements Serializable &#123; private int id; private String isbn; private String name; private double price; public Book() &#123; &#125; void Book()&#123; System.out.println(&quot;enheng?&quot;); &#125; public Book(int id, String isbn, String name, double price) &#123; this.id = id; this.isbn = isbn; this.name = name; this.price = price; &#125;Process finished with exit code 0 String s = new String(byte[] buf); String的构造方法 - 用byte数组构建字符串 结果证明缓冲数组buf中是有数据的. 文件的拷贝 - 利用自定义缓冲数组 - 关键代码1234567891011byte[] buf = new byte[3*1024];int len = -1;// 循环读取while (true)&#123; //读数据 len = in.read(buf); // 从输入流中读取一定数量的字节放到缓冲数组buf中,并且返回给len[当前总共读到的字节数] if(len == -1) break; // 写数据 out.write(buf,0,len);&#125; 缓冲流BufferedInputStream在它出来之前,可以单个单个字节进行读写操作,缺点是java程序和磁盘的IO交互比较频繁,性能就会低下. 采取了自定义的数组的方式,从磁盘文件中读取一定数量的字节先放入到缓冲数组中,然后再从缓冲数组中一次性写出道磁盘中,减少了java程序和磁盘IO的交互次数. - 性能提高 JDK中发现了这点,提供了缓冲流BufferedInputStream 123456789101112131415private static int DEFAULT_BUFFER_SIZE = 8192;//默认的容量8kbprotected volatile byte buf[];//内置的缓冲区public BufferedInputStream(InputStream in) &#123; this(in, DEFAULT_BUFFER_SIZE);&#125;public BufferedInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); &#125; buf = new byte[size];//初始化内置的缓冲区数组 - 大小是8kb&#125; 底层利用了”装饰器”思想,这个流属于包装流,拓展流,过滤流,本身不具备真正的文件的读写能力. 构建带缓冲功能的流,必须要以节点作为支持. 构建一个带缓冲功能的能够读取文件的字节输入流. 123BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;路径&quot;));BufferedOutputStream in = new BufferedOutputStream(new FileOutputStream(&quot;路径&quot;)); 缓冲数组BufferedInputStream本身已经在底层定义了8kb的字节数组,那么为什么程序中还自定义了一个3kb的字节数组[可以不定义,read()方法],自定义的byte[]和内置的byte[]各自的作用是什么? 内置的8kb的byte[] - 在一开始或者后面空闲的时候,由JVM去装载磁盘上的数据,提前放入到这个内置的byte[]中的. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/5 20:27 * @description 缓冲流 */public class BufferDemo &#123; public static void main(String[] args) &#123; BufferedInputStream in = null; BufferedOutputStream out = null;//out = new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy.gif&quot;); try &#123; in = new BufferedInputStream(new FileInputStream(&quot;src/tech/aistar/day13/fast.gif&quot;)); out = new BufferedOutputStream(new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy2.gif&quot;)); // 自定义一个byte[] byte[] buf = new byte[3*1024]; int len = -1; while (true)&#123; len = in.read(buf); if(len == -1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 读过程 当初始化好缓冲流之后,jvm会立刻读取磁盘中的数据到内置的缓冲数组中. 当程序循环读取到len = in.read(buf)时,程序是直接从内置的缓冲区[内置的缓冲数组中] 一旦内置的数组中的8kb数据被取完,那么jvm在空闲的时候,继续加载文件中下一个8kb的字节到内置的缓冲区. 语法糖jdk7.0提供的写法 - 把流的关闭交给jvm 12345try(资源对象的声明1;资源对象的声明2)&#123;&#125;catch(...)&#123; ...&#125; 123456789101112131415161718192021222324252627282930313233package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/5 20:37 * @description 语法糖 - jvm去关闭流 - 最终的版本 */public class StreamAutoCloseDemo &#123; public static void main(String[] args) &#123; try(BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;src/tech/aistar/day13/fast.gif&quot;)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy4.gif&quot;)))&#123; // 定义一个byte数组 byte[] buf = new byte[3*1024]; int len = -1; while (true)&#123; len = in.read(buf); if(len == -1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 证明语法糖是自动关闭对象12345678910111213141516public class ScannerDemo &#123; public static void main(String[] args) &#123; int result = get(); System.out.println(result); int x = get(); System.out.println(x); &#125; public static int get()&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.close(); return n; &#125;&#125; 12345public static int get()&#123; try(Scanner sc = new Scanner(System.in))&#123; return sc.nextInt(); &#125;&#125; 1234结果相同,都为如下:11Exception in thread &quot;main&quot; java.util.NoSuchElementException ObjectInputStream/ObjectOutputStream操作对象类型的字节输入流和字节输出流,拓展流,必须要以节点流作为支撑. 构建一个能够读写对象类型的文件字节输入流/输出流 12ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;path&quot;));ObjectOutputStream in = new ObjectOutputStream(new FileOutputStream(&quot;path&quot;)); 构建一个能够读写对象类型的并且带缓冲功能的文件字节输入流 12ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(&quot;path&quot;)));ObjectOutputStream in = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(&quot;path&quot;))); 利用”装饰器”思想,我们构建出功能更加强大的流,但是又不会对原来的流的结构产生任何影响. 序列化对象的序列化数据的持久化的过程,把内存中的java对象存储到磁盘的文件的过程. 注意点: 如果保存的是单个对象,这个对象的实体类必须要实现java.io.Serializable序列化接口. 如果没有实现这个接口,进行序列化的时候,抛出一个java.io.NotSerializableException不可被序列化的异常 保存的是数组/集合,那么集合中的每个对象对应的实体类也是需要实现这个序列化的接口. 关于追加写入,设置FileOutputStream(String path,boolean append);//append设置true,但是不支持分批次读取. 对象的反序列化java对象已经存储到磁盘的文件中,希望再从文件中将这些对象数据加载到内存中[映射到java对象上]. 字符流它和字节流的区别是读取的单位是不同的,字节流是按照单个字节进行读写操作. 字符流是按照单个字符的单位进行读写操作,字符流专门用来处理文本字符文件的,字节流用来处理文本文件或者二进制文件的. 字符输入流 java.io.Reader[C] - 顶级的字符输入流 - 抽象类 BufferedReader[C] - 带缓冲功能的字符流 123public BufferedReader(Reader in)&#123; this(in,defaultCharBufferSize);&#125; 提供的方法:String readLine(); // 每次读取文本文件一整行的数据 FileReader[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作 12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.day13;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * @Author liuWenXiu * @Date 2021/8/6 13:50 * @description 字符输入流 */public class ReaderHelloDemo &#123; public static void main(String[] args) &#123; /** * 步骤: * 1. 确定流 * 2. 确定源头 * 3. 循环读取 * 4. 关闭流 - 可以采用语法糖 - jvm自动关闭 */ try(BufferedReader in = new BufferedReader(new FileReader(&quot;src/tech/aistar/day13/book.java&quot;)))&#123; // 一行一行地读取 String line = null; // 循环读取 while (true)&#123; line = in.readLine(); // 读取一整行的数据,如果读取不到了,就返回null if(line == null) break; System.out.println(line); //注意这里不要忘记换行 &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字符输出流 java.io.Writer[C] - 顶级的字符输出流 - 抽象类 PrintWriter[C] - 自带缓存功能 构造方法: 12PrintWriter(Writer out);PrintWriter(Writer out,boolean autoFlush); 第二个参数是是否自动刷新缓存.缓存里面的数据被同步到磁盘上一般有两种情况,第一种是缓存中的数据满的时候回自动刷新,第二种是缓存中的数据还不足以撑满这个缓存但是使用了close方法或者flush方法手动刷新. FileWriter[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作的 构造方法: 12FileWriter(String path);FileWriter(String path,boolean append); 第二个参数代表的是是否追加写入.如果append设置为true,则可以支持分批次的写和分批次的读.而字节流不行,字节流可以追加写入,但不能读出来. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package tech.aistar.day13;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;/** * @Author liuWenXiu * @Date 2021/8/6 14:16 * @description 字符输出流 */public class WriteHelloDemo &#123; public static void main(String[] args) &#123; //test01(); test02(); &#125; /** * 构建一个不自动刷新,不能够追加写入的字符输出流 * 每次都会覆盖原来的文件,兵器而在第一次写入的时候,会自动创建这个文件 */ public static void test01()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;)))&#123; /** * 因为语法糖 - close操作 - 底层就是关闭流之前,会强制刷新缓存 */ /** * print方法以及println方法 * print方法写入之后,后面是没有加一个\\n * println方法写入之后,后面有一个\\n */ out.print(&quot;java很好玩&quot;); //out.println(&quot;python和好玩&quot;); //out.print(&quot;php很好玩!&quot;); // 把内存的数据持久化到硬盘的文件中 out.flush(); //可以不写,但是保险起见可以写一下 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 构建一个不能自动刷新,但是能够追加写入的字符流 */ public static void test02()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;,true)))&#123; out.print(&quot;hello&quot;); out.print(&quot;nice to meet&quot;); out.println(&quot;you&quot;); out.print(&quot;!&quot;); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void test03()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;,true),true))&#123; out.print(&quot;hello&quot;); out.print(&quot;nice to meet&quot;); out.println(&quot;you&quot;); out.print(&quot;!&quot;); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 文件的拷贝12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/6 14:58 * @description */public class FileCopyReaderDemo &#123; public static void main(String[] args) &#123; copyFile(&quot;src/tech/aistar/day13/hello.txt&quot;,&quot;src/tech/aistar/day13/hello_copy.txt&quot;); &#125; public static void copyFile(String src,String target)&#123; try(BufferedReader in = new BufferedReader(new FileReader(src)); PrintWriter out = new PrintWriter(new FileWriter(target),true))&#123; String line = null; while (true)&#123; line = in.readLine(); if(line == null) break; out.print(line); &#125; out.flush(); System.out.println(&quot;文件拷贝成功!&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结笔试 常见的字节流和字符流 装饰器的设计模式 难一点的知识点 - 同步[打电话]IO/异步[发短信]IO区别,阻塞IO/非阻塞IO区别 BufferedInputStream - 内置的缓冲数组 - 8kb 补充 - 破坏单例单例设计模式 - 保证在整个应用程序中,某个类的具体的实例永远只有1个 - 多线程下也是一个 - 双重锁检测 对象的序列化和反序列化可以破坏这种单例,如何破坏? 解决方案: 单例的第四个版本 - 枚举类型来实现单例模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.day13;import tech.aistar.design.singleton.version03.Singleton03;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/6 15:22 * @description 对象的序列化和反序列化会破坏单例 */public class ObjectSingletonDemo &#123; public static void main(String[] args) &#123; Singleton03 s1 = Singleton03.getInstance(); writeObject(s1,&quot;src/tech/aistar/day13/temp.txt&quot;); Singleton03 s2 = readObject(&quot;src/tech/aistar/day13/temp.txt&quot;); System.out.println(s1 == s2); &#125; public static void writeObject(Singleton03 s,String path)&#123; try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; // 写 out.writeObject(s); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Singleton03 readObject(String path)&#123; Singleton03 s = null; try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) &#123; // 读 s = (Singleton03) in.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://beautifulboyy/tags/IO%E6%B5%81/"},{"name":"序列化","slug":"序列化","permalink":"http://beautifulboyy/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"异常的处理","slug":"java10","date":"2021-08-04T06:20:14.000Z","updated":"2021-08-04T10:35:25.465Z","comments":true,"path":"2021/08/04/java10/","link":"","permalink":"http://beautifulboyy/2021/08/04/java10/","excerpt":"","text":"Throwablejava.lang.Throwable - 异常和错误的顶级的类 123456两个分支: 1. java.lang.Error - 错误 - 错误一旦发生,程序员是没有办法进行扭转的,不需要在代码中进行处理. 1-1. 子类VirtualMachineError虚拟机级别的错误 1-1-1. 子类java.lang.StackOverflowError 堆栈溢出 - 应用程序因为递归太深没有指定出口的时候. 1-1-2. 子类java.lang.OutOfMemoryError 内存泄露 - [GC垃圾回收机制 - 后台自动回收垃圾对象] 2. java.lang.Exception - 异常 - 程序在运行的过程中发生了不正常的情况 异常的分类运行时异常[RuntimeException]都是非运行时异常的子类[Exception] 运行时异常 - 未检测异常 顶级的父类java.lang.RuntimeException java.lang.NullPointerException - 空指针异常 12String str = null;System.out.println(str.length()); java.util.InputMismatchException - 输入不匹配异常 12Scanner sc = new Scanner(System.in);int n = sc.nextInt(); //只能获取整数,但是输入了一个字符串&quot;abc&quot; java.lang.ArithmeticException: - 分母为0 1System.out.println(10/0); java.lang.IllegalArgumentException - 非法参数异常 1SimpleDateFormat sdf = new SimpleDateFormat(&quot;ff&quot;); java.lang.IndexOutOfBoundsException - 下标越界异常 12List&lt;String&gt; list = new ArrayList&lt;&gt;();System.out.println(list.get(3)); 5.1 java.lang.StringIndexOutOfBoundsException - 字符串下标越界异常 12String str = &quot;faflfsfe&quot;;System.out.println(str.charAt(10)); 5.2 java.lang.ArrayIndexOutOfBoundsException - 数组下标越界异常 12int[] arr = &#123;1,3,5,7,9&#125;;System.out.println(arr[10]); java.util.NoSuchElementException - 不存在此元素 12LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;();System.out.println(list.getFirst()); java.lang.ClassCastException - 类型转换失败异常 12Animal c = new Cat(&quot;小喵&quot;,300.d);Dog dog = (Dog) c; 父类转换子类类型之前,推荐使用instanceof关键字进行类型的判断 非运行时异常 - 已检测异常 非运行时异常在编译时就能发现问题,需要用try…catch语句包裹. java.text.ParseException - 解析失败异常 - 字符串的模板和pattern不匹配 1234567SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);String str = &quot;2021-02-28&quot;;try &#123; Date date = sdf.parse(str);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125; InterruptedException - 中断异常 12345try &#123; Thread.sleep(3000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; java.lang.CloneNotSupportedException - 不支持clone 12345try &#123; Product copy = (Product) p1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 当Product实体类没有实现cloneable接口时就会出现这样的异常 java.io.IOException - IO流异常 4-1. java.io.EOFException - 已经读到文件的末尾了 4-2. java.io.FileNotFoundException - 文件找不到异常 java.sql.SQLException - SQL异常,比如程序中的sql语句写错了. 异常的处理方式 运行时异常不需要处理(也是可以处理的),只需要在编程的时候,注意一下验证/判断,稍微谨慎一点 非运行时异常,在编译期间就需要立即对其进行处理.处理的方式有两种,一种是积极处理,使用try…catch包围可能出现异常的语句,还有一种是消极处理. 积极处理方式 语法: try…catch…catch… 12345678try&#123; //code... //code...&#125;catch(异常类型1 e1)&#123; // code...&#125;cathc(异常类型2 e2)&#123; // code..&#125; 注意:上方的异常类型不能是下方的异常类型的父类 语法 - jdk7.0提供的新的写法 123456try&#123; //code... //code...&#125;catch(异常类型1 | 异常类型2)&#123; // code...&#125; 注意一下这里是非短路或. 语法 12345try&#123; //code..&#125;catch(异常总父类)&#123; //code..&#125; 消极处理比如在某个方法中某些代码出现了非运行时异常,那么在自己方法的内部”不着急”去积极处理.而是把这个异常抛出去了. 为了自己不处理,而是抛出去? - 因为这个方法有可能会被反复在其他地方调用 - 原则:谁调用,谁负责最终处理. 原则谨记 - 不要把异常抛给main方法,等同于把异常抛给jvm,等同于一旦出现异常,程序就会崩溃. 一个简单的实例 12345public void b() throws FileNotFoundException, ParseException &#123; InputStream in = new FileInputStream(&quot;d:\\\\sss&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date strDate = sdf.parse(&quot;2021-02-28&quot;);&#125; 直接在方法的签名[声明]上使用throws关键字+异常类型1,异常类型2 在方法体中使用throw+异常对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class NegativeHandlerException &#123; // 不要把异常抛给main方法 public static void main(String[] args) &#123; d(0); &#125; // c是最终的调用者 public void c()&#123; // 谁最终调用,谁最终进行处理 try &#123; a(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // 可以一直向上抛 public void a() throws FileNotFoundException&#123; try &#123; b(); //先处理一部分的异常,没有处理的可以继续抛出 &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; public void b() throws FileNotFoundException, ParseException &#123; InputStream in = new FileInputStream(&quot;d:\\\\sss&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date strDate = sdf.parse(&quot;2021-02-28&quot;); &#125; public static void d(int n)&#123; if(n==0)&#123; //System.out.println(&quot;异常...&quot;); /* throw + 运行时异常,不需要在方法的签名上抛出异常 因为本身运行时异常就不需要进行处理 */ throw new RuntimeException(&quot;发生异常啦&quot;); &#125; System.out.println(&quot;n:&quot;+n); &#125; public static void e(int n) throws FileNotFoundException &#123; if(n==0)&#123; /* throw + 非运行时异常 必须要在方法的签名上throws+非运行时异常类型 */ throw new FileNotFoundException(&quot;文件不存在!&quot;); &#125; System.out.println(&quot;n:&quot;+n); &#125;&#125; 自定义异常项目中存在一个exception包,专门定义自己的异常[大量的] jdk内置的异常不够用,不符合实际的业务场景 步骤 写一个异常类继承java.lang.Exception 提供父类的5个构造方法即可. 自定义异常的意义123System.out.println(&quot;余额小于0&quot;); throw new BalanceLtZeroException(&quot;余额小于0!&quot;); 场景:有的时候访问某些网站的时候 - 跳转到一个友好的页面 - 显示比如服务器正在维护/升级… 我们应该提供一个异常处理器 - 会监控软件程序在整个项目运行的过程中发生的一切异常. 一旦它发现了某个地方产生了异常,那么它就会对这些异常进行一个日志记录,然后再让程序跳转到一个友好的界面. SpringMVC/SpringBoot - 异常处理器 - 只认识异常. 相关笔试题1.笔试题1 123456789101112131415try&#123; // code // code return; // 结束整个方法&#125;catch(异常类型 e)&#123; // code&#125;catch(异常类型 e)&#123; // code&#125;finally&#123; // 无论是否出现异常,都会执行&#125;提问:假设try&#123;&#125;中没有任何异常发生,所有的code都会顺利执行.1.finally中的代码是否执行? - 一定会执行2.return语句是在finally块之前执行还是之后执行? - 之后执行 123456789String str = &quot;str&quot;;try &#123; System.out.println(str.length()); return;&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; System.out.println(&quot;-----end-----&quot;);&#125; 123结果:3-----end----- 2.笔试题2 123456789101112131415public class FinallyDemo &#123; public static void main(String[] args) &#123; System.out.println(test()); &#125; public static int test()&#123; int i = 0; // try可以直接和finally一起使用... try&#123; return ++i; &#125;finally &#123; ++i; System.out.println(&quot;i:&quot;+i); &#125; &#125;&#125; 结果: i:2 1 对待基本数据类型:在执行到return语句时,将i自增后的结果缓存起来了,并且这个缓存的结果就是作为最终返回出去的一个结果.然后执行finally中的语句,这时候finally中的修改不影响缓存中的数据,最后执行return语句. 123456789101112131415161718192021222324252627public class FinallyDemo &#123; public static void main(String[] args) &#123; System.out.println(change()); &#125; public static A change()&#123; A a = new A(); try&#123; a.age = 100; return a; &#125;finally &#123; a.age = 200; &#125; &#125;&#125;class A&#123; public int age = 19; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;A&#123;&quot;); sb.append(&quot;age=&quot;).append(age); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 结果:A{age=200} 对待对象类型:finally语句中修改对象的属性值时会影响return的结果 3.笔试题3 final和finally和finalize三者之间的区别? - 一点关系都没有 final a. 修饰的局部变量一旦赋值成功,不可改变. b.修饰的属性一旦赋值成功,不可改变 c.修饰的类不可被继承 d.修饰的方法不可被重写 finally a. 一般是和try.catch搭配使用的,try块中无论是否出现异常,finally块中的代码都会执行 b. finally块中一般写的是释放或者关闭资源的代码 finalize - Object类中提供的方法 a. 当GC想要去回收一个垃圾对象之前,会调用这个对象的finalize方法.这个是由jvm进行调用的. b. 该方法未必一定会调用得到. 4.throw和throws的区别 throw: 表示方法内抛出某种异常对象 如果异常对象是非RuntimeException则需要在方法申明时加上该异常的抛出,即需要加上throws语句或者在方法体内try…catch处理该异常,否则编译报错. 执行到throw语句则后面的语句块不再执行. throws: 方法的定义上使用throws表示这个方法可能抛出某种异常. 需要由方法的调用者进行异常处理.","categories":[],"tags":[{"name":"异常","slug":"异常","permalink":"http://beautifulboyy/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"零碎的知识点","slug":"java09","date":"2021-08-02T01:21:39.000Z","updated":"2021-08-06T03:28:48.155Z","comments":true,"path":"2021/08/02/java09/","link":"","permalink":"http://beautifulboyy/2021/08/02/java09/","excerpt":"","text":"SimpleDateFormat java.text.SimpleDateFormat - 日期格式处理类 它是一个线程不安全的类. 模板 Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, …, 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00 目标 Date类型转换成String类型 - 按照指定的日期格式 1234Date d = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss E&quot;);String strDate = sdf.format(d);System.out.println(strDate); 结果:2021-08-02 09:44:01 星期一 1234Date d = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;ff&quot;);String strDate = sdf.format(d);System.out.println(strDate); 结果:Exception in thread “main” java.lang.IllegalArgumentException: Illegal pattern character ‘f’ pattern必须是一个有效的格式化模板,如果传入了一个非法模板,就会抛出一个非法参数异常. String类型转成Date类型 12345678String birthday = &quot;2021-09-21&quot;;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);try &#123; Date dt = format.parse(birthday); System.out.println(&quot;Date:&quot;+dt);&#125; catch (ParseException e) &#123; e.printStackTrace(); //打印堆栈中的异常信息&#125; 结果:Date:Tue Sep 21 00:00:00 CST 2021 12345678String birthday = &quot;2021-09-21&quot;;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);try &#123; Date dt = format.parse(birthday); System.out.println(&quot;Date:&quot;+dt);&#125; catch (ParseException e) &#123; e.printStackTrace(); //打印堆栈中的异常信息&#125; 结果:java.text.ParseException: Unparseable date: “2021-09-21” 如果构造中的pattern的格式和日期的字符串格式不一致,在调用的时候回抛出解析失败异常. BigDecimalapi:java.math 构造方法 BigDecimal(double val); BigDecimal(String val); 常用方法 方法 含义 BigDecimal add(BigDecimal augend) 加 BigDecimal substract(BigDecimal subtrahend) 减 BigDecimal multiply(BigDecimal multiplicand) 乘 BigDecimal divide(BigDecimal divisor) 除 12345678910111213141516public class BigDecimalDemo &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal(9); BigDecimal d2 = new BigDecimal(3); // 加法运算 System.out.println(d1.add(d2)); //12 // 减法运算 System.out.println(d1.subtract(d2)); //6 // 乘法运算 System.out.println(d1.multiply(d2)); //27 // 除法运算 System.out.println(d1.divide(d2)); //3 &#125;&#125; 笔试题 - 在java开发中如何处理小数精度123456789101112public class BigDecimalHandleFloatDemo &#123; public static void main(String[] args) &#123; // BigDecimal的构造方法中有new BigDecimal(String) BigDecimal d1 = new BigDecimal(&quot;0.1&quot;); BigDecimal d2 = new BigDecimal(String.valueOf(&quot;0.2&quot;)); // 获取两个数相加的结果 BigDecimal result = d1.add(d2); // 相加的结果仍然是BigDecimal. 利用doubleValue获取result的double值 double resultDouble = result.doubleValue(); System.out.println(resultDouble); &#125;&#125; BigInteger笔试题 - 递归算法求阶层12345678public static BigInteger test(int n)&#123; if(n == 1) //return new BigInteger(&quot;1&quot;); return BigInteger.ONE; // 这个是上面那行代码的简写 BigInteger current = new BigInteger(String.valueOf(n)); return current.multiply(test(n-1));&#125; 四种内部类看懂别人写的内部类语法即可. 成员内部类 - 把内部类看成是外部类的一个成员 a. 成员内部类不能定义静态成员 b. 成员内部类中可以通过Outer.this.非静态属性名来访问外部类的非静态方法 c. 外部类.内部类 对象名 = 外部类对象.new 内部类(); 12345678910111213141516171819202122232425262728public class Outer &#123; private int id = 10; // 普通属性 private static int sid = 100; // 静态属性 // 1.成员内部类 - 把内部类看做成外部类的一个成员 public class MemberInner&#123; // 定义非静态属性 private int id = 20; private int age = 18; // 成员内部类不允许定义静态成员 // private static int sid = 200; public MemberInner()&#123; System.out.println(&quot;MemberInner...&quot;); &#125; // 自定义方法 public void test()&#123; System.out.println(&quot;内部类age:&quot;+age); System.out.println(&quot;内部类id:&quot;+id); System.out.println(&quot;外部类id:&quot;+Outer.this.id); System.out.println(&quot;外部类sid:&quot;+Outer.sid); &#125; &#125;&#125; 1234public static void main(String[] args) &#123; // 创建对象 Outer.MemberInner m = new Outer().new MemberInner();&#125; 静态内部类 - 把内部类看成是外部类的一个静态成员 a. 内部可以定义静态和非静态属性 b. 内部的普通方法中是不允许访问外部类的非静态属性的 c. 内部的普通方法中允许访问外部类的静态属性 d. 外部类.内部类 变量名 = new 外部类.静态类(); 1234567891011121314151617181920212223public class Outer &#123; private int id = 10; // 普通属性 private static int sid = 100; // 静态属性 public static class StaticMemberInner&#123; // 定义一个非静态属性 private int id = 20; // 定义一个静态属性 private static int sid = 299; public StaticMemberInner()&#123; System.out.println(&quot;StaticMemberInner&quot;); &#125; public void test()&#123; System.out.println(&quot;内部类-id:&quot;+this.id); System.out.println(&quot;内部类-sid:&quot;+sid); System.out.println(&quot;外部类-sid:&quot;+Outer.sid); // 静态类中访问不到外部类的非静态属性 &#125; &#125;&#125; 1Outer.StaticMemberInner s = new Outer.StaticMemberInner(); 局部内部类 - 内部类是出现在外部类的方法中 a. 内部类不允许使用访问修饰符,比如不能使用public b. 不能定义静态属性 c. 可以访问外部类的静态和非静态成员 d. 生命只在所在的方法中,方法外部是没有办法拿到这个对象的(不能直接在外部new) 123456789101112131415public void testLocalInner()&#123; class LocalInner&#123; public LocalInner()&#123; System.out.println(&quot;LocalInner()...&quot;); &#125; private int id = 10; public void test()&#123; System.out.println(&quot;内部类id:&quot;+id); System.out.println(&quot;外部类id:&quot;+id); System.out.println(&quot;外部类sid:&quot;+sid); &#125; &#125; LocalInner localInner = new LocalInner(); localInner.test();&#125; 匿名内部类 - 必须掌握 好处 - 我们可以在程序中少写实现类 jdk8.x中如果遇到函数式接口.推荐使用lambda表达式来替代匿名内部类的写法的. UMLUnified Modeling Language - 统一建模语言 BA - 需求分析师 powerndesigner starUML 掌握目标:看懂箭头即可 类与类之间由弱到强的关系是:没关系&lt;依赖&lt;关联&lt;聚合&lt;组合 依赖虚线 + 箭头 &lt;—– 简单理解:一个类A使用到了另一个类B.这种使用关系是具有偶然性的,临时性的,非常弱的. 12345678910public class A&#123; public void test(B b)&#123; // 自己的功能 // B类中的功能 b.test(); &#125;&#125;public class B&#123; &#125; 关联实线 + 箭头 &lt;- A类关联了B,A依赖于B 123456public class A&#123; private B b;&#125;public class B&#123; &#125; 组合属于关联的一种,强调的是整体和局部之间的关系,这种关系非常紧密,整体是可以决定局部的生命周期的. 箭头 + 实线 + 实心菱形 1234567891011public class Baby&#123; private Eye eye; private Hand hand; public Baby()&#123; this.eye = new Eye(); this.hand = new Hand(); &#125; public static void main(String[] args)&#123; Baby b = new Baby(); &#125;&#125; 聚合关系属于关联的一种 - 强调的是整体和局部的关系,这种关系较紧密.整体是可以不用决定局部的生命周期的 - 局部单独存在的 箭头 - 实线+空心菱形 123456public class Computer&#123; private Cpu cpu; public Computer(Cpu cpu)&#123; this.cpu = cpu; &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"DateFormat","slug":"DateFormat","permalink":"http://beautifulboyy/tags/DateFormat/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"http://beautifulboyy/tags/BigDecimal/"},{"name":"BigInteger","slug":"BigInteger","permalink":"http://beautifulboyy/tags/BigInteger/"},{"name":"内部类","slug":"内部类","permalink":"http://beautifulboyy/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"UML","slug":"UML","permalink":"http://beautifulboyy/tags/UML/"}]},{"title":"static关键字","slug":"java08","date":"2021-07-31T06:18:40.000Z","updated":"2021-08-02T02:14:57.322Z","comments":true,"path":"2021/07/31/java08/","link":"","permalink":"http://beautifulboyy/2021/07/31/java08/","excerpt":"","text":"static关键字 Static修饰的成员是在JVM加载类的时候就会被立刻分配空间以及初始化,这个过程只有一次,并且内存的实例也只有一份. 非静态的成员是在每次创建对象的时候才会被分配空间以及初始化. Static的作用 static修饰类 - 静态内部类[过] static修饰属性 - 静态属性 static修饰方法 - 静态方法 static修饰代码块 - 静态代码块 JVM加载类进入内存的活动顺序 JVM加载类进入内存 给所有的静态属性分配空间以及初始化 给所有的静态方法分配空间以及初始化 执行静态代码块 如果创建了对象 5-1.给这个对象的所有非静态属性分配空间以及初始化 5-2.给这个对象的所有非静态方法分配空间以及初始化 5-3.执行普通代码块 5-4.执行构造块 static关键字的应用设计模式 - 单例模式 static练习123456789101112131415161718192021222324public class StaticDemo &#123; // 普通属性 - 每次创建对象的时候才会被分配空间以及初始化 private int id = 10; // 静态属性 - static修饰的成员是在jvm加载类的时候就会被立即分配空间以及初始化 private static int sid = 100; // 构造方法 public StaticDemo()&#123; this.id = sid++; &#125; public int getId() &#123; return id; &#125; public static void main(String[] args) &#123; StaticDemo s1 = new StaticDemo(); System.out.println(s1.getId()); StaticDemo s2 = new StaticDemo(); System.out.println(s2.getId()); &#125;&#125; 结果: 100 101 12345678910111213141516171819202122232425262728293031public class StaticBlockDemo &#123; private int id = 10; private static int sid = 100; public StaticBlockDemo()&#123; System.out.println(&quot;构造方法&quot;); System.out.println(&quot;con-id:&quot;+id); System.out.println(&quot;con-sid&quot;+sid); &#125; // 普通代码块 - 每次创建对象的时候,都会执行 - 并且它的时机高于构造块 &#123; System.out.println(&quot;普通代码块&quot;); System.out.println(&quot;b-id&quot;+id); System.out.println(&quot;b-sid&quot;+sid); &#125; // 静态代码块 - jvm加载类进入内存的时候,立即调用静态代码 // 仅仅会执行一次,执行效率最高 static &#123; System.out.println(&quot;静态代码块&quot;); System.out.println(&quot;s-sid:&quot;+sid); &#125; public static void main(String[] args) &#123; StaticBlockDemo s1 = new StaticBlockDemo(); System.out.println(); StaticBlockDemo s2 = new StaticBlockDemo(); &#125;&#125; 结果: 静态代码块s-sid:100普通代码块b-id10b-sid100构造方法con-id:10con-sid100 普通代码块b-id10b-sid100构造方法con-id:10con-sid100 12345678910111213public class Cygnus&#123; static int value = 9; private void printValue()&#123; //局部变量不能使用对象去获取 int value = 69; System.out.println(this.value); &#125; public static void main(String[] args) throws Exception&#123; new Cygnus().printValue(); &#125;&#125; 这个程序会有下面哪种结果？A. 编译错误B. 打印9C. 打印69D. 运行时抛出异常 结果:B 1234567891011121314151617181920212223242526class Base&#123; static&#123; System.out.println(&quot;base static&quot;); &#125; public Base()&#123; System.out.println(&quot;base constructor&quot;); &#125;&#125;public class Test extends Base&#123; static&#123; System.out.println(&quot;test static&quot;); &#125; public Test()&#123; super(); System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 结果 base statictest staticbase constructortest constructor 12345678910111213public class Test &#123; static&#123; System.out.println(&quot;test static 1&quot;); &#125; public static void main(String[] args) &#123; &#125; static&#123; System.out.println(&quot;test static 2&quot;); &#125;&#125; 结果 test static 1test static 2 123456789101112131415public class test&#123; static&#123; int x=5; &#125; static int x,y; public static void main(String args[])&#123; x--; myMethod( ); System.out.println(x+y+ ++x); &#125; public static void myMethod( )&#123; y=x++ + ++x; &#125;&#125; A. 编译错误B. 输出：1C. 输出：2D. 输出：3E. 输出：7F. 输出：8 结果:D 12345678910111213141516171819202122class HelloA&#123; public HelloA() &#123; System.out.println(&quot;I’m A class &quot;); &#125; static&#123; System.out.println(&quot;static A&quot;); &#125;&#125;public class HelloB extends HelloA&#123; public HelloB()&#123; System.out.println(&quot;I’m B class&quot;); &#125; static&#123; System.out.println(&quot;static B&quot;); &#125; public static void main (String[] args)&#123; new HelloB(); &#125;&#125; A. static A I’m A class static B I’m B classB. I’m A class I’m B class static A static BC. static A static B I’m A class I’m B classD. I’m A class static A I’m B class static B 结果:C 12345678910111213141516public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println(&quot;构造块&quot;); &#125; static&#123; System.out.println(&quot;静态块&quot;); &#125; public static void main(String[] args)&#123; B t = new B(); &#125;&#125; A. 静态块 构造块 构造块 构造块B. 构造块 静态块 构造块 构造块C. 构造块 构造块 静态块 构造块D. 构造块 构造块 构造块 静态块 结果:D 12345678910111213141516171819class A &#123; public int func1(int a, int b) &#123; return a - b; &#125;&#125;class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125;&#125;public class ChildClass &#123; public static void main(String[] args) &#123; A a = new B(); B b = new B(); System.out.println(&quot;Result=&quot; + a.func1(100, 50)); System.out.println(&quot;Result=&quot; + b.func1(100, 50)); &#125;&#125; A. Result=150Result=150B. Result=100Result=100C. Result=100Result=150D. Result=150Result=100 结果:A 123456789101112131415public class Test&#123; public static Test t1 = new Test(); &#123; System.out.println(&quot;blockA&quot;); &#125; static&#123; System.out.println(&quot;blockB&quot;); &#125; public static void main(String[] args)&#123; Test t2 = new Test(); &#125; &#125; A. blockAblockBblockAB. blockAblockAblockBC. blockBblockBblockAD. blockBblockAblockB 结果:A","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"static","slug":"static","permalink":"http://beautifulboyy/tags/static/"}]},{"title":"String和StringBuilder的使用","slug":"java05","date":"2021-07-31T03:10:47.000Z","updated":"2021-07-31T12:11:25.569Z","comments":true,"path":"2021/07/31/java05/","link":"","permalink":"http://beautifulboyy/2021/07/31/java05/","excerpt":"","text":"Stringjava中提供的处理字符串的类 - java.lang.String 特点 字符串是不可变的 123String str = &quot;abc&quot;;str = &quot;eef&quot;;// 这里字符串&quot;abc&quot;是没有改变的,将str指向了&quot;eef&quot;,导致&quot;abc&quot;成了垃圾对象. 字符串的本质上就是一个字符数组 123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ //String s = &quot;abc&quot;; 会将&quot;abc&quot;打散,保存到value[]数组中. private final char value[];&#125; 1.String被final修饰,被final修饰的类不可以被继承-&gt;String不能被继承 2.final char value[],表示这个String维护的是不可变的字符数组 构建方式 通过new关键字来构建 1String s = new String(&quot;abc&quot;); 通过这个步骤,可能创建一个或两个对象. ①通过new关键字在堆里面创建了一个字符串对象”abc” ②同时查看”串池”里面有没有”abc”,如果没有,还需要在”串池”中再创建一个”abc”对象. 直接通过”串池”/“字符串常量池”的方法来构建 123String s2 = &quot;abc&quot;;String s3 = &quot;abc&quot;;System.out.println(s1 == s2); 构建s2这个字符串时,会在”串池”中创建一个”abc”对象,然后将地址给s2,构建s3字符串时,发现串池中已经有了”abc”对象,则直接将”abc”的地址返回给s3,所以上面判断的结果为true. 串池的特点:利用串池创建对象时优先到串池中查找是否已经存在该对象,如果有则直接返回地址,如果没有则在串池中创建对象. 拼接字符串的拼接使用的是”+”,它的拼接效率非常低 测试”+”和StringBuilder的append耗费时间的对比 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.day09;/** * @Author liuWenXiu * @Date 2021/7/27 17:45 * @description */public class StringPlusDemo &#123; public static void main(String[] args) &#123; test01(); test02(); &#125; public static void test01()&#123; // 获取当前时间的毫秒数 long t1 = System.currentTimeMillis(); String str = &quot;&quot;; for (int i = 0; i &lt; 100000; i++) &#123; str += i; &#125; // 获取拼接之后的时间的毫秒数 long t2 = System.currentTimeMillis(); System.out.println(&quot;str拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125; public static void test02()&#123; StringBuilder builder = new StringBuilder(); // 获取当前时间的毫秒数 long t1 = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; builder.append(i); //StringBuilder利用append()方法进行拼接 &#125; // 获取拼接之后的时间的毫秒数 long t2 = System.currentTimeMillis(); System.out.println(&quot;StringBuilder拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125; &#125; 123结果str拼接时间:39618msStringBuilder拼接时间:3ms 对比发现”+”的效率特别低. 拼接效率低的原因 “+”底层实现时每次拼接都会创建一个StringBuilder对象,每次创建需要耗费大量的时间. “+”底层仍然是调用StringBuilder的append方法. 关于字符串的测试12String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); 1&gt; javap -c HelloStr 1234567891011121314151617181920212223242526272829303132public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 2: astore_1 3: new #3 // class java/lang/String 6: dup 7: ldc #4 // String def 9: invokespecial #5 // Method java/lang/String.&quot;&lt;init&gt;&quot;: //(Ljava/lang/String;)V 12: astore_2 13: new #6 // class java/lang/StringBuilder //字符串每次拼接+,都会产生一个新的StringBuilder对象 16: dup 17: invokespecial #7 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V //StringBuilder builder = new StringBuilder(); 20: aload_1 21: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; //字符串的+,底层仍然是去调用StringBuilder类中提供的append方法 24: aload_2 25: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #9 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_1 32: return&#125; 在这个代码中,新创建的字符串是”def”,串池中没有,所以要新建,并且是#4.在代码中使用了”+”,对应上面的第13行,创建了StringBuilder对象,在17行进行初始化,21行调用StringBuilder的append方法实现字符串拼接. 比较 s1指向的是”abc”在堆中的地址,s2指向的是”abc”在串池中的地址. intern()强制让s1指向串池中的对象 1234String s1 = new String(&quot;abc&quot;);String s2 = &quot;abc&quot;;System.out.println(s1 == s2); //falseSystem.out.println(s1.intern() == s2); //true s3是一个变量,所以在拼接时,会创建StringBuilder对象,拼接后的结果是String对象,放在堆中,s5则是常量,放在串池中,因此不相等. 12345String s3 = &quot;b&quot;;String s4 = &quot;a&quot; + s3;String s5 = &quot;a&quot; + &quot;b&quot;;System.out.println(s4 == s5); //falseSystem.out.println(s4.intern() == s5); //true s6被final修饰,表示一个常量,所以结果和s5是一致的,都是变量池中的”ab” 123final String s6 = &quot;b&quot;;String s7 = &quot;a&quot; + s6;System.out.println(s5 == s7); //true 这个应该是最容易理解的,每次都新建了一个对象,这个对象和它的值是没有关系的,所以是false. 而**x1.equals(x2)**是用来判断两个字符串值是否相等. 1234String x1 = new String(&quot;abc&quot;);String x2 = new String(&quot;abc&quot;);System.out.println(x1 == x2); //falseSystem.out.println(x1.equals(x2)); //true 常用方法 方法 解释 str.charAt(index); 获取字符串中下标为index的字符 str.length 获取字符串的长度 str.concat(str1) 在原来字符串str的末尾添加新的字符串str1 str.contains(s) 判断字符串str中是否包含子串s str.endsWith(s) 判断字符串str是否以s字符串为结尾 str.startsWith(s) 判断字符串str是否以s字符串为开头 str.equals(str1) 判断字符串str与字符串str1的值是否相等 str.equalsIgnoreCase(str1) 判断字符串str与字符串str1的值是否相等[忽略大小写] str.toUpperCase() 将字符串str中的字符转换为大写 str.toLowerCase() 将字符串str中的字符转换为小写 str.indexOf(s) 返回字符串str中指定字符串s第一次出现的索引 str.lastIndexOf(s) 返回字符串str中指定字符串s最后一次出现的索引 str.isEmpty() 判断字符串是否为空 str.replace(s1,s2) 将字符串str中的所有s1字符串替换为s2字符串 String[] arr = str.split(i) 将字符串str按字符i分割成一个String数组 char[] arr = str.toCharArray() 将字符串转换为字符类型数组 str.substring(a,b) 截取字符串str中下标a到b-1的字符串[a,b) str.substring(a) 截取字符串str中下标a到最后一个字符 str.trim() 去除字符串str左右两边的空格 String s = String.valueOf(n) 将一个整型数n转换成String类型 StringBuilderjava.lang.StringBuilder - 一个可变的字符串 - final修饰,它是性能最高的,默认的容量16,线程不安全 构造方法 1StringBuilder s = new StringBuilder(); 1StringBuilder s2 = new StringBuilder(String str); 扩容机制研究append方法 - 底层代码 每次扩容都为原来长度*2+2 常用方法 方法 解释 str.delete(a,b) 删除字符串str中[a,b)的字符串 str.deleteCharAt(index) 删除字符串str下标为index的字符 str.insert(index,str1) 在字符串str指定下标index位置插入字符串str1 str.reverse() 将字符串str进行反转 注意:StringBuilder是可变的,所以在调用上述方法时不需要进行重新赋值也会改变. 总结类型转换 StringBuilder-&gt;String类型 java.lang.StringBuilder中提供的String toString(); java.lang.String类中提供的构造方法String(StringBuilder builder); java.lang.String类中提供的static String valueOf(Object obj); 面向父类编程 String-&gt;StringBuilder类型 java.lang.StringBuilder中提供的构造StringBuilder(String val); String,StringBuilder,StringBuffer的区别 三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点 不同点 2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的. 2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的. 2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String 方面 区别 可变与不可变 String类是不可变类,StringBuffer和StringBuilder是可变类 线程是否安全 String线程安全,StringBuffer线程安全,StringBuilder线程不安全 效率 String&lt;StringBuffer&lt;StringBuilder","categories":[{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://beautifulboyy/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"贪吃蛇的简单实现","slug":"java-project01","date":"2021-07-30T07:06:08.000Z","updated":"2021-08-01T10:45:26.578Z","comments":true,"path":"2021/07/30/java-project01/","link":"","permalink":"http://beautifulboyy/2021/07/30/java-project01/","excerpt":"","text":"贪吃蛇的简单实现 123456789101112131415161718思路:Point实体类,用于记录点对象.Snake实体类:用于记录这条蛇 定义四个静态常量用于记录蛇头前进的方向[增加代码可读性] 定义一个集合来存储蛇身体的每一个点对象,因为LinkedList集合可以快速找到头节点和尾节点,所以采用LinkedList集合. 定义一个属性,用来记录这个蛇下一次要向哪个方向行动[上下左右]. contains(x,y)方法:判断蛇的身体是否包含(x,y) judgeStep(int dir)方法:判断用户的输入方向是否正确,如果不正确[蛇下一次前进的方向不能与上一次前进的方向相反]抛出异常,正确的话为属性的方向进行赋值.SnakeGames实体类:用于实现这个游戏 定义两个静态常量属性表示游戏边界. 定义一个集合属性来存储食物的坐标,因为坐标是不可重复的,所以用Set集合. 定义一个Snake对象属性. init方法():随机生成食物的点 构造方法:调用init方法初始化集合属性,同时初始化Snake属性 step()方法:实现真正的前进功能.首先要获取蛇的头结点点对象,然后根据方向获得下一个要去的点的位置.判断下一个位置是不是合理的,如果这个位置是墙,则游戏结束,否则将这个位置设置成头结点,再判断这个节点是不是食物,如果是食物就不需要改变了,如果不是食物还需要删除蛇的尾节点. start方法():打印游戏界面,包括判断什么时候打印*[墙],0[食物],#[蛇身]StartGames类:测试类 主方法中接收用户输入并且调用SnakeGames中的start方法. Point实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package day11.snake;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/30 18:48 * @description */public class Point &#123; private int x; private int y; public Point() &#123; &#125; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Point point = (Point) o; return x == point.x &amp;&amp; y == point.y; &#125; @Override public int hashCode() &#123; return Objects.hash(x, y); &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Point&#123;&quot;); sb.append(&quot;x=&quot;).append(x); sb.append(&quot;, y=&quot;).append(y); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 泪目了!!!!忘记重写equals方法,找了半个多小时问题出在哪里,心痛. Snake实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package day11.snake;import java.util.LinkedList;/** * @Author liuWenXiu * @Date 2021/7/30 18:50 * @description 蛇 - 实体类 */public class Snake &#123; public static final int UP = -1; public static final int DOWN = 1; public static final int LEFT = -2; public static final int RIGHT = 2; private LinkedList&lt;Point&gt; snakes = new LinkedList&lt;&gt;(); private int dir; public Snake() &#123; snakes.add(new Point(5,8)); snakes.add(new Point(5,9)); snakes.add(new Point(5,10)); snakes.add(new Point(5,11)); dir = LEFT; &#125; public LinkedList&lt;Point&gt; getSnake() &#123; return snakes; &#125; public void setSnake(LinkedList&lt;Point&gt; snake) &#123; this.snakes = snake; &#125; public int getDir() &#123; return dir; &#125; public void setDir(int dir) &#123; this.dir = dir; &#125; /** * 判断LinkedList集合中是否包含(x,y)点对应的Point对象 * @param x * @param y * @return */ public boolean contains(int x,int y)&#123; return this.snakes.contains(new Point(x,y)); &#125; /** * 判断用户输入的方向是否合法 * @param dir */ public void judgeStep(int dir)&#123; if(this.dir + dir == 0)&#123; // 相加等于0表示前一次的方向和下一次的正好相反 // 抛出异常 throw new RuntimeException(&quot;对不起,方向相反,游戏结束.&quot;); &#125; // 否则给dir赋值 this.dir = dir; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Snake&#123;&quot;); sb.append(&quot;snake=&quot;).append(snakes); sb.append(&quot;, dir=&quot;).append(dir); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; SnakeGames实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package day11.snake;import java.util.HashSet;import java.util.LinkedList;import java.util.Set;/** * @Author liuWenXiu * @Date 2021/7/30 18:55 * @description 游戏实体类 */public class SnakeGames &#123; // 游戏的边界 public static final int ROWS = 20; public static final int COLS = 20; // 存储食物坐标的集合 private Set&lt;Point&gt; foods = new HashSet&lt;&gt;(); private Snake snake; public SnakeGames()&#123; snake = new Snake(); init(5); &#125; /** * 初始化set集合 * @param n 食物的个数 */ public void init(int n)&#123; while (true)&#123; // 随机数 int x = (int) (Math.random()*(ROWS-2)+1); int y = (int) (Math.random()*(COLS-2)+1); foods.add(new Point(x,y)); // 如果食物的坐标在蛇身上也是不可以的. if(snake.contains(x,y))&#123; continue; &#125; if(foods.size()==n) return; &#125; &#125; public void step(int dir)&#123; snake.judgeStep(dir); //1.获取蛇的头结点 Point header = snake.getSnake().getFirst(); int x = header.getX(); int y = header.getY(); //2.根据方向获得下一个点对象的坐标 switch (snake.getDir())&#123; case Snake.UP: x--; break; case Snake.DOWN: x++; break; case Snake.LEFT: y--; break; case Snake.RIGHT: y++; break; &#125; // 3.判断坐标是否合法 if(x==0 || y==0 || x==ROWS-1 || y==COLS-1) throw new RuntimeException(&quot;对不起,撞墙了,游戏结束&quot;); // 4.创建新的点对象 Point p = new Point(x,y); // 5.将新的点对象设置为snake的头结点 snake.getSnake().addFirst(p); // 6.判断吃掉的这个是不是食物 if(foods.remove(p))&#123; // 如果可以删除,则表示吃的是食物 return; &#125; // 如果不能删除,表示吃的不是食物,需要将蛇的尾节点去掉. snake.getSnake().removeLast(); &#125; public void start()&#123; for (int i = 0; i &lt; ROWS ; i++) &#123; for (int j = 0; j &lt; COLS ; j++) &#123; if(i==0 || j==0 || i==ROWS-1 || j==COLS-1)&#123; // 打印游戏的边界 System.out.printf(&quot;%2s&quot;,&quot;*&quot;); &#125;else if(snake.contains(i,j))&#123; // 打印蛇的身体 System.out.printf(&quot;%2s&quot;,&quot;#&quot;); &#125;else if(foods.contains(new Point(i,j)))&#123; // 打印食物 System.out.printf(&quot;%2s&quot;,&quot;0&quot;); &#125;else &#123; // 打印空白 System.out.printf(&quot;%2s&quot;,&quot;&quot;); &#125; &#125; System.out.println(); &#125; &#125;&#125; StartGames123456789101112131415161718192021222324252627282930313233343536373839package day11.snake;import java.util.Scanner;/** * @Author liuWenXiu * @Date 2021/7/30 19:21 * @description 测试类 */public class StartGames &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); SnakeGames games = new SnakeGames(); while (true)&#123; games.start(); System.out.print(&quot;上w下s左a右d-&gt;&quot;); String dir = sc.nextLine(); switch (dir)&#123; case &quot;w&quot;: games.step(Snake.UP); break; case &quot;s&quot;: games.step(Snake.DOWN); break; case &quot;a&quot;: games.step(Snake.LEFT); break; case &quot;d&quot;: games.step(Snake.RIGHT); break; default: System.out.println(&quot;输入错误,请重试!&quot;); break; &#125; &#125; &#125;&#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://beautifulboyy/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://beautifulboyy/tags/java/"}]},{"title":"集合框架","slug":"java04","date":"2021-07-29T02:36:18.000Z","updated":"2021-08-02T02:14:22.198Z","comments":true,"path":"2021/07/29/java04/","link":"","permalink":"http://beautifulboyy/2021/07/29/java04/","excerpt":"","text":"集合框架内存中的”容器对象” - 存储数据的,开发中来替代数组的使用. 结构123456789101112131415api:java.utilCollection[I] - List[I] - 有序可重复 - ArrayList[C] - LinkedList[C] - Vector[C] - Set[I] - 无序不可重复 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复的. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I]特点 - 有序并且是可以重复的. E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray();//将集合转换成数组. ArrayList[C]特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低. 分析源码 123456789101112private static final int DEFAULT_CAPACITY = 10; //默认的初始容量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //一个空数组transient Object[] elementData; // 真正存储数据的数组private int size; // 集合的大小// 构造public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //构造时初始化elementData &#125; add方法 123456789101112public boolean add(E e) &#123; //第一次:size=0; 执行ensureCapacityInternal(1); //第二次:size=1; 执行ensureCapacityInternal(2); //第十一次:size=10; 执行ensureCapacityInternal(11); ensureCapacityInternal(size + 1); //第一次:elementData[0++] = e; size=1 //第二次:elementData[1++] = e; size=2 //第十一次:elementData[10++] = e; size=11 elementData[size++] = e; return true;&#125; ensureCapacityInternal(); 123456789101112131415private void ensureCapacityInternal(int minCapacity) &#123; //第一次:在构造时进行了初始化,所以if之后的判断为true //第二次:在grow方法中elementData已经重新指向了新的数组,所以结果是false,跳过该if //第十一次:仍旧是跳过 //这个if只有在第一次add的时候是true if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 第一次:minCapacity = Math.max(10,1); =&gt; minCapacity=10 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //第一次:ensureExplicitCapacity(10); //第二次:ensureExplicitCapacity(2); //第十一次:ensureExplicitCapacity(11); ensureExplicitCapacity(minCapacity);&#125; ensureExplicitCapacity(minCapacity); 1234567891011private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 第一次:minCapacity = 10,elementData.length=0;10-0&gt;0的结果是true // 第二次:minCapacity = 2,elementData.length=10;2-10&gt;0的结果是false,跳过该if,返回add方法 // 第十一次:minCapacity = 11,elementData.length=10;11-0&gt;0的结果是true if (minCapacity - elementData.length &gt; 0) // 第一次:执行grow(10); // 第十一次:执行grow(11); grow(minCapacity);&#125; grow(minCapacity);每次扩容都增加原来长度的一半 12345678910111213141516private void grow(int minCapacity) &#123; // 第一次:oldCapacity=0,newCapacity=0; // 第十一次:oldCapacity=10,newCapacity=15; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5倍 // 第一次:0-10&lt;0 true // 第十一次:15-11&lt;0 false if (newCapacity - minCapacity &lt; 0) // 第一次:newCapacity = 10; newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 第一次:进行扩容,新的数组长度为newCapacity=10; // 第十一次:进行扩容,新的数组长度为newCapacity=15; elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历12345ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Hello&quot;);list.add(&quot;Java&quot;);list.add(&quot;oracle&quot;);list.add(&quot;php&quot;); 直接输出 123for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i)+&quot;\\t&quot;);&#125; 增强for循环 - 只读 1只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常 123for (String s : list) &#123; System.out.print(s+&quot;\\t&quot;);&#125; 迭代器 - 很重要 12345Iterator&lt;String&gt; iter = list.iterator();while(iter.hasNext())&#123; String s = iter.next(); System.out.print(s+&quot;\\t&quot;);&#125; 匿名内部类 123456list.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.print(s+&quot;\\t&quot;); &#125;&#125;); lambda表达式 1list.forEach(s -&gt; System.out.print(s+&quot;\\t&quot;)); LinkedList的遍历方法和ArrayList一样. 常用方法 方法 含义 list.add() 添加元素 list.clear() 清空元素 list.remove(index) 按下标删除集合中的元素 list.remove(o) 按元素删除集合中的元素 list.isEmpty() 判断集合是否为空 list.contains(o) 判断集合中是否包含某个元素 list.indexOf(o) 返回某个元素在集合中第一次出现的位置,如果不存在返回-1 list.size() 获取集合的大小 list.get(index) 获取集合中指定下标的值 适用于ArrayList和LinkedList. LinkedList[C]有序的序列,底层的数据双向链表,jdk6以及之前是双向循环链表 链表结构的特点:查询效率很低,每次都会从头节点开始遍历.但是增删效率高,只会涉及到相邻节点的移动. 链表结构相对于数组这种数据结构,需要占用更多的内存.每个节点除了保存具体的数据,还需要保存相邻节点的地址. 单向链表 head - 头节点 tail - 尾节点 element - 节点中真正的保存的数据 next - 下一个节点的地址 单向循环链表 尾节点的next又指向了头节点. 双向链表 - LinkedList底层数据结构 增加了一个pre - 保存的是上一个节点的地址. 双向循环链表 剖析源码1234567891011121314151617//节点类 -&gt; 有三个属性:分别元素,上一个节点对象以及下一个节点对象private static class Node&lt;E&gt; &#123; E item; //元素 Node&lt;E&gt; next; //next的值是下一个节点对象的地址 Node&lt;E&gt; prev; //prev的值是上一个节点对象的地址 // 构造方法 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;transient Node&lt;E&gt; first; //定义了头节点transient Node&lt;E&gt; last; //定义了尾节点 add方法1234public boolean add(E e) &#123; linkLast(e); return true;&#125; 12345678910111213141516void linkLast(E e) &#123; //1.创建节点对象l指向尾节点 final Node&lt;E&gt; l = last; //2.创建节点对象newNode,这个是新创建的节点对象 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //3.将尾节点指向新的节点对象[每次创建新的节点对象,尾节点都变成新的对象] last = newNode; if (l == null) //如果l为空-&gt;之前的尾节点为空-&gt;是第一次创建-&gt;表示链表之前没有任何的元素 first = newNode; // 于是把新的节点作为头节点 else // 如果l不为空-&gt;表示链表不为空,则将之前链表中的尾节点的next指向新的节点 l.next = newNode; size++; //长度++ modCount++;&#125; get方法1234public E get(int index) &#123; checkElementIndex(index); //用于检测元素下标-&gt;可以暂时不用在意 return node(index).item;&#125; 1234567891011121314151617181920212223242526// 获取指定下标的节点Node&lt;E&gt; node(int index) &#123; // size&gt;&gt;1 的含义就是size/2 // 判断index是在[0,size/2)之间还是在[size/2,size)之间 if (index &lt; (size &gt;&gt; 1)) &#123; // 如果index在[0,size/2)之间,则从头节点开始查询 Node&lt;E&gt; x = first; // 获取头节点 // 查找的步骤是从头节点开始一个一个向后取 for (int i = 0; i &lt; index; i++) x = x.next; //假设index=3; //i=0时,x = first.next -&gt; 第二个节点 i++ //i=1时,x -&gt; 第三个节点 i++ //i=2时,x -&gt; 第四个节点 i++(不符合条件,退出) return x; //这时候就返回第四个节点 &#125; else &#123; // 如果index在[size/2,size)之间,则从尾节点开始查询 Node&lt;E&gt; x = last; // 获取尾节点 for (int i = size - 1; i &gt; index; i--) x = x.prev; // 假设index = 7,size = 10 // i = 9时,x = last.prev -&gt; 倒数第二个节点(第九个节点) i-- // i = 8时,x -&gt; 倒数第三个节点(第八个节点) i-- 此时i=7,不符合循环条件,退出循环 return x; //返回第八个节点 &#125;&#125; remove方法123456public E remove(int index) &#123; checkElementIndex(index); // 这里首先node(index)找到下标对应的Node对象 // 然后通过unlink(Node对象)删除对象 return unlink(node(index));&#125; 1234567891011121314151617181920212223242526E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 常用方法 方法 含义 list.addFirst(o) 在头部添加某个元素 list.addLast(o) 在尾部添加某个元素 list.push(o) 把元素压入栈顶[即添加到头部] list.pop() 弹出栈顶元素并返回. list.removeFirst() 删除第一个元素 list.removeLast() 删除最后一个元素 list.getFirst() 获取第一个元素 list.getLast() 获取最后一个元素 offer,offerFirst,offerLast方法和add方法一样. 一个小题目括号匹配,如果是{[()]},{}等匹配成功,{[)}匹配失败. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package day11.homework;import java.util.LinkedList;/** * @Author liuWenXiu * @Date 2021/7/29 10:57 * @description 括号匹配 */public class BracketMatching &#123; /** * 括号的匹配 * @param c1 * @param c2 * @return */ public static boolean match(char c1,char c2)&#123; boolean flag = false; if(c1 == &#x27;&#123;&#x27; &amp;&amp; c2 == &#x27;&#125;&#x27;) flag = true; else if(c1 == &#x27;[&#x27; &amp;&amp; c2 == &#x27;]&#x27;) flag = true; else if(c1 == &#x27;(&#x27; &amp;&amp; c2 == &#x27;)&#x27;) flag = true; return flag; &#125; /** * * @param str * @return */ public static boolean bracketMatching(String str)&#123; char[] arr = str.toCharArray(); LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); list.push(arr[0]); for (int i = 1; i &lt; arr.length; i++) &#123; //!!!!!!!!这里真的要注意一下!!!!!!!!!!!!!-&gt;没有考虑到这种情况 // 为了避免在栈顶已经没有元素的情况下还去获取栈顶元素,非空判断 if(list.isEmpty())&#123; list.push(arr[i]); continue; &#125; if(match(list.getFirst(),arr[i]))&#123; // 匹配就出栈 list.pop(); &#125;else&#123; // 不匹配就入栈 list.push(arr[i]); &#125; &#125; return list.isEmpty(); &#125; public static void main(String[] args) &#123; String str = &quot;&#123;&#125;[]()&quot;; System.out.println(bracketMatching(str)); &#125;&#125; 这里一定要注意在取出栈顶元素的时候,首先需要判断这个集合中是否还有元素. Map[I]HashMap[C]数据存储的形式是key-value,针对key是无序不可重复的. jdk8.x之前,底层的数据结构是桶数组+链表 jd8.0开始,底层的数据结构是桶数组+链表+红黑树 桶(哈希桶)数组 - 里面的元素放在数组的这个位置是通过一个哈希算法计算得到的. 图示 剖析put方法 put方法 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; putVal方法 12345678910111213141516171819202122232425262728293031323334353637383940414243final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 常用方法 方法 含义 map.size() 获取集合大小 map.put(k,v) 添加元素,键为k,值为v map.get(k) 获取键key对应的值 map.clear() 清空集合 map.isEmpty() 判断集合是否为空 map.containsKey(k) 判断集合中是否包含某个key map.keySet() 将map集合中所有的key全部取出来放到一个set集合中 map.entrySet() 将map集合中的每对key-value封装到内置的Entry对象中 map.containsValue(v) 判断集合中是否包含某个value Map集合的迭代方式1234567891011121314151617181920212223// 第一种方式:将map集合中所有的key全部取出来放入到set集合中Set&lt;Integer&gt; sets = maps.keySet();// 遍历set集合Iterator&lt;Integer&gt; inter = sets.iterator();while(inter.hasNext())&#123; Integer key = inter.next(); String value = maps.get(key); System.out.println(key+&quot;:&quot;+value);&#125;System.out.println();// 第二种方式// 将map集合中的每对key-value封装到内置的entry对象中// 然后将每个entry对象放到set集合中Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter = entries.iterator();while(iter.hasNext())&#123; Map.Entry&lt;Integer,String&gt; entry = iter.next(); Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+&quot;-&gt;&quot;+value);&#125; HashSetSet[I]接口下的实现类 - 存储的数据是无序,不可重复的. 添加数据到容器的原理 当把对象添加到容器中之前,会调用对象的hashCode方法,得到一个哈希值. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用,那么就可以直接将这个对象放入到这个容器中的这个位置. 如果这个哈希值在这之前出现过了,产生了哈希碰撞或哈希冲突.但这个时候还不能确定哈希碰撞的两个对象是同一个对象 继续调用对象的equals方法,如果返回true,说明是同一个对象,则拒绝添加. 底层数据结构桶数组 + 链表 + 红黑树 查看HashSet源码 Set sets = new HashSet&lt;&gt;(); 1234public HashSet() &#123;//HashSet的底层是HashMapmap = new HashMap&lt;&gt;();&#125; add方法底层 123456789private static final Object PRESENT = new Object();//此处的e是添加到容器中的对象public boolean add(E e) &#123;//实际上还是在调用map的put方法//HashSet中添加的对象是作为了Map集合的key//Map的key具有什么特点 = HashSet中的数据有何特点.return map.put(e, PRESENT)==null;&#125; TreeSetSet[I] - SortedSet[I] - TreeSet[C] - 不可重复的,但是可以排序. 特点TreeSet在添加元素时,假设排序的规则定好,比如根据price进行排序,那么被添加到容器的这些对象的price就不能一样,一旦存在price相同的对象,就会拒绝添加. 123456789101112131415161718public class ComparatorFactory &#123; public static final int ISBN = 0; public static final int PRICE = 1; public static Comparator&lt;Book&gt; getInstance(int type)&#123; Comparator&lt;Book&gt; c = null; switch (type)&#123; case ISBN: c = (b1,b2)-&gt;b2.getIsbn().compareTo(b1.getIsbn()); break; case PRICE: c = (b1,b2)-&gt; (int) (b2.getPrice()-b1.getPrice()); break; &#125; return c; &#125;&#125; 123456789101112131415// 获取按照price进行排序的比较器Comparator c = CompareFactoryDemo.getInstance(CompareFactoryDemo.PRICE);TreeSet&lt;Book&gt; books = new TreeSet&lt;&gt;(c); //注意一下这里的构造Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d);Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d);Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d);Book b4 = new Book(2,&quot;1004&quot;,&quot;python&quot;,300.0d);books.add(b1);books.add(b2);books.add(b3);books.add(b4);books.forEach(e-&gt; System.out.println(e)); 1234结果Book&#123;id=2, isbn=&#x27;1004&#x27;, name=&#x27;python&#x27;, price=300.0&#125;Book&#123;id=2, isbn=&#x27;1002&#x27;, name=&#x27;java&#x27;, price=200.0&#125;Book&#123;id=1, isbn=&#x27;1001&#x27;, name=&#x27;java&#x27;, price=100.0&#125; 如果构造中没有指明Comparator,就会报java.lang.ClassCastException异常. 排序比较器接口Comparatorjdk8.0开始,在List接口中已经定义了排序的方法 void sort(Comparator&lt;? superE&gt; c) Book实体类 - 省略构造,getter/setter方法/toString方法 123456public class Book &#123; private int id; private String isBn; private String name; private double price;&#125; 测试类 12345678910Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d);Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d);Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d);Book b4 = new Book(4,&quot;1004&quot;,&quot;python&quot;,300.0d);List&lt;Book&gt; bookList = new ArrayList&lt;&gt;();bookList.add(b1);bookList.add(b2);bookList.add(b3);bookList.add(b4); 根据价格降序排序,使用匿名内部类方式 12345678910bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; if(o1.getPrice()&gt;o2.getPrice()) return -1; else if(o1.getPrice()&lt;o2.getPrice()) return 1; return 0; &#125;&#125;); 简化一下 123456bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; return (int) o2.getPrice() - o1.getPrice(); &#125;&#125;); 在排序时,如果符合要求则返回-1,不符合就返回1,相等返回0. 根据价格升序排序,使用lambda表达式 1234567bookList.sort((o1,o2) -&gt; &#123; if(o1.getPrice()&gt;o2.getPrice()) return 1; else if(o1.getPrice()&lt;o2.getPrice()) return -1; return 0;&#125;); 简化 1bookList.sort((o1,o2) -&gt; (int) (o1.getPrice()-o2.getPrice())); 根据编号降序排序,使用lambda表达式 1bookList.sort((o1,o2) -&gt; o2.getIsBn().compareTo(o1.getIsBn())); 因为String类中重写了compareTo方法,所以字符串可以通过compareTo进行比较 根据价格升排序,如果价格一样,按照编号升序继续排序,使用匿名内部类. 12345678910bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; if(o1.getPrice()&gt;o2.getPrice()) return 1; else if(o1.getPrice()&lt;o2.getPrice()) return -1; else return o1.getIsBn().compareTo(o2.getIsBn()); &#125;&#125;); Collectionsjava.util.Collections[C] - 集合工具类 面试题 - Collection和Collections有什么区别? Teacher类 - 省略构造,getter/setter方法/toString方法 12345public class Teacher &#123; private int id; private String name; private int age;&#125; Teacher测试类 12345678910Teacher t1 = new Teacher(1,&quot;tom&quot;,23);Teacher t2 = new Teacher(2,&quot;jack&quot;,25);Teacher t3 = new Teacher(3,&quot;james&quot;,18);Teacher t4 = new Teacher(4,&quot;rose&quot;,17);List&lt;Teacher&gt; list = new ArrayList&lt;&gt;();list.add(t1);list.add(t2);list.add(t3);list.add(t4); 要求:按照老师的年龄增序排序 static void sort(List list, Comparator&lt;? super T&gt; c)根据指定的比较器引起的顺序对指定的列表进行排序。 123456789// 匿名内部类Collections.sort(list, new Comparator&lt;Teacher&gt;() &#123; @Override public int compare(Teacher o1, Teacher o2) &#123; return o1.getAge()-o2.getAge(); &#125;&#125;);// lambda表达式Collections.sort(list,(o1,o2) -&gt; o1.getAge()-o2.getAge()); static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list) ;//集合中的对象必须要实现java.lang.Comparable可比较接口 修改Teacher类,实现Comparable接口,并重写compareTo方法 12345678910public class Teacher implements Comparable&lt;Teacher&gt;&#123; private int id; private String name; private int age; @Override public int compareTo(Teacher o) &#123; return this.getAge()-o.getAge(); &#125;&#125; 测试类 1Collections.sort(list); 如果在Teacher类中没有实现接口,这里的语法就会报错. 面试题HashMap 和 HashTable 区别 HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下: HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。","categories":[{"name":"框架","slug":"框架","permalink":"http://beautifulboyy/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"集合框架","slug":"集合框架","permalink":"http://beautifulboyy/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"设计模式","slug":"java-design","date":"2021-07-27T12:46:54.000Z","updated":"2021-08-14T02:40:50.261Z","comments":true,"path":"2021/07/27/java-design/","link":"","permalink":"http://beautifulboyy/2021/07/27/java-design/","excerpt":"","text":"模板方法设计模式抽象类应用 - 模板方法设计模式 模板方法模式很常用,其目的是在一个方法中定义一个算法骨架,而将一些步骤延迟到子类中.模板方法使得子类可以在不改变算法接口的情况下,重新定义算法的某些步骤. 在标准的模板方法模式实现中,主要是使用继承的方式,来让父类在运行期间可以调用到子类的方法. -&gt;处理某个流程的代码已经都具备,但是其中某个节点的代码暂时不能确定.处理步骤在父类中定义好,具体实现延迟到子类中定义 模板类中只负责定义: 需要做的事情 - 不需要具体的实现,具体的实现留给各个子类去实现. 做事情的流程[步骤] 一个小实例,可以参考理解 TemplateDemo.java 1234567891011121314public abstract class TemplateDemo &#123; //规定了需要完成的事情 public abstract void start(); //演员登台 public abstract void play(); //演员表演 public abstract void end(); //落幕 //提供一个不可变的方法,用来控制事情执行的顺序 public final void execute()&#123; this.start(); this.play(); this.end(); &#125;&#125; YueYueImpl.java 1234567891011121314151617181920212223package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:17 * @description 继承TemplateDemo类并且实现里面的抽象方法 */public class YueYueImpl extends TemplateDemo &#123; @Override public void start() &#123; System.out.println(&quot;小岳岳登场!&quot;); &#125; @Override public void play() &#123; System.out.println(&quot;小岳岳讲相声&quot;); &#125; @Override public void end() &#123; System.out.println(&quot;小岳岳离场&quot;); &#125;&#125; DeGangImpl.java 123456789101112131415161718192021222324package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:58 * @description 继承TemplateDemo类并且实现里面的抽象方法 */public class DeGangImpl extends TemplateDemo &#123; @Override public void start() &#123; System.out.println(&quot;郭德纲登场..&quot;); &#125; @Override public void play() &#123; System.out.println(&quot;郭德纲在讲相声&quot;); &#125; @Override public void end() &#123; System.out.println(&quot;郭德纲退场...&quot;); &#125;&#125; TestTemplate 12345678910111213141516171819202122232425262728package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:18 * @description 测试 */public class TestTemplate &#123; public static void main(String[] args) &#123; TemplateDemo t = new YueYueImpl(); //t.execute(); TemplateDemo t2 = new DeGangImpl(); TemplateDemo[] ts = &#123;t,t2&#125;; for (TemplateDemo demo : ts) &#123; demo.execute(); &#125; &#125;&#125;结果:小岳岳登场!小岳岳讲相声小岳岳离场郭德纲登场..郭德纲在讲相声郭德纲退场... 这个就是模板方法设计模式,不管是DeGangImpl还是YueYueImpl都是遵循一个顺序,分别是start()-&gt;play()-&gt;end();但是这些方法的具体实现是在子类中实现的. 模板方法设计模式的优缺点 优点 模板方法提供了一个很好的代码复用平台. 实现了反向控制,通过一个父类调用其子类的操作,通过对子类的具体实现扩展不同的行为,实现了反向控制,符合”开闭原则”. 缺点 每一个不同的实现都需要一个子类来实现,导致类的个数增加,使得系统更加庞大.结合实例来理解,每一个相声演员都需要一个新的子类来实现,这样就会导致类的数量很多. 单例模式如何保证某个类的对象在内存中永远只有一份,某些类的创建和销毁的时间成本比较高,这些类有必要设计成单例的.比如jdbc中的连接池对象[重量级的对象] 饿汉模式 - 多线程安全 私有化构造方法 初始化一个静态变量,该变量就是该类唯一的一个实例. 提供一个公开的静态方法来返回这个实例 123456789public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉模式 - 多线程不安全 私有化构造方法 创建一个静态变量,但不进行初始化,该变量就是该类唯一的实例 提供一个公开的静态方法,在方法中初始化该实例并返回. 1234567891011public static Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null) instance = new Singleton(); return instance; &#125;&#125; 双重检查锁 - 多线程安全 私有化构造方法 创建一个静态变量,但不进行初始化,该变量就是该类唯一的实例 123456789101112131415161718192021222324252627public static Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; //因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁,所以此处也要进行非空判断. if(instance == null)&#123; //跑得快的线程都会进入此处A,B //A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入 //同步代码块去执行里面的代码 //假设A线程抢到了,B就会在等待 synchronized (Singleton03.class)&#123; //A进入判断instance==null //只要抢到&quot;锁&quot;的线程,如果此处没有非null判断 //那么进入到这的线程都会去执行instance = new Singleton03(); if(instance == null)&#123; //由A线程进行实例的初始化 //A继续执行,等A执行完毕之后,那么A就会释放锁资源 //其他线程继续争抢锁资源. instance = new Singleton03(); &#125; &#125; &#125; return instance;&#125; volatile 可见性[忽略] 禁止JVM的指令重排 123456789101112int i = 10; //这是一个原子性的操作Student s = new Student(); //这不是一个原则性的操作 /*它需要经过三个过程:①给s对象分配内存空间②调用构造块,执行构造函数 - 初始化③将引用s指向内存中的那个对象但是JVM内部会对这些指令进行一个优化操作.本来顺序是①-&gt;②-&gt;③,经过JVM指令重排之后,顺序有可能变成①-&gt;③-&gt;②*/ 12345678910111213public class Singleton&#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; &#125;&#125; 工厂模式简单工厂模式它违背了”开闭原则” 123456789101112131415public class interface Sender&#123; void send();&#125;public class QQSender implements Sender&#123; @override public void send()&#123; System.out.println(&quot;QQSend...&quot;) &#125;&#125; public class WXSender implements Sender&#123; @override public void send()&#123; System.out.println(&quot;WXSend...&quot;) &#125;&#125; 简单工厂模式必须要脱手写出来 123456789101112131415161718public class ProductFactory&#123; public static final int QQ = 1; public static final int WX = 2; public static Sender getInstance(int type)&#123; swtich(type)&#123; case 1: return new QQSender(); break; case 2: return new WXSender(); break; default: System.out.println(&quot;输入错误!&quot;); break; &#125; &#125;&#125; 多方法简单工厂 12345678public class ProductFactory&#123; public Sender produceQQ()&#123; return new QQSender(); &#125; public Sender produceWX()&#123; return new WXSender(); &#125;&#125; 静态方法简单工厂12345678public class ProductFactory&#123; public static Sender produceQQ()&#123; return new QQSender(); &#125; public static Sender produceWX()&#123; return new WXSender(); &#125;&#125; 简单工厂优缺点优点： 很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。所以简单工厂有一个别名：上帝类。 缺点： 任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大 在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。 工厂方法模式一个工厂类只负责生产一个产品 123456789101112131415161718192021222324public interface ProductFactory&#123; Sender createSender();&#125;public class QQProductFactory implements PrductFactory&#123; @Override public Sender createSender() &#123; return new QQSender(); &#125;&#125;public class WXProductFactory implements ProductFactory&#123; @Override public Sender createSender() &#123; return new WXSender(); &#125;&#125;public class TestProductFactory &#123; public static void main(String[] args) &#123; Sender qq = new QQProductFactory().createSender(); Sender wx = new WXProductFactory().createSender(); qq.send(); wx.send(); &#125;&#125; 工厂方法模式优缺点优点： 工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产；（对应简单工厂的缺点1） 同时增加某一类”东西“并不需要修改工厂类，只需要添加生产这类”东西“的工厂即可，使得工厂类符合开闭原则。 缺点： 相比简单工厂，实现略复杂。 对于某些可以形成产品族的情况处理比较复杂（相对抽象工厂）。 抽象工厂模式产品族 123456789101112131415161718192021222324252627282930public interface Cpu &#123; void info();&#125;public interface Net &#123; void info();&#125;public class IBMCpu implements Cpu&#123; @Override public void info() &#123; System.out.println(&quot;IBMPCpu...&quot;); &#125;&#125;public class IntelCpu implements Cpu&#123; @Override public void info() &#123; System.out.println(&quot;IntelCpu...&quot;); &#125;&#125;public class InternetNet implements Net&#123; @Override public void info() &#123; System.out.println(&quot;InternetNet...&quot;); &#125;&#125;public class GaoTongNet implements Net&#123; @Override public void info() &#123; System.out.println(&quot;GaoTongNet...&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public interface ProductFactory &#123; Cpu createCpu(); Net createNet();&#125;public class XiaoMiFactory implements ProductFactory&#123; @Override public Cpu createCpu() &#123; return new IBMCpu(); &#125; @Override public Net createNet() &#123; return new InternetNet(); &#125;&#125;public class PhoneXFactory implements ProductFactory&#123; @Override public Cpu createCpu() &#123; return new IntelCpu(); &#125; @Override public Net createNet() &#123; return new GaoTongNet(); &#125;&#125;public class TestFactory &#123; public static void main(String[] args) &#123; ProductFactory pf = new XiaoMiFactory(); Cpu cpu = pf.createCpu(); Net net = pf.createNet(); cpu.info(); net.info(); &#125;&#125; 反射工厂模式反射工厂既能够保证在新增一个产品的时候,遵守”开闭原则”,又能够保证始终仅仅只有一个工厂类. 基础demo1234567891011121314151617public interface IBaseDao &#123; void add();&#125;public class StudentDaoImpl implements IBaseDao&#123; @Override public void add() &#123; System.out.println(&quot;Student...impl&quot;); &#125;&#125;public class TeacherDaoImpl implements IBaseDao&#123; @Override public void add() &#123; System.out.println(&quot;Teacher...impl&quot;); &#125;&#125; 12345678910111213141516171819202122public enum FactoryNum &#123; STUDENT_DAO(&quot;STUDENT_DAO&quot;), TEACHER_DAO(&quot;TEACHER_DAO&quot;), MASTER_DAO(&quot;MASTER_DAO&quot;); private String sign; FactoryNum() &#123; &#125; FactoryNum(String sign) &#123; this.sign = sign; &#125; public String getSign() &#123; return sign; &#125; public void setSign(String sign) &#123; this.sign = sign; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package tech.aistar.design.factory.reflect;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @Author liuWenXiu * @Date 2021/8/14 9:25 * @description */public enum PropUtil &#123; INSTANCE; // 定义一个Properties文件 private Properties properties; PropUtil()&#123; // 在构造方法中为properties初始化 properties = new Properties(); // 读取属性文件 // 方法一 //InputStream in = null;// try &#123;// in = new FileInputStream(&quot;src/tech/aistar/design/factory/reflect/bean.properties&quot;);// &#125; catch (FileNotFoundException e) &#123;// e.printStackTrace();// &#125; // 方法二 - 推荐使用的方法 - 硬记下来 // 注意一下方法二和方法一文件路径的区别,一个有src一个没有src InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;tech/aistar/design/factory/reflect/bean.properties&quot;); //System.out.println(in); // 加载属性资源 try &#123; properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 根据key获取值 * @param key * @return */ public String getValue(String key)&#123; // 需要确认properties是否为空 if(properties==null) return null; // properties.getProperty(key) 根据键获取值 return properties.getProperty(key); &#125;&#125; 12345678910111213141516171819202122232425262728package tech.aistar.design.factory.reflect;/** * @Author liuWenXiu * @Date 2021/8/14 9:42 * @description 泛型类 负责根据传入的实现类全限定名返回对应的实例 */public class BaseFactory&lt;T&gt; &#123; public static&lt;T&gt; T getInstance(String type)&#123; T t = null; // 传入的是某个类的全限定名 // 创建类的实例 try &#123; Class&lt;?&gt; c = Class.forName(type); // 反射调用空参构造创建实例 t = (T) c.newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; return t; &#125;&#125; 12STUDENT_DAO=tech.aistar.design.factory.reflect.StudentDaoImplTEACHER_DAO=tech.aistar.design.factory.reflect.TeacherDaoImpl 进阶demoStudentDaoImpl的功能要升级. 创建StudentDaoImpl2 1234567891011121314151617181920212223242526package tech.aistar.design.factory.reflect;/** * @Author liuWenXiu * @Date 2021/8/14 10:17 * @description */public class StudentDaoImpl2 implements IBaseDao&#123; private IBaseDao baseDao; public StudentDaoImpl2() &#123; // 为baseDao初始化 baseDao = new StudentDaoImpl(); System.out.println(&quot;StudentDaoImpl....2&quot;); &#125; @Override public void add() &#123; // 调用StudentDaoImpl()的add方法 baseDao.add(); // 实现功能的拓展 System.out.println(&quot;拓展的功能&quot;); // 再修改bean.properties文件,修改STUDENT_DAO对应的value值,改为StudentDaoImpl2的全限定名 &#125;&#125; 修改bean.properties 12STUDENT_DAO=tech.aistar.design.factory.reflect.StudentDaoImpl2TEACHER_DAO=tech.aistar.design.factory.reflect.TeacherDaoImpl 工厂模式对比 简单工厂 优点:简单 缺点:如果有新的产品加入,需要修改工厂类,违背了软件开发的设计原则-“开闭原则” 工厂方法设计模式 优点:一个工厂类只负责生产一个产品,如果有新的产品加入,不需要修改工厂类,只需要增加一个工厂. 缺点:项目中会存在很多的工厂类. 抽象工厂模式 负责创建一个产品族 反射工厂既能够保证在新增一个产品的时候,遵守”开闭原则”,又能够保证始终仅仅只有一个工厂类.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"包装类型","slug":"java03","date":"2021-07-27T08:50:47.000Z","updated":"2021-08-02T02:13:28.900Z","comments":true,"path":"2021/07/27/java03/","link":"","permalink":"http://beautifulboyy/2021/07/27/java03/","excerpt":"","text":"包装类型每个基本类型都有其对应的包装类型[对象类型] 基本类型 包装类型[对象类型] byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 学习掌握目标 包装类型的api常用方法 包装类型和基本数据类型以及String类型三者之间的相互转换问题 Numberjava.lang.Number - 所有关于上面包装类型[数字]的共同的抽象的父类 byte byteValue()返回指定号码作为值 byte ，这可能涉及舍入或截断。 abstract double doubleValue()返回指定数字的值为 double ，可能涉及四舍五入。 abstract float floatValue()返回指定数字的值为 float ，可能涉及四舍五入。 abstract int intValue()返回指定号码作为值 int ，这可能涉及舍入或截断。 abstract long longValue()返回指定数字的值为 long ，可能涉及四舍五入或截断。 short shortValue()返回指定号码作为值 short ，这可能涉及舍入或截断。 提供的这些方法都是关于包装类型转换成对应的基本类型的方法 Integer构造 Integer(int i);//利用int类型的整数来构建一个Integer对象 - int类型-&gt;Integer类型 Integer(String s);//此处的字符串一定是数字形式的字符串 - String类型-&gt;Integer类型 如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 自动解封箱jdk5.x开始支持的新的功能 封箱 - 基本数据类型可以自动转换成对应的包装类型 解箱 - 包装类型可以自动转换成对应的基本的数据类型 常用方法 static Integer valueOf(int i); int类型-&gt;Integer类型 如果int类型的数在**[-128,127]**之间,就直接返回内部的缓冲数组中的数据,如果不在这个范围,会返回一个新的Integer对象.因为在Integer类中有一个个静态内部类IntegerCache,在它里面有一个缓冲区,提供了缓冲数组,数组在静态代码块中进行预初始化,提前赋值了. 1234567891011121314151617181920212223//如果[-128,127]之间,那么直接返回内部的缓冲数组中的数据//如果不在这个范围,返回一个新的Integer对象public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;Integer类内部有一个静态内部类private static class IntegerCache &#123; static final int low = -128; static final int high; //缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了. static final Integer cache[]; static&#123; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; &#125; 关于进制的转换 2-1. static String toBinaryString(int n);//十进制n转换成对应的二进制 2-2. static String toHexString(int n);//十进制n转换成对应的十六进制 2-3. static String toOctalString(int n);//十进制n转换成对应的八进制 static int parseInt(String s);//将数字形式的字符串转换成int类型,如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 static Integer valueOf(String s);//String-&gt;Integer 包装类型和基本数据类型以及String类型三者之间的相互转换问题 int-&gt;Integer 123456//1.构造方法new Integer(int n)Integer t1 = new Integer(12);//2.Integer提供的静态方法valueOfInteger t2 = Integer.valueOf(12);//3.自动封箱Integer t3 = 12; Integer-&gt;int 1234//1.Number提供的方法intValueint n1 = t1.intValue();//2.自动解箱int n2 = t1; int-&gt;String 12//String提供的静态方法valueOfString str = String.valueOf(n1); String-&gt;int 12//Integer提供的静态方法paseIntint n3 = Integer.pareInt(str); String-&gt;Integer 1234//1.构造方法Integer t4 = new Integer(str);//2.Integer的静态方法valueOfInteger t5 = Integer.valueOf(str); Integer-&gt;String 1234//1.String提供的toString方法String str1 = t4.toString();//2.String提供的静态valueOfString str2 = String.valueOf(t4); 总结 Integer.valueOf()可以将int/String转换为Integer对象 String.valueOf()可以将int/Integer转换为String对象 new Integer()可以将int/String转换为Integer对象 int和Integer之间的区别 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。 泛型不支持int，但是支持Integer int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。 判断题123456789101112131415161718192021222324Integer i = new Integer(12);Integer j = new Integer(&quot;12&quot;);Integer o = new Integer(12);System.out.println(i==o);System.out.println(i==j);Integer i1 = Integer.valueOf(12);Integer i2 = Integer.valueOf(&quot;12&quot;);System.out.println(i1==i2);Integer i3 = Integer.valueOf(300);Integer i4 = Integer.valueOf(&quot;300&quot;);System.out.println(i3 == i4);Integer i5 = Integer.valueOf(128);Integer i6 = Integer.valueOf(128);System.out.println(i5 == i6);Integer i7 = new Integer(&quot;10&quot;);Integer i8 = Integer.valueOf(10);int i9 = 10;System.out.println(i7 == i9);System.out.println(i8 == i9);System.out.println(i7 == i8); Objectjava.lang.Object类是所有的类的基类,根类,超类 所有的类如果没有明确指定父类,都会默认继承Object类. equal方法页内认可的一种说法 - 基本类型用==比较的是值,对象类型用==比较的是地址 boolean equals(Object obj); 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 默认的比较方式不符合实际的业务需要,因此需要重写equals方法 一个小实例[注意观察equal方法的重写] Product.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package tech.aistar.day10.obj;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/28 11:01 * @description */public class Product &#123; private Integer id; private String name; private Double price; private ProductInfo info; public Product() &#123; &#125; public Product(Integer id, String name, Double price) &#123; this.id = id; this.name = name; this.price = price; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; public ProductInfo getInfo() &#123; return info; &#125; public void setInfo(ProductInfo info) &#123; this.info = info; &#125; @Override public boolean equals(Object obj)&#123; //1.非空性 if(obj == null) return false; //2.自反性 if(this == obj) return true; //3.一致类型,判断具体的哪个属性是一致的,才认为返回true if(obj instanceof Product)&#123; Product p = (Product) obj; return this.id == p.id &amp;&amp; this.getInfo().equals(p.getInfo()); &#125; return false; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Product&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&quot;, price=&quot;).append(price); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; ProductInfo.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 11:06 * @description */public class ProductInfo &#123; private Integer id; private String info; public ProductInfo() &#123; &#125; public ProductInfo(Integer id, String info) &#123; this.id = id; this.info = info; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; /** * 重写父类的equals方法,判断id相等时equals为真 * @param obj * @return */ @Override public boolean equals(Object obj)&#123; // 1.非空性 if(null == obj) return false; // 2.自反性 if(this == obj) return true; // 3.一致性判断,判断具体的哪个属性是一致的,才认为是返回true if(obj instanceof ProductInfo)&#123; // 强制转换 ProductInfo pf = (ProductInfo) obj; return this.id == pf.id; &#125; return false; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;ProductInfo&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, info=&#x27;&quot;).append(info).append(&#x27;\\&#x27;&#x27;); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; TestProduct.java 1234567891011121314151617181920212223package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 11:11 * @description equals方法的测试类 */public class TestProduct &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac2&quot;,10000.0d); ProductInfo info1 = new ProductInfo(1,&quot;好产品&quot;); p1.setInfo(info1); Product p2 = new Product(1,&quot;mac&quot;,20000.0d); ProductInfo info2 = new ProductInfo(1,&quot;坏产品&quot;); p2.setInfo(info2); boolean flag = p1.equals(p2); System.out.println(p1.equals(p2));//true System.out.println(p1 == p2);//false &#125;&#125; hashCode方法int hashCode(); 用于返回对象的哈希值,一般是和equals方法成对出现的,目的是为了提高效率 容器应用中 - 在什么时候才会去调用equals方法? - 当哈希碰撞的时候,只要哈希不冲突,不会调用equals方法 而调用equals方法执行的时机肯定会慢一点的.因为它需要比较属性值[需要更多的时间] 一个小实例 Course.java 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.day10.hashcodes;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/28 19:58 * @description */public class Course &#123; private Integer id; private String name; @Override public boolean equals(Object o) &#123; System.out.println(&quot;equals..&quot;); if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Course course = (Course) o; return Objects.equals(id, course.id); &#125; @Override public int hashCode() &#123; System.out.println(&quot;hash...&quot;); return Objects.hash(id); &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Course&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; TestCourse.java 123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.day10.hashcodes;import java.util.HashSet;import java.util.Objects;import java.util.Set;/** * @Author liuWenXiu * @Date 2021/7/28 19:58 * @description */public class TestCourse &#123; public static void main(String[] args) &#123; Course c1 = new Course(1,&quot;java&quot;); Course c2 = new Course(2,&quot;mysql&quot;); Course c3 = new Course(3,&quot;php&quot;); Course c4 = new Course(4,&quot;c#&quot;); Course c5 = new Course(5,&quot;c++&quot;); Course c6 = new Course(6,&quot;python&quot;); Course c7 = new Course(1,&quot;oracle&quot;);// System.out.println(c1==c2); //false;// System.out.println(c1.equals(c7));//true // 集合 - &quot;容器&quot; 比数组更加强大 Set&lt;Course&gt; sets = new HashSet&lt;&gt;(); sets.add(c1); sets.add(c2); sets.add(c3); sets.add(c4); sets.add(c7); for (Course c : sets) &#123; System.out.println(c); &#125; &#125;&#125; 运行结果 12345678910hash...hash...hash...hash...hash...equals..Course&#123;id=1, name=&#x27;java&#x27;&#125;Course&#123;id=2, name=&#x27;mysql&#x27;&#125;Course&#123;id=3, name=&#x27;php&#x27;&#125;Course&#123;id=4, name=&#x27;c#&#x27;&#125; 总结 如果两个对象hashcode值一样,将会使用equals进行比较,不一定返回true 如果两个对象equals返回true,那么这两个对象的哈希值一定是一样的. - 数据的完整性 笔试题 == 和equals的区别 ==基本类型使用,比较的就是基本类型的数值 equals对象类型使用,如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true. clone方法protected Object clone(); //默认的克隆方法是浅克隆 浅克隆浅拷贝,浅层复制,浅复制 - 默认的 直接生成的clone方法 1234@Overrideprotected Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; 要对其进行修改,将protected修改成public 123456@Overridepublic Object clone() throws CloneNotSupportedException &#123;return super.clone();&#125;Object中的clone方法 - native修饰的方法 - 本地方法栈中的方法 - C写的 - Java语言本地调用C程序.protected native Object clone() throws CloneNotSupportedException; clone方法的使用**:只有实现了java.lang.Cloneable接口[标记接口]的对象才能够调用clone方法,否则会抛出java.lang.CloneNotSupportedException不支持克隆的异常.** 12345try &#123; Product copy = (Product) p1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 关于clone的测试实例 1234567891011121314151617181920212223242526272829303132package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 20:14 * @description */public class TestCloneDemo &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac&quot;,1000.0d); ProductInfo info = new ProductInfo(1,&quot;good&quot;); p1.setInfo(info); // 浅拷贝 try &#123; Product copy = (Product) p1.clone(); // 1. 修改基本类型/String类型 p1.setId(2); p1.setName(&quot;Sakura&quot;); // 2.修改对象类型 p1.getInfo().setId(3); p1.getInfo().setInfo(&quot;bad&quot;); System.out.println(copy); System.out.println(copy.getInfo()); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果: 12Product&#123;id=1, name=&#x27;mac&#x27;, price=1000.0&#125;ProductInfo&#123;id=3, info=&#x27;bad&#x27;&#125; 浅拷贝:修改原来对象的基本数据类型以及字符串不会对拷贝的新对象产生影响,修改原来对象的对象类型数据会对拷贝的新对象产生影响 深克隆深层复制,深拷贝,深复制 - 需要自己重写clone里面的具体的代码的 12345678910111213141516171819 @Override public Object clone() throws CloneNotSupportedException &#123;// return super.clone(); // 手动创建一个Product对象 Product pf = new Product(); pf.setId(this.id); pf.setName(this.name); pf.setPrice(this.price); ProductInfo info = pf.getInfo(); //! 注意这里首先要判断info是否为空,因为info有可能还没有被赋值 if(info!=null)&#123; ProductInfo pi = new ProductInfo(); pi.setId(info.getId()); pi.setInfo(info.getInfo()); // 最后为pf设置 pf.setInfo(pi); &#125; return pf; &#125; 深拷贝每次都创建一个新的对象,所以是很消耗时间的.","categories":[],"tags":[{"name":"Integer","slug":"Integer","permalink":"http://beautifulboyy/tags/Integer/"},{"name":"深拷贝浅拷贝","slug":"深拷贝浅拷贝","permalink":"http://beautifulboyy/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"Date和Calendar的使用","slug":"java02","date":"2021-07-25T08:50:47.000Z","updated":"2021-08-02T02:12:35.376Z","comments":true,"path":"2021/07/25/java02/","link":"","permalink":"http://beautifulboyy/2021/07/25/java02/","excerpt":"","text":"Date api:java.util.Date[C] - 使用这个类之前,必须要导包import 这是java中提供的关于日期的处理,内置的对象类型.它本身是一个过时的类 里面提供了很多已经过时的方法. 目标:掌握这个类中提供的方法 构造方法构造方法 - 创建这个类的对象的方式 在使用api时首先观察该类提供的方法是静态的还是动态的,发现Date类中提供的方法几乎都是非静态的,所以必须创建该类的对象从而调用方法. 构造方法通过new关键字调用 1234567891011121314151617// 方法1:空参构造函数Date d = new Date(); //这个Date指的是当前的时间// 打印这个日期对象System.out.println(d); //结果:Wed Jul 21 18:50:26 CST 2021// 方法2:重载的构造方法[有参构造方法] - 已经过时,不再使用// 以下代码表示创建日期为2021年7月21日// 年份需要减去1900 月份需要-1Date d2 = new Date(2021-1900,6,21);System.out.println(d2); //结果:Wed Jul 21 00:00:00 CST 2021// 方法3:利用毫秒数[时间戳]来构建一个Date对象// 毫秒数表示距离1970经过那么多毫秒到现在的时间// 注意:毫秒数的类型是long型的Date d3 = new Date(1626828910303L);System.out.println(d3); //结果:Wed Jul 21 08:55:10 CST 2021 一个小练习:计算三天之后的此时此刻 1234567// 首先获取当前时间Date date = new Date();// 获取当前毫秒数并且加上三天的毫秒数long time = date.getTime() + 3L*24*60*60*1000;Date threeDayAfter = new Date(time);System.out.println(date); //结果:Wed Jul 21 19:00:03 CST 2021System.out.println(threeDayAfter); //结果:Sat Jul 24 19:00:03 CST 2021 常用方法由api知方法几乎都是非静态方法,需要**日期对象.方法名()**进行调用 long getTime();返回当前日期的毫秒数的表现形式 获取当前系统时间的毫秒数.距离1970年1月1日 123// 我们可以通过设置毫秒数来构建Date对象,当然也可以通过Date对象获取毫秒数long nowTime = d.getTime(); //获取当前时间的时间戳System.out.println(nowTime); //结果:1626865041991 get/set方法 - 过时的 void setYear(int year); //year-1900 void setMonth(int month); //month的范围[0,11] void setDate(int date); //设置今天是几号 void setHours(int hours); //设置小时 void setMinutes(int minutes); //设置分钟 void setSeconds(int seconds); //设置秒钟 12345678910111213System.out.println(&quot;------------Date对象的set方法---------------&quot;);Date now = new Date();now.setYear(2020-1900); //设置年份为2020年now.setMonth(5); //设置月份为6月now.setDate(25); //设置日期为25日System.out.println(now); //结果:Thu Jun 25 19:02:19 CST 2020System.out.println(&quot;------------Date对象的get方法---------------&quot;);System.out.println(&quot;year:&quot;+(now.getYear()+1900));System.out.println(&quot;month:&quot;+(now.getMonth()+1));System.out.println(&quot;date:&quot;+now.getDate());System.out.println(&quot;day:&quot;+now.getDay()); //星期几 [周一,周六]=[1,6] 周日为0System.out.println(&quot;hours:&quot;+now.getHours()); setTime()方法,通过设置毫秒数重新设置Date 1234// 利用setTime(毫秒数)设置DateDate dd = new Date();dd.setTime(1726830007794L);System.out.println(dd); //结果为:Fri Sep 20 19:00:07 CST 2024 Calendarjava.util.Calendar是一个抽象类,它不能被new 常用方法 static Calendar getInstance(); 12// 获取当前系统的日历对象Calendar cal = Calendar.getInstance(); //底层使用到了简单工厂的设计模式 设置日历字段 12345678void set(int year, int month, int date)设置日历字段中的值 YEAR ， MONTH和 DAY_OF_MONTH 。void set(int year, int month, int date, int hourOfDay, int minute)设置日历字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY和 MINUTE 。void set(int year, int month, int date, int hourOfDay, int minute, int second)设置字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY ， MINUTE和 SECOND 。 单独针对单个字段一一进行赋值 12345void set(int field,int value);只要看到field//公开的静态的常量属性public static final int YEAR = 1; 获取日历字段 123Date getTime();//获取日历信息中关于日期部分的信息 - Calendar转成Date类型int get(int field);//关于获取日历指定字段的值 123456789101112131415//Calendar.YEAR -&gt; 年份System.out.println(cal.get(Calendar.YEAR));// 这样就可以获取到年份是2021年// 增加程序的可读性// Calendar.DATE -&gt; 获取日期System.out.println(cal.get(Calendar.DATE));// Calendar.DAY_OF_MONTH -&gt; 获取日期[一个月之中的第几天]System.out.println(cal.get(Calendar.DAY_OF_MONTH));// 上面两个域都是一样的,都是5,所以他俩表示的是同一个意思// Calendar.DAY_OF_WEEK -&gt; 一周中的第几天 [周日,周六]-[1,7]System.out.println(cal.get(Calendar.DAY_OF_WEEK));// Calendar.MONTH -&gt; 获取月份 [0,11]System.out.println(cal.get(Calendar.MONTH)); 总结 毫米数 -&gt; Date Date提供的构造方法 1Date d1 = new Date(1626869108538L); Date提供的setTime(long 毫秒数)方法 1d1.setTime(1726869108538L); Date -&gt; 毫米数 Date提供的getTime()方法 1long l = d1.getTime(); Calendar -&gt; Date Calendar提供的getTime()方法 12Calendar cal = Calendar.getInstance();Date d2 = cal.getTime(); Date -&gt; Calendar Calendar提供的setTime(Date d)方法 1cal.setTime(d1); 一个综合练习题给定一个年份和月份,在idea控制台输出该日历,形式如下 相关api:java.util.Date和java.util.Calendar 123456789请您输入年份:2021请您输入月份:7 2021年7月日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package tech.aistar.day05;import tech.aistar.util.DateUtil;import java.util.Calendar;import java.util.Scanner;/** * @Author liuWenXiu * @Date 2021/7/21 19:07 * @description 打印日历 */public class PrintCalendar &#123; public static void main(String[] args) &#123; // 根据题意分析: // 1.首先获取键盘输入的年份和月份 Scanner sc = new Scanner(System.in); System.out.print(&quot;请您输入年份:&quot;); int year = sc.nextInt(); System.out.print(&quot;请您输入月份:&quot;); int month = sc.nextInt(); // 2.根据年份和月份打印日历 print(year,month); &#125; /** * 根据年份和月份打印日历 * @param year * @param month */ public static void print(int year,int month)&#123; // 1.判断键盘输入的合法性 // 1.1 year是否合法,如果year&lt;0,则不合法 if(year&lt;0)&#123; System.out.println(&quot;年份不合法!&quot;); return; &#125; // 1.2 month是否合法,如果month&lt;0或month&gt;12,则不合法 if(month&lt;0 || month&gt;12)&#123; System.out.println(&quot;月份不合法!&quot;); return; &#125; // 2.打印日历中的标题 例如2021年7月 System.out.println(&quot;\\t\\t&quot;+year+&quot;年&quot;+month+&quot;月&quot;); // 3.打印日历中的星期 System.out.println(&quot;日\\t一\\t二\\t三\\t四\\t五\\t六&quot;); // 4.确定某年某月的1号是周几 int week = DateUtil.getWeek(year,month,1); // 5.确定某年某月的最大天数 int maxDays = DateUtil.getMaxDay(year, month); // 6.确定今天是几号 int date = Calendar.getInstance().get(Calendar.DATE); // 7.打印结果 // 7.1 先根据某年某月的1号是星期几先打印出一号 // 假设1号是星期三 那么星期日星期一星期二的位置都打\\t // 还需要定义一个计数器,当计数器=7时换行,不管打&quot;\\t&quot;还是具体时间都要++ int count = 0; for(int i=0;i&lt;week;i++)&#123; System.out.print(&quot;\\t&quot;); count++; &#125; //经过了这个for循环以后我们找到了1号所在的位置 // 然后开始逐个打印日期,从1~最大天数,每当count=7时换行 for(int i=1;i&lt;=maxDays;i++)&#123; System.out.print(i+&quot;\\t&quot;); count++; if(count==7)&#123; System.out.println(); count=0; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.util;import java.util.Calendar;/** * 本类用来演示:自定义的日期工具类 - 推荐定义成static */public class DateUtil &#123; /** * 判断某年某月的最大天数 * @param year * @param month * @return */ public static int getMaxDay(int year,int month)&#123; int days = 31; if(month==4 || month==6 || month==9 || month==11)&#123; days = 30; &#125;else if(month ==2)&#123;// if(isLearYear(year))&#123;// days = 29;// &#125;else&#123;// days = 28;// &#125; days = isLeapYear(year)?29:28; &#125; return days; &#125; /** * 根据年份月份和日期返回星期 * @param year 年 * @param month 月 * @param date 日 * @return 星期几 */ public static int getWeek(int year,int month,int date)&#123; // 1. 首先构建Calendar对象 Calendar cal = Calendar.getInstance(); // 2. 设置年份和月份 // 注意一下这个月份:用户输入的是6表示要6月 而在程序中必须-1 cal.set(year,month-1,date); // 3. 返回星期 // 注意一下这个星期:[周日,周六] -&gt; [1,7] return cal.get(Calendar.DAY_OF_WEEK)-1; &#125;&#125;","categories":[{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Date","slug":"Date","permalink":"http://beautifulboyy/tags/Date/"},{"name":"Calendar","slug":"Calendar","permalink":"http://beautifulboyy/tags/Calendar/"}]},{"title":"抽象类和接口","slug":"java07","date":"2021-07-23T12:18:40.000Z","updated":"2021-08-02T06:04:12.535Z","comments":true,"path":"2021/07/23/java07/","link":"","permalink":"http://beautifulboyy/2021/07/23/java07/","excerpt":"","text":"抽象类抽象类的特点 抽象类天生就是用来被子类继承的,抽象类天生就是不能够被外部进行实例化的. 抽象类使用abstract来进行修饰 普通类是没有子类去定义抽象方法的,换句话说,只有抽象类能定义抽象方法 抽象方法也是使用abstract修饰的,抽象方法是指没有方法体的方法.抽象的方法天生也是被子类用来重写的. 抽象类是一种抽象的数据类型 抽象类继承的特点 如果某个普通的子类继承了抽象类,那么这个子类必须要重写这个抽象父类中所有的抽象方法. 如果某个子类继承了抽象类,不想重写抽象父类中所有的抽象方法,那么需要将这个子类也定义成抽象类. 不能一起混用的修饰符 final和abstract不能一起使用 private和abstract不能一起修饰方法 static和abstract不能一起修饰方法. static不存在多态 接口接口的特点 属于抽象的数据类型,也会不能够被实例化的. 接口中不允许定义普通属性也不允许出现构造方法. jdk8.x允许在接口中使用default关键字来定义普通方法 接口也是用来定义抽象的方法的,接口中的方法都是抽象的方法.[不准确] 接口的属性都是公开的静态的常量属性 定义接口的关键字是interface,编译之后也是.class字节码文件. 接口也可以定义静态方法. 接口的命名规则通常以I开头或者able结尾 一个接口的使用实例 123456789101112131415161718192021public interface Userable &#123; // 接口的属性都是公开的静态的常量属性 //public static final int YEAR = 1; // 简写 //public int YEAR = 1; // 再简写 int YEAR =1; //jdk8.x之前不允许定义普通方法 // 之后可以通过default方法来定义普通方法 public default void test()&#123; System.out.println(&quot;test..&quot;); &#125; // 接口中的方法应该都是抽象的方法 //public abstract void add(); // 简写 //public void add(); // 再简写 void add();&#125; 12345678910111213public class UserableImpl implements Userable&#123; @Override public void add() &#123; System.out.println(&quot;impl1...&quot;); &#125;&#125;public class UserableImpl2 implements Userable&#123; @Override public void add() &#123; System.out.println(&quot;impl2...&quot;); &#125;&#125; 12345678public class TestUserable &#123; public static void main(String[] args) &#123; Userable u1 = new UserableImpl(); u1.add(); Userable u2 = new UserableImpl2(); u2.add(); &#125;&#125; 结果 impl1… impl2… 接口的规则 接口和类 接口天生是用实现类来实现的 - implements 普通的类去实现某个接口的话,必须要实现这个接口中所有的抽象方法 如果抽象的类去实现某个接口的话,可以选择实现或者不实现.[如果不实现的话就让子类去实现] 一个接口可以拥有多个实现类. 一个类可以同时实现多个接口,接口之间用逗号隔开,需要实现这些接口中所有的抽象方法. 接口和接口 一个接口可以继承多个接口,接口是支持多重继承的. 接口的应用提供了一种”契约机制”,屏蔽了底层的具体实现,为了程序的拓展 - 在开发中会体会到. 作用 - 指定开发的这个软件的功能 - “业务方法” 接口的分类 业务接口 - 该接口中只定义抽象方法 常量接口 - 该接口中只定义了常量属性,用于管理系统中所有的常量属性.jdk5.x使用了枚举类型来替代常量接口. 标记接口 - 什么都没有,用来做标记的. 1234567public interface IA&#123;&#125;public class Aimpl implements IA&#123; ...&#125;Aimpl a = new Aimpl();System.out.println(a instanceof IA); //true 函数式接口 - jdk8.x - lambda表达式 里面只有一个抽象方法的接口 - @FunctionnallInterface 1234@FunctionalInterfacepublic interface Funable &#123; int add(int a,int b);&#125; 123456class FunableImpl implements Funable&#123; @Override public int add(int a, int b) &#123; return a+b; &#125;&#125; 匿名内部类 123456Funable f = new Funable()&#123; @Override public int add(int a, int b) &#123; return a+b; &#125;&#125;; lambda表达式 123Funable f = (a,b)-&gt;&#123;return a+b;&#125;;// lambda表达式看起来真的很简单 可是真的有点难理解System.out.println(f.add(10,20)); 抽象类和接口的异同 相同点 接口和抽象类都不能被实例化,他们都位于继承树顶端,用于被其他类继承或实现 接口和抽象类都可以包含抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法,但若是该子类是抽象的,则可以选择实现也可以选择不实现. 不同点 接口中只能包含抽象方法,静态方法,和默认方法,不能定义普通方法,而抽象类中可以包含普通方法. 接口中只能定义静态常量,而抽象类中可以定义普通成员变量,也可以定义静态常量 接口中不能有构造器,而抽象类中可以有. 接口里不能包含初始化块,而抽象类可以包含初始化块. 一个子类中最多只能继承一个抽象类,而一个实现类可以同时实现多个接口.","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"http://beautifulboyy/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"接口","slug":"接口","permalink":"http://beautifulboyy/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"面向对象程序设计","slug":"java06","date":"2021-07-21T12:18:40.000Z","updated":"2021-08-04T13:03:49.387Z","comments":true,"path":"2021/07/21/java06/","link":"","permalink":"http://beautifulboyy/2021/07/21/java06/","excerpt":"","text":"面向对象程序设计 java语言属于面向对象的语言 面向对象本身不是一门具体的技术,符合人类思维的思想. 宗旨:把一个复杂的大型的业务,利用面向对象的思想进行面向对象的分析, 接着面向对象的设计,最终进行面向对象的编程. 对象是数据在内存中的”载体” 类和对象 类是抽象的概念,对象是具体的概念 类是构建对象的蓝图/模板,对象是类的具体的实例化[表现] 类是用来描述对象的. 面向对象的思想核心:”一切皆对象” ①分析出系统中业务的关键对象 - “找对象” - 未来页面上显示的数据 ②找出对象的**”属性”** - “对象拥有什么” ③分析出对象的”方法” - “对象可以干什么,对象的功能” ④找出对象与对象之间的关系. 12345671:1 - 一个丈夫对应一个妻子,一个妻子对应一个丈夫.1:N - 一个客户拥有多个订单.一个订单只能属于一个客户 - 70%N:N - 一个学生可以选择多门课程,一门课程可以被多个学生来选择.自关联 - 自己关联自己. ⑤最后一步才会去考虑具体怎么编码实现.可能也会考虑数据结构或者算法. “相亲业务” - 媒婆帮你找一个”对象” 你要查看”对象”的属性 询问”对象”的功能 分析你和”对象”是否来道🌩 考虑 - 追 - 彩礼 - 结婚 - 具体怎么实现! 面向过程的思想C是典型的面向过程的思想 ①优先考虑的就是算法和数据结构 - 考虑的就是具体怎么实现. 实体类实体类就是用来描述对象的. 实体类中包含属性,构造方法,getter/setter方法,toString方法. 如何定义属性语法:修饰符 数据类型 属性名 [=初始值]; 修饰符 public 公开的 private 私有的 数据类型 八种基本数据类型 内置对象类型以及自定义对象类型. 属性名参考变量的命名 - “小驼峰” this关键字this是自身的一个对象,代表对象本身,可以理解为:指向对象本身的一个指针. 普通的直接引用 this相当于指向当前对象本身 形参与成员名字重名,用this进行区分 12345678910class Person&#123; private int age = 10; public Person()&#123; System.out.println(&quot;初始化年龄:&quot;+age); &#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; 调用本类中另一种形式的构造函数(应该为构造函数中的第一条语句) super关键字super可以理解为指向自己最近父类对象的指针. 普通的直接引用 通过super.xxx来引用父类中的非私有成员 子类中的成员变量或方法与父类中的成员变量或方法同名时进行区分 123456789101112131415class Country&#123; String name; void value()&#123; name = &quot;China&quot;; &#125;&#125;class City extends Country&#123; String name; void value()&#123; name = &quot;Shanghai&quot;; super.value(); //调用父类中的方法啊 System.out.println(name); System.out.println(super.name); &#125;&#125; 调用父类中的某一个构造函数(应该为构造函数中的第一条语句) toString方法 当我们直接输出对象的时候,默认一定会去调用toString方法 - 如果这个对象是null,那么不会调用toString方法的 当自定义的实体类中没有手动提供toString方法,那么这个对象会自动去调用java.lang.Object类中的toString方法 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; java.lang.Object - 它是所有的类的根类,基类,超类,父类. 如果某个类没有明确指定它的父类,那么这个类默认会直接继承java.lang.Object类 “User类是Object类的儿子” - 规定 - “子类可以调用父类中所有的公开的成员“ Object类中提供的toString方法只能用来返回对象的内存地址 - 不满足实际的打印需求 所以需要在实体类中重新重写这个toString方法. 当子类User类一旦重写了toString方法之后,那么就会采取”就近原则”,直接调用自己重写之后的toString方法. 构造方法-constructor作用:创建对象的时候调用构造方法,通过new关键字 可以在创建对象的同时进行赋值操作,赋值的方式只有1次,setter赋值,可以多次赋值 特点 当实体类中如果没有手动提供任何一个构造方法的时候,那么系统会自动分配一个空参构造.如果实体类中一旦手动提供了带参构造之后,那么系统将不会再分配一个空参构造了. 定义的时候,不需要返回类型的 123public 类名([参数列表])&#123; //构造体&#125; 构造允许重载的 实体类中推荐只用提供空参,全参 OO练习业务类和实体类合二为一将业务方法放在实体类中 - 违背了设计原则 - “单一职责原则”. 不要给一个类增加太多的负担. 实体类 - 主要描述的对象,数据在内存中的载体,注重的应该是数据的存储. 业务类 - 存放的是业务的方法 - 在于操作这些数据 实例:设计一个员工类[编号id,姓名name,工资salary],业务方法[crud增删改查]放在实体类中,这是不合理的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package tech.aistar.day06;import java.util.Arrays;/** * @Author liuWenXiu * @Date 2021/7/22 9:22 * @description 员工类 * * 在这个实例中学习到:在进行功能的实现时一定要先判断参数的合法性等 */public class Emp &#123; private int id; private String name; private double salary; //一个上司拥有多个下属 //一个下属对应一个上司 //自关联 private Emp[] emps; //构造,getter/setter,toString public Emp() &#123; &#125; public Emp(int id, String name, double salary, Emp[] emps) &#123; this.id = id; this.name = name; this.salary = salary; this.emps = emps; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Emp[] getEmps() &#123; return emps; &#125; public void setEmps(Emp[] emps) &#123; this.emps = emps; &#125; //给上司添加一个下属 public void addEmp(Emp e)&#123; // 同样需要判断 if(null != this.emps)&#123; //数组的扩容Arrays.copyOf(数组对象,新的长度); this.emps = Arrays.copyOf(this.emps,this.emps.length+1); this.emps[emps.length-1] = e; &#125;else&#123; System.out.println(&quot;对不起,您没有资格添加员工.&quot;); &#125; &#125; //输出下属的个数 public void printEmpCount()&#123; // 防止下属调用这个方法 if(null == this.emps)&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); return; &#125; System.out.println(&quot;员工个数:&quot;+this.emps.length); &#125; //输出某个上司所有的下属信息 public void printEmp()&#123; //同样需要进行判断 if(null != this.emps &amp;&amp; this.emps.length&gt;0)&#123; System.out.println(&quot;下属信息如下:&quot;); for (int i = 0; i &lt; this.emps.length; i++) &#123; System.out.println(this.emps[i]); &#125; &#125;else&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); &#125; &#125; /** * 根据id删除员工 * @param id */ public void delById(int id)&#123; // 又忘了判断合法性!!!! if(this.emps!=null &amp;&amp; emps.length&gt;0)&#123; // 员工的编号是唯一的,因此新的员工列表的长度是原来长度-1 Emp[] temp = new Emp[this.emps.length-1]; int post = 0; for (int i = 0; i &lt; this.emps.length; i++) &#123; if(this.emps[i].getId() == id) continue; temp[post++] = this.emps[i]; &#125; this.emps = temp; &#125;else&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125;&#125; 业务类和实体类分开业务方法应该专门抽取出来放到一个业务类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package tech.aistar.day06.biz;/** * @Author liuWenXiu * @Date 2021/7/22 10:25 * @description Emp实体类 - 数据的存储 */public class Emp &#123; private int id; private String name; private double salary; private Emp[] emps; public Emp() &#123; &#125; public Emp(int id, String name, double salary, Emp[] emps) &#123; this.id = id; this.name = name; this.salary = salary; this.emps = emps; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Emp[] getEmps() &#123; return emps; &#125; public void setEmps(Emp[] emps) &#123; this.emps = emps; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package tech.aistar.day06.biz;import java.util.Arrays;/** * @Author liuWenXiu * @Date 2021/7/22 10:28 * @description 业务类 - 业务方法 */public class EmpBiz &#123; /** * 将新的员工添加上司的下属数组中 * @param boss 上司 * @param e 员工 */ public void addEmp(Emp boss,Emp e)&#123; // 1. 判断 Emp[] emps = boss.getEmps(); if(emps!=null)&#123; emps = Arrays.copyOf(emps,emps.length+1); emps[emps.length-1] = e; // 注意一下这里的set 很重要 boss.setEmps(emps); &#125;else&#123; System.out.println(&quot;对不起,您没有资格添加下属.&quot;); &#125; &#125; /** * 打印下属 * @param boss */ public void printEmp(Emp boss)&#123; Emp[] emps = boss.getEmps(); if(emps!=null &amp;&amp; emps.length&gt;0)&#123; System.out.println(&quot;下属信息:&quot;); for (Emp emp : emps) &#123; System.out.println(emp); &#125; &#125;else&#123; System.out.println(&quot;对不起,您没有下属&quot;); &#125; &#125; /** * 删除工资高于salary的员工 * @param boss * @param salary */ public void delBySalary(Emp boss,double salary)&#123; // 1. 首先需要获取boss的所有员工 Emp[] emps = boss.getEmps(); if(emps!=null)&#123; // 2.遍历员工信息,记录需要删除的个数 // 定义一个计数器 int count = 0; for (Emp emp : emps) &#123; if(emp.getSalary()&gt;salary)&#123; count++; &#125; &#125; // 3.此时我们就已经知道了需要删除的个数,可以创建新的数组 Emp[] temp = new Emp[emps.length-count]; // 4.遍历旧的数组 // 定义新的数组下标 int post = 0; for (Emp emp : emps) &#123; if(emp.getSalary()&lt;=salary)&#123; temp[post++] = emp; &#125; &#125; // 5.得到的temp就是删除后的数组,再将它赋值给boss.emps boss.setEmps(temp); &#125;else&#123; System.out.println(&quot;对不起,您没有下属&quot;); &#125; &#125;&#125; 封装性- Encapsulation封装 - Encapsulation - 屏蔽底层的细节,数据提供保护的机制 属性私有化 提供getter/setter方法 setter方法 - set属性名[首字母变大写] - 推荐的命名规则 setter方法这种设置值的好处 2-1. setter方法中是可以进行参数有效性判断的. 2-2. 业务需求改变了 - 属性名称改变了,使用到这个属性的具体的地方都要发生改变 - “可维护性” 2-3. 并不是所有的属性的值都是通过那么太简单的计算得到的. 12345678910111213141516171819202122232425public class Orders&#123; private int id; private double price; private int count; private double total; //getter/setter - 提供好了 public double getTotal()&#123; double result = this.price * this.count; return result; &#125;&#125;Orders o = new Orders();o.setPrice(100.0);o.setCount(10);//o.setTotal(o.getPrice()*o.getCount());System.out.println(o.getTotal()); 2-4. 并不是所有的属性都需要对外进行公开的. 继承 - Inheritance将多个具有共同特点的对象抽象出一个”父类” 父类中存储的是各个子类共同的特点[属性]或者功能[方法] 继承的好处 - 提高了代码的复用性,使用多态的前提,为了代码的可拓展新 继承的缺点 - 增加了类与类之间的关系,不太符合软件的设计原则”高内聚,低耦合 ​ 低耦合 - 模块与模块之间/类与类之间的关系应该越弱越好 - 最好是没有关系 ​ 高内聚 - 单个模块/类能够独立完成某个业务功能的能力比较强 ​ 实际开发中,可以采用设计原则”合成复用原则 “- 来替代继承的使用 使用extends关键字来表示某个类继承某个父类 123456public class A&#123; &#125;public class B extends A&#123; //B继承于A&#125; B是A的子类,A是B的父类,基类,超类 A的父类就是java.lang.Object - 当某个类如果没有明确指定它的父亲是谁,那么这个类默认继承于Object. 子类可以访问到父类中所有的非私有成员 java的类只支持单继承,一个类只能继承一个父类,避免出现网状结构,保证类的层次性. java的接口支持多重继承,一个接口可以继承多个接口. 继承具有传播性 C extends B B extends A C间接继承于A,C也可以访问到A中所有的非私有成员 不要滥用继承,在使用继承时首先要确保B is A,比如说猫是动物等. super关键字必须放在构造方法的首行 调用父类的构造 在子类的构造方法中,如果没有出现任何的super语句,那么系统默认会给定super();调用父类的空参构造. 当在子类中调用了一个和父类中同名的成员的时候,需要通过super关键字来加以区分[强制调用父类中那个同名的成员] 多态 - polymorphism对象有多种形态,发生前提是具有继承关系 相同的消息可能会送给多个不同的类别之对象. 系统可以根据所属类别,引发对应类别的方法,而有不同的行为.简单来说,所谓多态意指相同的消息给予不同的对象会引发不同的动作. instanceof-&gt; 进行类型的判断,只有为true的时候才能够进行类型的强制转换. 在没有进行类型的判断,随便进行了一个强制类型转换,可能会抛出java.lang.ClassCastException类型转换失败异常. Animal父类 12345678910public class Animal &#123; private String name; public Animal()&#123;&#125; public Animal(String name)&#123; this.name = name; &#125; public void spark()&#123; System.out.println(&quot;动物在叫&quot;); &#125;&#125; Dog子类 123456789101112131415161718192021222324252627public class Dog extends Animal&#123; //子类定义各个子类特有的成员 private double loyalty; //忠诚度 public Dog()&#123; super(); //在子类的构造中,如果没有出现任何的super语句 // 那么系统默认会给定super(); // 调用父类的空参构造 System.out.println(&quot;Dog...&quot;); &#125; public Dog(String name,double loyalty)&#123; // 如果一旦提供了super(name),系统不会分配一个super() super(name); // 调用父类的一参 System.out.println(&quot;Dog全参构造&quot;); this.loyalty = loyalty; &#125; // 子类特有的方法 public void watchDoor()&#123; System.out.println(&quot;狗可以看门&quot;); &#125; // 重写父类中的spark()方法 @Override public void spark() &#123; System.out.println(&quot;汪汪&quot;); &#125;&#125; Cat子类 1234567891011121314151617181920public class Cat extends Animal &#123; private double cute; //萌度 public Cat()&#123; &#125; public Cat(String name,double cute)&#123; super(name); this.cute = cute; &#125; // 子类特有的方法 public void catMouse()&#123; System.out.println(&quot;猫猫会抓鼠鼠...&quot;); &#125; // 重写父类的方法 @Override public void spark() &#123; System.out.println(&quot;喵喵喵&quot;); &#125;&#125; Test类 123456789101112131415public static void main(String[] args) &#123; Animal d = new Dog(&quot;小可&quot;,200.0d); Animal c = new Cat(&quot;小喵&quot;,300.d); Animal[] animals = &#123;d,c&#125;; for (Animal animal : animals) &#123; animal.spark(); if(animal instanceof Dog)&#123; ((Dog) animal).watchDoor(); &#125; if(animal instanceof Cat)&#123; ((Cat)animal).catMouse(); &#125; &#125;&#125; 12345结果:汪汪狗可以看门喵喵喵猫猫会抓鼠鼠... final关键字不可更改,不可变 final修饰的变量/属性 - 不能够重新赋值 final修饰的类 - 不能够被继承 final修饰的方法 - 不能被重写 修饰符访问修饰符 - 决定了这个成员可以在哪里能够被访问. 所有包 子类[同/不同包] 同包 本类 public √ √ √ √ protected × √ √ √ 默认的 × × √ √ private × × × √ 安全级别:private&gt;默认的&gt;protected&gt;public 可见区域:public&gt;protected&gt;默认的&gt;private 方法的重写方法的重写的特点:发生的前提是要有继承关系 重写有一个特殊的场景 - 子类重写之后的方法的修饰符,返回类型,方法名,参数列表和父类中高度保持一致. - 重构 方法名必须一致. 参数列表要高度保持一致. 子类重写的方法的访问修饰符可以小于或者等于父类.[按照安全级别]比如说父类是protected,子类可以是protected或者public,不能是private或缺省. 子类重写的方法的返回类型可以小于[可以是父类方法的返回类型的子类类型]或者等于父类的那个方法 笔试题 - 方法的重载和方法的重写有什么区别? 方法的重载 重载的前提是在同一个类中. 重载的方法方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 方法的重写 重写的前提是要有继承关系 重写的方法名必须相同 重写的参数列表要高度保持一致 重写的方法访问修饰符的安全性可以小于或等于父类 重写的返回类型可以小于或等于父类 三种场景应用 面向父类编程 对象的编译时类型写成父类,对象的运行时类型写成子类. 编译时类型 对象名 = new 运行时类型(); 对象的编译时类型决定对象的访问能力 - “对象名只能访问到编译时类型中定义的成员” 对象的运行时类型决定了对象的行为能力 - “子类中如果一旦重写了父类中的方法,那么运行期间调用的是子类重写之后的方法” 方法的参数类型写成父类,调用这个方法的时候,可以传入这个父类的任意一个子类对象 方法的返回类型写成父类,方法的返回结果可以是这个父类的任意一个子类对象 - “简单工厂设计模式” 面向接口编程 对象的编译时类型写成接口,对象的运行时类型写成实现类 方法的参数类型写成接口,调用方法时可以传入这个接口的任意一个实现类. 方法的返回类型写成接口,方法的返回结果的类型可以是这个接口的任意一个实现类. 练习一12345678910111213141516171819202122232425262728293031323334public class Animal &#123; private String desc; public Animal() &#123; this.desc = getDesc(); &#125; public String getDesc() &#123; return &quot;Animal&quot;; &#125; public String toString() &#123; return desc; &#125;&#125;public class Worf extends Animal &#123; private String name; private double weight; public Worf(String name, double weight) &#123; this.name = name; this.weight = weight; &#125; public String getDesc() &#123; return &quot;Worf:&quot; + name + &quot;体重:&quot; + weight; &#125; public static void main(String[] args) &#123; System.out.println( new Worf(&quot;羊&quot;, 10)); &#125;&#125; 运行结果: Worf:null体重:0.0 练习二12345678910111213141516171819202122232425262728public class Super &#123; int i = 10; public Super() &#123; print(); i = 20; &#125; public void print() &#123; System.out.println(i); &#125;&#125;public class Sub extends Super &#123; int j = 30; public Sub() &#123; print(); j = 40; &#125; public void print() &#123; System.out.println(j); &#125; public static void main(String[] args) &#123; System.out.println(new Sub().j); &#125;&#125; 结果: 0 30 40","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Java入门","slug":"java01","date":"2021-07-21T11:33:04.000Z","updated":"2021-08-04T07:16:22.095Z","comments":true,"path":"2021/07/21/java01/","link":"","permalink":"http://beautifulboyy/2021/07/21/java01/","excerpt":"","text":"Java入门Java语言特点 简单 可移植性 面向对象 - 核心 跨平台性 安全性 - 本身是强类型语言,在编译期间就需要确定数据的类型 JDK和JRE和JVM 三者之间的区别 - 笔试简单题 JDK - Java Development Kit - Java开发工具包,针对开发者的,包含了很多的开发工具,比如java.exe,javac.exe,javadoc.exe,jar.exe等. JDK中是包含JRE的 JRE - Java Runtime Environment- Java运行时环境,包含了很多核心的内库.针对于使用Java语言开发出来软件的用户,如果一个用户仅仅想运行一个java程序的话,那么计算机中只需要安装jre即可. JRE中包含JVM JVM - Java Virtual Machine - Java虚拟机 [笔试的大头 - 内存模型] jvm本身是用C语言编写的 Java程序并不是直接在计算机中跑的,而是在虚拟机上执行的,虚拟机是安装在操作系统上的. java语言具有跨平台性[使用java语言编写的程序可以运行在不同的os上],但是jvm不具有跨平台性,不同的操作系统需要安装不同的jvm. HelloWorld程序java的基础单元是类class 标识符的命名 只能由字母,数字,下划线,$符号组成,但是不能以数字开头. 推荐使用”大驼峰”命名规则,单词首字母必须要大写,其余字母小写. 不能是jdk中内置的对象类型[String,System] 不能是java中的一些关键字,关键字-&gt;java语言赋予了这些单词具备一定的语法含义 byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue等等 不能是java中的保留关键词 - goto[汇编] const 不推荐使用中文,防止出现乱码问题 推荐见名知意 不能是以下三个字面量 - true,false,null 代码 首先在某目录下新建一个文件HelloWorld.java java的源文件就是以.java为后缀的文件 打开HelloWorld.java文件[记事本打开或Notepad++],输入以下代码 1234567public class HelloWorld&#123; // 规范 - 缩进四个空格 public static void main(String[] args)&#123; //方法体:现阶段代码一定是放在方法体内部的 System.out.println(&quot;HelloWorld&quot;); &#125;&#125; 在编程语言中,只要出现了符号,一定必须都是英文输入法下的. java以类作为基础的单位,关键字是class,并且类的名称要和文件的名称高度保持一致. 一对{}表示一个block - 块 - 代码块 main方法是程序的”大门”,运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main方法中执行 jdk中提供了内置的对象[拥有一些功能],开发者可以直接使用,例如java.lang.System类,向控制台输出一句话. java源代码不能够直接被执行,因为计算机不识别java语言程序. 需要对.java为后缀的源文件进行 一个编译操作,一旦语法发生了问题,编译就会失败 编译命令如下所示 1javac HelloWorld.java javac.exe工具其实就是在调用jdk中的编译器,将**.java源文件编译成.class字节码文件** 运行java程序命令如下所示 1java HelloWorld 过程首先编写.java源代码,再使用javac.exe进行编译,最后使用java.exe执行. 原理:.java源文件经过jdk中的编译器生成.class字节码文件,经过jvm中的解释器翻译成机器能够识别的符号. 注:java属于解释型的语言 可能会有题目说java属于半编译型半解释型语言,这是错误的.编译型语言比如C语言,它编写的程序字节编译成计算机能够执行的程序-&gt;xx.exe Java每次执行都会经过jvm解释器进行解释,因此C语言执行的性能高于java语言. Java中的包-package 包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用. 包的命名规则 2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录 2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号 com.baidu.car tech.aistar 2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中. 一旦创建了package,需要在类文件的首行采用package关键字来声明包. Java中的三种注释 单行注释// Ctrl+/ 添加/取消注释 多行注释 123/* 多行注释的内容 - 注释的内容是不会经过jdk的编译器的*/ 文档注释 可以生成文档树,一般放在类或方法上面 1234/***** 文档注释的内容*/ 注释的内容不会经过jdk的编译器,利用javac命令编译.java源文件生成.class文件,再进行反编译得到的.java文件不包含注释. main方法的细节123456//修饰符在使用的时候,之间是没有顺序的.public static void main(String[] args)&#123;...&#125; //okstatic public void main(String[] args)&#123;...&#125; //ok//jdk8中方法的参数支持可变长参数public static void main(String... args)&#123;...&#125; //ok//args是我们传给虚拟机的参数 输出语句12System.out.println();System.out.print(&quot;\\n&quot;); 特殊字符 \\代表转义字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day01;/** * 用来演示转义字符 */public class NrDemo &#123; public static void main(String[] args) &#123; // \\n换行 - 当输出完毕后,光标停在下一行的起始位置 System.out.println(&quot;hello\\n&quot;); System.out.println(&quot;world&quot;); /*结果 hello world * */ // \\r - 当输出完毕后,光标停在下一行的起始位置 System.out.println(&quot;LoveBoy\\r88&quot;); /*结果 88veBoy * */ // \\b - 退格 System.out.println(&quot;Hello\\bever&quot;); /*结果 Hellever * */ // \\t - 制表符,相当于tab键,默认是空4格 System.out.println(&quot;hello\\tworld&quot;); /*结果 hello world * */ // 双引号 \\&quot; System.out.println(&quot;james:\\&quot;sakura is a good girl\\&quot;&quot;); // 单引号 \\&#x27; // 单个\\ \\\\ System.out.println(&quot;D:\\\\temp\\\\news&quot;); // 输出\\\\ System.out.println(&quot;\\\\\\\\&quot;); &#125;&#125; 变量编程的核心就是从定义变量开始,java语言是一个强类型的语言,在编译期间必须要确定好数据的类型 变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作 但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库)] - JVM内存 “JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据” java中是如何定义和存储简单的这些数据呢? 就是通过数据类型以及变量来定义和存储的. 数据类型java的数据类型有两大块 基本数据类型(8种) - 编程思想中将void归纳为第9种 对象类型(无数种) 2.1内置对象类型 - System,String - JDK中提供的类 2.2自定义对象类型 - 自己定义的那些类 八种基本数据类型 名称 大小 范围 默认值 byte 字节 占1个字节8bit -128~127 0 short 短整型 占2个字节16bit -2^15~2^15-1 0 int 整型 占4个字节32bit -2^31~2^31-1 0 long 长整型 占8个字节64bit -2^63~2^63-1 0 float 单精度浮点数 占4个字节32bit +-(3.4*10^38) 0.0 double 双精度浮点数 占8个字节64bit +-(1.798*10^308) 0.0 char 字符 占2个字节16bit 0~65535 ‘\\u0000’空格 boolean 布尔类型 占1个字节8bit true/false false 这些都要记下来 变量的定义变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰” “小驼峰” - 首字母小写,其余每个单词的首字母大写.比如studentAge 1数据类型 变量名 [= 变量值]; 123456789101112131415161718192021222324252627282930313233package tech.aistar.day01;public class VarDemo &#123; public static void main(String[] args) &#123; //数据存储在JVM的内存当中 //定义在方法内部的变量 - 局部变量[JVM的栈区] // 局部变量的生命周期是伴随着方法(main)的调用的开始和结束 //1.JVM加载VarDemo.class到内存 //2.JVM找到main方法想要去执行里面的程序 //3.此时需要申请一块区域来保存数据10 // 3-1.区域的大小是由前面的数据类型来决定的 比如:int类型需要申请4个字节32bit的大小的区域 // 3-2.栈里面的区域大小一旦被确定了,就不能改变,这样有时就会导致内存的浪费 // 3-3.虽然控件浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot; 这也是为什么说栈的时间效率很高 //4.只要是内存中的空间,这个控件就必然会有一个地址,所以变量的存在是为了给这个区域取一个名字 // 比如说这个存储数据10的空间有一个地址,并且给它取了一个名字为a // 变量是为了方便用户来通过它访问到这个空间总存储的具体的那个值的. int a = 10; byte b = 10; short c = 20; long d = 10000; boolean e = true; float f = 13.14f; //注意一下float的定义喔! double g = 233.13; char h = &#x27;a&#x27;; System.out.println(a == b); &#125;&#125; 数据类型的转换一些小常识: a. java中看到一个整数,默认就是int类型 b.java中看到一个小数,默认就是double类型 c.大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方. 自动转换 小的数据类型可以自动转换成大的数据类型 123byte -&gt; short -&gt; int -&gt; longchar -&gt; intint -&gt; double 强制类型转换 大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作 123MaxType 变量1 = 值1;MinType 变量2 = (MinType)变量1; 1234567891011121314151617181920212223242526272829303132package tech.aistar.day01;/** * 数据类型的转换基础 */public class TypeChangeDemo &#123; public static void main(String[] args) &#123; //定义一个byte类型的数据[-128~127] byte b = 127; // 127 - 字面量,数字常量 - 不可改变的量 System.out.println(b); //变量 - 允许多次进行赋值 byte x = 126; //alt+enter可以自动进行强制转换 x = (byte) (x + 1); //注意一下:JVM看待字面量和变量是不同的. byte b2 = 127; //JVM判断出127是字面量,认为它是不可改变的. //JVM再次判断出127正好在byte类型的范围之内,所以精确判断出127可以存储在byte类型定义的变量中 //x = x + 1 这样就会报错 //jvm对待变量的方式,不关心这个变量中具体的数据到底是多大 //只要能够识别出x是byte类型,得出一个结论byte类型+int类型 = int类型 // 所以会报错 &#125;&#125; 一个小实例 12345boolean flag = true;while(flag)&#123; System.out.println(&quot;ddd&quot;);&#125;System.out.println(); 1234while(true)&#123; System.out.println(&quot;ddd&quot;);&#125;System.out.println(&quot;ddd&quot;); 在例子1中可以正常编译,例子2中会报错,就是因为JVM在对象常量和变量时的不同. 隐式转换 1234567int-&gt;long整数后面添加l/L double-&gt;float小数后面加上f/F 推荐在double后面加上d/D - 提高语义 变量的定义和使用八种数据类型的定义和使用 byte类型 1byte b = 127; short类型 - short很少使用 1short s = 155; int类型 - 存在多种情况 - java中的int类型表示的是十进制的数据 12345678//1.整数int a1 = 10;//2.二进制数:在定义二进制数时使用 0b二进制int a2 = 0b1010; //存储的是1010对应的十进制数10//3.字符int a3 = &#x27;a&#x27;; //存储的是字符&#x27;a&#x27;对应的ascii码(97)//4.八进制数:在定义八进制数时使用0八进制[以0开头]int a4 = 032; //存储的是032对应的十进制数26 long类型 - int类型可以自动转换为long类型 12long l1 = 145;long l2 = 1240L; //推荐此种定义方式,隐式转换法 补充:整型数再定义时可以用下划线将数字隔开,增加数字的可读性. 1234int x = 12_3_4_5;System.out.println(x); //结果为12345long l = 3_14_15_936L;System.out.println(l); //结果为31415936 float类型 - 两种方式 12345//1.强制类型转换float f1 = (float)1.34;//2.隐式转换float f2 = 1.34f;//以上两种结果都是一样滴 double类型 12double d1 = 1.25;double d2 = 1.25D; boolean类型 12boolean bl1 = true;boolean bl2 = false; char类型 java中使用单引号表示char类型,使用双引号来表示字符串 java的底层编码是unicode编码,char类型也是采用unicode编码 而unicode编码是双字节[16bit],所以可以用来存储汉字 12345678//1. 字符char c1 = &#x27;c&#x27;;//2. unicode码char c2 = &#x27;\\u5218&#x27;; //结果是刘//3. 汉字char c3 = &#x27;文&#x27;;//4. 数值char c4 = 48; //结果是0 char类型数的计算 - char类型在进行计算的时候会转换成ascii码来进行计算 123456789101112char n1 = &#x27;a&#x27; + 1; //结果是b// 过程: &#x27;a&#x27;-&gt;97 97+1=98 ascii码为98对应的字符是&#x27;b&#x27;char cc = &#x27;a&#x27;;//char nn = cc + 1;//这个会报错!因为cc是变量,并且是char类型的,char+int所以结果应该是int,不能赋值到char// 因此要进行强制转换char nn = (char)(cc + 1);//char--&gt;intint result = &#x27;a&#x27; + &#x27;b&#x27;; //ok//结果是97+98=195 变量的赋值 单个赋值:int a = 10; 通过表达式赋值 123int a = 10;int b = 20;int result = a + b; 链式赋值 1int a=19,b=20,c=39; //同时定义三个变量并进行初始化 先定义变量然后进行赋值 12int a;a = 10; 通过方法赋值 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用范围在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 12345678910111213141516171819202122package tech.aistar.day02;public class LocalVarAndGlobalDemo &#123; //定义全局变量 static int c = 100; public static void main(String[] args) &#123; //&#123;&#125;表示的是代码块 //局部变量 - 定义在方法体内部 int a = 10; &#123; //局部变量使用的范围就在它的最近的&#123;&#125;中 int b = 29; System.out.println(b); //ok System.out.println(a); //ok &#125; //System.out.println(b); //error 跳出&#123;&#125;以后b就无效了 System.out.println(c); //ok &#125;&#125; 常量使用final修饰的变量 - 常量 - 不可改变的量 语法: final 数据类型 变量 [= 初始值] 123456final int s = 100;// s = 200; //error 常量不可以改变final byte b = 100;byte result = b+1; //ok//如果不加final就会报错 运算符算术运算符12345678910111213141516171819201. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] + 123// + 在数值之间表示数值相加// + 在字符串之间表示连接System.out.println(1+2+3+&quot;&quot;+4+5); //结果为645 / 123System.out.println(9.0/2);//4.5System.out.println(9/2);//取整 4 % - 求模/余 1234567// 计算一个多位数每个位数的值int year = 2089;// 原则:任意数字%10 = 最末尾的数字System.out.println(year/1000); //千位数-2System.out.println(year/100%10); //百位数-0System.out.println(year/10%10); //十位数-8System.out.println(year%10); //个位数-9 ++ 和 – 123456789101112131415161718192021222324//现象//前++ 变量和表达式都会自增1int x1 = 1;int result1 = ++x1;System.out.println(&quot;result1:&quot;+result1);//2System.out.println(&quot;x1:&quot;+x1); //2//后++ , 变量仍然自增1,但是x2++的结果是这个x2变量自增之前的值// 表达式的结果是变量自增之前的值int x2 = 1;int result2 = x2++;System.out.println(&quot;result2:&quot;+result2);//1System.out.println(&quot;x2:&quot;+x2);//2System.out.println(&quot;========练习=========&quot;);int o1 = 1;int o2 = 1;//o1=2 o1=3 o2=0//o3 = 1 + 3 + 0 = 4int o3 = o1++ + ++o1 + --o2;//4 + 0int o4 = o3-- + o2++;System.out.println(&quot;o4:&quot;+o4); 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 1234567891011121314151617181920//条件表达式//逻辑与 - 短路与System.out.println(10&gt;3 &amp;&amp; 5&lt;3);//true//短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行.System.out.println(2&gt;3 &amp;&amp; 5&lt;3);//false//证明短路的特性int s1 = 1;System.out.println(5&gt;3 &amp;&amp; (++s1)&gt;10);System.out.println(s1);System.out.println(3&gt;2 || 2&lt;3);//trueSystem.out.println(!(2&gt;3));//trueSystem.out.println(10&gt;3 &amp; 3&gt;2);//trueSystem.out.println(10 &amp; 8); 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 连接条件:为true - 所有的条件表达式都是返回true 123456710 &amp; 8 = 810 对应的二进制数 - 1010 1 0 1 0 &amp;1 0 0 0-------------------- 1 0 0 0 -&gt; 对应的十进制8 | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:只要存在一个1,结果就是1 连接条件:为true - 只要存在一个条件表达式为true. 12345610 | 8 = 1 0 1 0 | 1 0 0 0-------------------- 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 12345678910111210 ^ 8 = 2 1 0 1 0 ^ 1 0 0 0-------------------- 0 0 1 0 -&gt; 对应的十进制2 10 ^ 8 ^ 8 = 10 0 0 1 0 ^ 1 0 0 0-------------------- 1 0 1 0 -&gt; 对应的十进制10 结论:一个数字连续异或同一个数字两次结果是它本身,可以进行加密和解密的操作 一个小实例:交换两个变量的值,不允许出现第三方变量 1234567891011121314151617public static void main(String[] args) &#123; // 方法一:一个数字连续异或同一个数字两次结果是它本身 int m = 100; int n = 200; m = m ^ n; n = m ^ n; m = m ^ n; System.out.println(&quot;m:&quot;+m); System.out.println(&quot;n:&quot;+n); // 方法二:管老师自创写法 int x = 100; int y = 200; y = x ^ (x = y) ^ y; System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y);&#125; 取反~,1变成0,0变成1 123 ~1 0 0 0-------------------- 0 1 1 1 补码 - 负数在计算机中的变现形式就是以补码的形式存在的 1234补码 = 反码 + 1反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位=&gt;1代表的是负数,0代表的是正数反码本身是没有意义的,它的存在就是为了计算补码 题目:-10的二进制是多少?-10的补码是多少? 1234567-10的原码:10000000 00000000 00000000 00001010-10的反码:11111111 11111111 11111111 11110101-10的补码 = 反码 + 111111111 11111111 11111111 11110110最后这个就是-10的补码,也是-10的二进制 题目:计算~9 12300000000 00000000 00000000 0000100111111111 11111111 11111111 11110110最后这个是~9 发现~9 = -10 结论:-(x+1) = ~x 移位操作 笔试题 - 计算机性能最高的操作,jdk源码里面很多都是移位操作 12345678910111213141516171819202122232425&lt;&lt; 向左移动 2&lt;&lt;2 =&gt; 0010&lt;&lt;2 =&gt; 1000=8 原题:请你用最高性能的方式计算出2的3次方 &gt;&gt; 带符号的向右移动,向右移动多少位,那么就在最高位补符号位 -10 &gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 1111111111 11111111 11111111 111101 -&gt; 负数的二进制,最高位是1 要对这个负数进行求解可以参考结论-(x+1)=~x,因此对它取反 00000000 00000000 00000000 00000010 -&gt; 结果是3 表示那个数是~3 =&gt; 该数为-2 10 &gt;&gt; 2 00000000 00000000 00000000 00001010 &gt;&gt; 2 0000000000 00000000 00000000 000010 -&gt; 结果是2 &gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算这个十进制(这个就是结果) 为了更好的计算,补齐后面的数,该十进制就等于如下式子 01000000 00000000 00000000 00000000 - 3 ------------------------------------ 1073741821 练习-15&gt;&gt;2 和-15&gt;&gt;&gt;2 123456789101112131415-15 = ~1411111111 111111111 11111111 11110001 &gt;&gt; 21111111111 111111111 11111111 11110011111111 111111111 11111111 11111100 这个就是结果,取反00000000 000000000 00000000 00000011 -&gt; ~3故结果为-411111111 111111111 11111111 11110001 &gt;&gt;&gt; 20011111111 111111111 11111111 11110000111111 111111111 11111111 11111100 这个就是结果,为了配好,所以+401000000 00000000 00000000 00000000- 4-----------------------------------1073741820 方法方法相当于其他语言中的函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性 语法1234修饰符 返回类型 方法名([参数列表]) [throw 可抛出的异常列表]&#123;...方法体...&#125;现阶段修饰符 返回类型 方法名([参数列表]) &#123;...方法体...&#125; 修饰符访问修饰符决定了这个方法可以被调用的范围 public - 公开的,公共的,如果一个方法被public进行修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的 默认的 受保护的 特殊修饰符 static - 静态的 静态方法 - 使用static修饰的方法 非静态方法 - 没有使用static修饰的方法 是否为静态的方法决定了这个方法被调用的方式 返回类型 有返回类型 - 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自动以对象类型] 方法体的最终的出口一定有return返回值 12345678return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法 正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果 方法的返回类型是什么,就用什么类型去定义,当然也支持类型的转换 无返回类型 - void 不需要使用return + 返回值; 应该如何选择 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型,如果一个方法仅仅是为了输出,只要定义void 123456789public static int test01(int m,int n)&#123; //code... return m和n的最大公约数&#125;public static int test02(int m,int n)&#123; int 公约数 = test01(m,n); return m*n/公约数;&#125;int n = test02(20,12); 方法名参考变量名的命名规则 - 一模一样 参数列表 无参列表 带参列表 1234//此处的age和name就是形参public static void add(int age,String name)&#123; System.out.println(age+&quot;:&quot;+name);&#125; 可变长列表 12345public static void sub(int...arr)&#123; //这里的arr表示数组 for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]); &#125;&#125; 参数的分类 形参 - 定义在方法的参数列表中的参数,目的是告诉这个方法的调用者在调用这个方法时需要传入的参数[个数以及类型],没有实际的值. 实参 - 方法的调用者在调用这个方法的时候传入的真正的参数 - 有真正的值. 如何定义方法 方法体的内部不能够再去定义方法了 main方法仍然是程序的主入口 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 方法的调用方式取决这个方法是静态的还是非静态的 - static 1234567891011121314151617181920212223242526272829303132333435package tech.aistar.day02.method;public class MethodHelloDemo &#123; public static void main(String[] args) &#123; //1.调用公开的静态方法add MethodHelloDemo.add(); //2.调用公开的非静态方法sub //2.1首先创建对象 MethodHelloDemo m = new MethodHelloDemo(); //2.2利用对象调用方法 m.sub(); //整理笔记 //静态方法是属于类的,由类调用,它在JVM加载类进入内存时就分配空间并进行初始化 //非静态方法是属于对象的,只能由类的对象进行调用,每次创建对象的时候,给各自的非静态成员分配空间并进行初始化. &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 1.静态方法只能够直接调用静态方法 2.非静态方法中可以直接调用非静态方法以及静态方法 3.通用的原则 - 类名.静态方法或者对象.非静态方法 4.静态方法属于类拥有的,非静态方法属于对象拥有的 5.静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且仅有一次机会,而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package tech.aistar.day02.method;public class StaticDetailDemo &#123; // 在类中,属性和方法都属于类的成员 //定义全局变量 // 非静态的属性 int n = 19; //等创建对象的时候,才会分配空间和初始化 //静态属性 - 静态属性的初始化的时机优于静态方法 static int m = 199; public static void main(String[] args) &#123; //定义的全局变量n是非静态的,所以此时n还没有初始化,不能直接输出n //System.out.println(n); //error //但是可以直接输出m,因为m是静态的,在JVM加载内存的时候就已经分配了空间并且进行了初始化 System.out.println(m); //要输出n首先需要创建对象 StaticDetailDemo s1 = new StaticDetailDemo(); System.out.println(s1.n); &#125; //非静态方法 public void test01()&#123; System.out.println(&quot;test01...&quot;); &#125; //静态方法 public static void test02()&#123; //在静态方法中可以创建非静态局部变量 int n = 10; //这里可以想象一下 在main方法中可以创建非静态局部变量 System.out.println(&quot;test02...&quot;); // 静态方法中可以调用自定义的静态方法 // 1. 通过类.方法名 StaticDetailDemo.test04(); // 2. 省略类 test04(); // 静态方法中也可以调用非静态方法 // 通过对象.方法 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; //非静态方法 public void test03()&#123; System.out.println(&quot;test03...&quot;); //非静态方法中不允许定义静态的局部变量 根本就没有静态的局部变量这种东西! //static int n = 20; //error // 想象一下static都是JVM一开始加载的 但是非静态的必须要创建对象才可以 这样是不合理的 //非静态方法中调用静态方法 // 1.类名.方法 StaticDetailDemo.test04(); // 2.省略类 因为这个时候静态方法早已经加载好了 test04(); //非静态方法中调用非静态方法 this.方法 this.test01(); // 在实际写代码时可以省略this关键字,this表示的是当前对象 test01(); &#125; //静态方法 public static void test04()&#123; System.out.println(&quot;test04...&quot;); &#125;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或对象.非静态方法 方法的调用者和方法的定义者是存在不同包的不同类中 必须先通过import关键字进行导包操作 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 方法的重载(@overload)重载的要求: 重载的方法存在同一个类中 重载的方法方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 12345678910111213141516171819public static void main(String[] args) &#123; add(); //调用无参add方法 add(12,&quot;Tom&quot;); //调用有参add方法1 add(&quot;Lisa&quot;,10); //调用有参add方法2 &#125; public static void add()&#123; System.out.println(&quot;调用无参add方法&quot;); &#125; public static int add(int age,String n)&#123; System.out.println(n+&quot;:&quot;+age); System.out.println(&quot;调用有参add方法1&quot;); return age; &#125; public static int add(String n,int age)&#123; System.out.println(age+&quot;:&quot;+n); System.out.println(&quot;调用有参add方法2&quot;); return age; &#125; 方法重载的优点-&gt;简化api-方便调用 学会用api通过学习java.lang.Math - 数学工具类 - 提供了很多关于数学计算的方式 abs - 求绝对值 random - 随机数 - [0,1.0)之间 - double类型 注意在求随机整数时需要强制转换 floor -&gt; 返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。 结合例子理解,注意负数的时候的使用 round -&gt; 返回参数中最接近的 long ，其中 long四舍五入为正无穷大。-&gt; round = floor(a+1/2) 同样结合例子理解,注意返回值是long 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; //绝对值 System.out.println(Math.abs(-12)); //12 //随机数 [0,1.0) System.out.println(Math.random()); //[1,100]之间随机的整数 int n1 = (int) (Math.random()*100+1); System.out.println(n1); //[3,5]之间的随机整数 //这里要注意分析 int n2 = (int) (Math.random()*3 + 3); System.out.println(n2); //两个数中的最大值/最小值 System.out.println(Math.max(10,15)); System.out.println(Math.max(10,15)); //floor方法 小于或等于 System.out.println(Math.floor(3.5)); //结果为3.0 System.out.println(Math.floor(3.0)); //结果为3.0 System.out.println(Math.floor(-3.5)); //结果为-4.0 System.out.println(Math.floor(-3.0)); //结果为-3.0 //round方法 四舍五入 这个需要注意一下:!!!返回值是long!!! //round = floor(a+1/2) System.out.println(Math.round(3.5)); //结果为4 System.out.println(Math.round(3.0)); //结果为3 System.out.println(Math.round(-3.5)); //结果为-3 System.out.println(Math.round(-3.0)); //结果为-3&#125; 语句三元操作符三目运算符 条件表法师?result1:result2 表达式为true,结果就是result1,否则结果是result2 支持无限嵌套,但是不推荐,因为可读性很差 m?(表达式?result1:result2):result2 if…else if语句单独使用场景 1234if(条件)&#123; code... code...&#125; {}可以省略的场景 - 如果if{}中的代码只有一行,那么{}可以省略,但是一定要缩进 123if(条件)&#123; code&#125; if…else…的使用 1234567if(条件)&#123; code... code...&#125;else&#123; code...&#125; 多条件分支if…else if…else… 1234567if(条件)&#123; code...&#125;else if(条件)&#123; code...&#125;else&#123; code...&#125; if…else语句可以无限嵌套使用 123456789101112131415if(条件)&#123; if(条件) code... else code...&#125;else if(条件)&#123; if(条件)&#123; code... &#125; else&#123; code... &#125;&#125;else&#123; code...&#125; 习题1.买奶茶,每第二杯半价,单价是10元.求总价. 1234567891011121314int n = 11; //奶茶的数量 double price = 10.0d; //奶茶的价格 // 10 5 10 5 10 5... //如果奶茶是双数杯-&gt; 一半是全价,一半是半价 //如果奶茶是单数杯-&gt; 一半加一杯是全价,一半是半价 double total = n/2 * price + n/2 * (price/2); // 判断是奇数 奇数&amp;1=1 if((n &amp; 1) == 1)&#123; total = total + price; &#125; System.out.println(total); 2.求某年某月最大天数 1234567891011121314151617181920212223242526/** * 判断某年是否为闰年 - (闰年%4=0 &amp;&amp; 闰年%100!=0) || 闰年%400 =0 * @param year 需要判断的年份 * @return */ public static boolean isLeapYear(int year)&#123; return ((year%4==0 &amp;&amp; year%100!=0) || year%400==0); &#125; /** * 求某年某月最大天数 * @param year * @param month * @return */ public static int getMaxDays(int year,int month)&#123; int days = 31; // 4,6,9,11 -&gt; 30 天 // 2 -&gt; 28/29天 // 其他-&gt;31天 if(month==4 || month==6 || month==9 || month==11) days = 30; else if(month == 2) days = isLeapYear(year)?29:28; return days; &#125; switch…caseswitch…case没有if…else灵活 语法 1234567891011switch(变量)&#123; case 值1: //code... [break]; case 值2: //code.. [break]; default: //code... [break];&#125; switch括号中变量的类型只能为byte short int char String enum Byte Short Integer Character 运行过程中如果进入到某个case块中执行,只有遇到break语句才会跳出switch块,如果没有遇到break语句,程序会自动进入到下一个case块中去执行. default语句可以省略,也可以放置在switch{}中的任意位置,但是推荐放置在末尾,如果switch括号中的变量没有匹配到任何的case后面的值,就会进入到default中. 循环语句while while属于后置循环 - 先判断循环条件是否成立,如果成立,则进入到循环体中,否则不执行循环 使用场景: 当不知道循环多少次,但是知道循环退出的条件的时候,优先选择while循环. 语法: 123while(条件)&#123; //循环体...&#125; 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; char c = &#x27;a&#x27;; while(c&lt;=&#x27;z&#x27;)&#123; System.out.print(c); c++; &#125; System.out.println(); //输出&#x27;A&#x27;-&#x27;Z&#x27; int n = 65; while(n&lt;=90)&#123; System.out.print((char)n); n++; &#125; System.out.println(); //死循环 int m = 0; while(true)&#123; System.out.print(m+&quot;\\t&quot;); if(m==10) break; m++; &#125; &#125; 死循环需要注意的点: 一定要有break,否则会一直处于死循环之中 注意要对变量进行操作,使它满足退出循环的条件 练习: 求两个数的最大公约数 12345678910public static int getMaxDivisor(int m,int n)&#123; int divisor = n; int first = m,second = n; while(divisor!=0)&#123; divisor = first % second; first = second; second = divisor; &#125; return first; &#125; 十进制转换为二进制 12345678910111213141516171819202122232425262728/** * 十进制转二进制 - String保存结果 * @param n */ public static void DecimalToBinary(int n)&#123; String result = &quot;&quot;; while(n!=0)&#123; result = n%2 + result; n=n/2; &#125; System.out.println(result); &#125; /** * 十进制转二进制 - int保存结果 * @param n */ public static void DecimalToBinary2(int n)&#123; int result = 0,count=0; while(n!=0)&#123; result = (int) (result + (n%2)*(Math.pow(10,count))); n = n/2; count++; &#125; System.out.println(result); &#125; for循环 单层for 123for(①表达式;②表达式;③表达式)&#123; //④循环体&#125; ①表达式 - 循环过程中变量的初始化操作 - 仅仅执行一次. ②表达式 - 循环退出的条件 - 至少执行一次 ③表达式 - 循环过程中,变量因子的变化 - 可能执行,可能不执行[取决于②表达式是否成立] 执行顺序: ① - ②[成立] - ④ - ③ - ②[成立] - ④ - ③ - … 怪异的写法 - 三个表达式都可以省略不写,或者写到其他地方 123for(;;)&#123; //死循环 - break打破循环&#125; for循环的复合形态 123for(同时定义若干个变量;条件;表达式)&#123; //循环体...&#125; 练习: 打印九九乘法表 12345678for (int i = 1,j=1; i &lt;9 ; j++) &#123; System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j + &quot;\\t&quot;); if(i==j)&#123; System.out.println(); j = 0; i++; &#125;&#125; 嵌套for循环,循环的层数不建议超过三层,嵌套越多,性能越低. 2-1.内外层无关 - 里面的for选中的时候可以单独执行,没有使用到外面for循环的变量因子 1234567//外层循环走一次,内层循环走全部for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 40; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println();&#125; 2-2 内外层相关 - 里面的for使用到了外面for循环的变量因子 123456for (int i = 0; i &lt;9 ; i++) &#123; for (int j = 0; j &lt;=i ; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println();&#125; 练习:打印所有的三位数,三位数由数字1,2,3,4组成,但是不能出现重复的,每打印四个换一行 1234567891011121314151617//定义计数器,用于换行int count = 0;for (int x = 1; x &lt;=4 ; x++) &#123; for (int y = 1; y &lt;=4 ; y++) &#123; for (int z = 1; z &lt;=4 ; z++) &#123; if(x!=y &amp;&amp; y!=z &amp;&amp; x!=z)&#123; System.out.print(x*100+y*10+z+&quot;\\t&quot;); count++; if(count==4)&#123; System.out.println(); count=0; &#125; &#125; &#125; &#125;&#125; 注意一下这里计数器的使用 do…while…do…while属于前置循环 - 无论循环条件是否成立,优先进入到循环体中执行一次,然后再判断条件,决定下一次是否会再次进入. 语法: 123do&#123; //循环体...&#125;while(条件); break语句 break可以跳出switch块. break可以打破它所在的那一层循环. continue语句它只能出现在循环体中,跳过本轮循环,继续执行下一轮循环. 1234567for (int i = 0; i &lt;10 ; i++) &#123; if(i==5)&#123; //break; //结果:01234 continue; //结果:012346789 &#125; System.out.print(i); &#125; 数组 数组的诞生 - 为了解决单个变量只能存储单个知道缺点 数组本身也属于数据结构[数组,栈,堆,树,链表,图] 数组属于对象类型,数组是存在在JVM内存的堆区,基本类型存储在JVM内存的栈区. 数组在内存中一定是一块连续的空间 数组的大小[长度]一旦确定了,就不能改变 语法121. 元素类型[] 变量名 = new 元素类型[size] //推荐使用这种2. 元素类型 变量名[] = new 元素类型[size] 元素类型就是数据类型[8种基本数据类型以及对象类型],决定了这个数组中可以存放的数据的类型 123//arr的数据类型是什么?int[]-&gt;整数型数组// 定义一个长度为3的int型数组int[] arr = new int[3]; 赋值方式如果定义了数据,但是没用对其进行赋值操作,那么系统会默认分配一个默认值.默认值由元素类型决定.byte,short,int,long -&gt; 0float,double -&gt; 0.0boolean -&gt; falsechar -&gt; 空格对象类型 -&gt; null 首先定义数组,然后通过下标一一赋值 下标的范围[0,数组长度-1] 1234int[] arr = new int[3];arr[0] = 10;arr[1] = 10;arr[2] = 10; 如果下标不在此范围,控制台抛出java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常 定义数组的同时进行赋值 12int[] arr= &#123;3,4,5&#125;;int[] arr = new int[]&#123;3,4,5&#125;; 通过普通for循环语句去赋值 1234int[] arr = new int[3];for(int i=0;i&lt;arr.length;i++)&#123; arr[i] = (int)(Math.random()*100+1); //[1,100]的随机数&#125; 获取数组的值 通过下标一一取值 1System.out.println(arr[下标]); 数组提供了属性length - 获取数据的长度,通过普通for循环进行遍历 123for(int i = 0; i &lt; arr.length; i++)&#123; System.out.println(arr[i]);&#125; 使用jdk5.x提供的增强for循环的语法,属于只读的for循环 1234567for(元素类型 元素变量:数组变量名)&#123; System.out.println(元素);&#125;for (int i:arr)&#123; System.out.print(i); &#125; 数组的内存通过new关键字在JVM的堆区中开辟新的空间01,用来存储这个对象{10,20,30},然后将这个对象在堆空间中的内存地址赋值给了引用变量arr1,这个变量存储在栈区中. arr1的本质不是对象,只是一个引用变量. 引用变量中存储的是对象在堆中的内存地址.并且一个引用变量在同一时刻只能指向一个对象,一个对象在同一时刻可以被多个引用指向. 12345int[] arr1 = new int[]&#123;10,20,30&#125;;int[] arr2 = &#123;10,20,30&#125;;arr1 = arr2; //执行完本条语句后,arr1和arr2都是指向第二次创建出来的数组对象//原来第一次创建出来的对象就称为内存中的垃圾对象[没有任何引用指向的对象],会由GC[垃圾回收线程]进行回收并释放内存. 123456int[] arr = &#123;1,3,4,7&#125;; //arr是引用变量,指向该数组在堆区中的地址System.out.println(arr); //打印的是arr的值,也就是数组的地址[I@1b6d3586int[] arr2 = &#123;1,3,4,7&#125;;System.out.println(arr == arr2); //false//因为==始终比较的是值,也就是arr和arr2所代表的值,即两个数组的地址,是不同的,所以是false 方法的参数传递方式 基本类型采用值传递 - 形参的改变不影响实参 12345678910111213141516public static void main(String[] args) &#123; //基本类型采用值传递 int a=10,b=20; //将a,b变量中保存的具体的值拷贝一份赋值给了方法参数中的那俩个变量m,n //所以m和n的改变不影响a,b add(a,b); System.out.println(&quot;main-a:&quot;+a); //10 System.out.println(&quot;main-b:&quot;+b); //20 &#125; private static void add(int m, int n) &#123; m = m + 10; n = n + 10; System.out.println(&quot;add-m:&quot;+m); //20 System.out.println(&quot;add-n:&quot;+n); //30 &#125; 对象类型[引用类型]采用地址传递 12345678910111213public static void main(String[] args) &#123; //对象类型采用的是地址传递/引用传递 int[] arr = &#123;1,3,4,5&#125;; add(arr); System.out.println(&quot;main-arr[3]:&quot;+arr[3]); //15 &#125; private static void add(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] += 10; &#125; System.out.println(&quot;add-arr[3]:&quot;+arr[3]); //15 &#125; 总结:Java中只有值传递,没有地址传递.对象类型[引用类型]看起来是地址传递,但是实际上传递的是引用变量的值,这个值表示的是地址. 注意String类型虽然是一个对象类型,但是具备基本类型传递的特点 12345678910public static void main(String[] args) &#123; String s = &quot;Hello&quot;; add(s); System.out.println(&quot;main-s:&quot;+s);&#125;private static void add(String s) &#123; s += &quot;Sakura&quot;; System.out.println(&quot;add-s:&quot;+s); //main-s:Hello&#125; 一个重点题目: 1234567891011121314public static void main(String[] args) &#123; int[] arr1 = &#123;10&#125;; int[] arr2 = &#123;20&#125;; change(arr1,arr2); System.out.println(&quot;main-arr1[0]:&quot;+arr1[0]); System.out.println(&quot;main-arr2[0]:&quot;+arr2[0]); &#125; private static void change(int[] arr1, int[] arr2) &#123; arr2[0] = 100; arr1 = arr2; System.out.println(&quot;change-arr1[0]:&quot;+arr1[0]); System.out.println(&quot;change-arr2[0]:&quot;+arr2[0]); &#125; 图片虽然有些草率,能看懂大致意思即可. 二维数组定义 数据类型 变量 = 初始化; 数据类型 - 八种基本数据类型以及对象类型 数组本身就属于对象类型 1int[] arr =new int[3]; //arr的数据类型int[],整数型数组,int型数组 元素类型[] 变量名 = new 元素类型[数组长度]; 123int[][] 变量名 = new int[rows][cols];//元素类型决定了数组中可以存放的数据类型//二维数组中的每个元素就是一堆数组 123//定义一个3行2列的int型二维数组int[][] arr = new int[3][2];int arr[][] = new int[3][2]; 一定要理解一下,二维数组的每个元素就是一个一维数组 在定义的时候,列可以省略,行不能省略 赋值方式 通过下标一一赋值 12int[][] arr = new int[3][2];arr[0][0] = 100; 定义二维数组的同时进行赋值 12int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;int[][] arr2 = new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; 先定义一个数组,然后一行一行进行赋值 1234int[][] arr = new int[3][3];//arr[0] = &#123;1,2,3&#125;; //error//注意一下这个每行进行赋值不能省略newarr[0] = new int[]&#123;1,2,3&#125;; 定义一个不规则的二维数组 1234int[][] arr4 = new int[3][];arr4[0] = new int[]&#123;1&#125;;arr4[1] = new int[]&#123;1,2&#125;;arr4[2] = new int[]&#123;1,2,3&#125;; 遍历方式 通过下标一一输出 通过单层for循环输出 123for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(Arrays.toString(arr[i]));&#125; 双层for循环 123456for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.print(arr[i][j]+&quot;\\t&quot;); &#125; System.out.println();&#125; 利用java.util.Arrays工具类中的方法 1System.out.println(Array.deepToString(arr)); 增强型for循环 123456for (int[] i : arr2) &#123; for (int i1 : i) &#123; System.out.print(i1+&quot;\\t&quot;); &#125; System.out.println();&#125; 实例:二维数组的行列转换 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; String[][] arr = new String[4][6]; arr[0]=new String[]&#123;&quot;白&quot;,&quot;日&quot;,&quot;依&quot;,&quot;山&quot;,&quot;尽&quot;,&quot;,&quot;&#125;; arr[1]=new String[]&#123;&quot;黄&quot;,&quot;河&quot;,&quot;入&quot;,&quot;海&quot;,&quot;流&quot;,&quot;.&quot;&#125;; arr[2]=new String[]&#123;&quot;欲&quot;,&quot;穷&quot;,&quot;千&quot;,&quot;里&quot;,&quot;目&quot;,&quot;,&quot;&#125;; arr[3]=new String[]&#123;&quot;更&quot;,&quot;上&quot;,&quot;一&quot;,&quot;层&quot;,&quot;楼&quot;,&quot;.&quot;&#125;; change(arr); &#125; private static void change(String[][] arr) &#123; // 注意一下这个新建的二维数组的元素个数 String[][] temp = new String[6][4]; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; temp[j][i] = arr[i][j]; &#125; &#125; //打印输出 for (String[] strings : temp) &#123; for (String string : strings) &#123; System.out.print(string+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; 递归算法 方法体中调用方法自己本身 递归算法的方法体中一定要出现递归的出口,否则会抛出java.lang.StackOverflowError - 堆栈溢出错误 使用场景:适合解决大量的,重复性的业务题 缺点:性能比较低,将每次计算的结果都会保存在内存中. 获取键盘输入 java.util.Scanner键盘类 如何构建这个Scanner对象 1Scanner sc = new Scanner(System.in); 方法 3-1. int nextInt();//只能获取整数 3-2. double nextDouble();//获取小数 3-3. String nextLine();//获取字符串 注意点:nextLine不要和nextInt或者nextDouble混用.","categories":[],"tags":[{"name":"Scanner","slug":"Scanner","permalink":"http://beautifulboyy/tags/Scanner/"},{"name":"变量","slug":"变量","permalink":"http://beautifulboyy/tags/%E5%8F%98%E9%87%8F/"},{"name":"方法","slug":"方法","permalink":"http://beautifulboyy/tags/%E6%96%B9%E6%B3%95/"},{"name":"循环语句","slug":"循环语句","permalink":"http://beautifulboyy/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"数组","slug":"数组","permalink":"http://beautifulboyy/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Java算法学习","slug":"javastudy-algorithm","date":"2021-07-20T08:34:09.000Z","updated":"2021-08-02T02:15:00.912Z","comments":true,"path":"2021/07/20/javastudy-algorithm/","link":"","permalink":"http://beautifulboyy/2021/07/20/javastudy-algorithm/","excerpt":"","text":"简单算法题整数的逆序给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:34 * @description 给一个的正整数，要求：一、求它是几位数，二、逆序打印出各位数字. */public class ReverseNumber &#123; /** * 获取正整数的位数 * @param num 输入的正整数 * @return */ public static int getDigit(int num)&#123; int digit = 0; while(num!=0)&#123; digit++; num = num/10; &#125; return digit; &#125; /** * 直接逆序输出正整数 * @param num 输入的正整数 */ public static void reverseNumber(int num)&#123; while(num!=0)&#123; System.out.print(num%10+&quot;\\t&quot;); num = num/10; &#125; System.out.println(); &#125; /** * 把逆序的正整数保存在String类型的字符串中 * @param num * @return */ public static String reverseNumberByString(int num)&#123; String str = &quot;&quot;; while(num!=0)&#123; str += num%10; num = num/10; &#125; return str; &#125; /** * 正整数的逆序,逆序的结果仍然是int型 * @param num * @return */ public static int reverseNumberByInt(int num)&#123; int result = 0; while(num!=0)&#123; result = result*10 + num%10; num = num/10; &#125; return result; &#125; public static void main(String[] args) &#123;// System.out.println(getDigit(1247));// reverseNumber(1247); System.out.println(reverseNumberByString(1247)); System.out.println(reverseNumberByInt(1247)); &#125;&#125; 判断回文数一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同 12345678910111213141516171819202122232425package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:43 * @description 一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同 * 思路 - 判断这个数逆序之后的结果是否与原来的数相等 */public class JudgePalindrome &#123; public static boolean judge(int num)&#123; int result = ReverseNumber.reverseNumberByInt(num); if(result == num) return true; return false; &#125; public static void main(String[] args) &#123; System.out.println(judge(123)); System.out.println(judge(12321)); System.out.println(judge(1221)); &#125;&#125; 打印水仙花数打印出所有的 “水仙花数 “,所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。 例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方 1234567891011121314151617181920212223242526272829303132package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:46 * @description 打印水仙花数 * 打印出所有的 &quot;水仙花数 &quot;,所谓 &quot;水仙花数 &quot;是指一个三位数，其各位数字立方和等于该数本身。 * 例如：153是一个 &quot;水仙花数 &quot;，因为153=1的三次方＋5的三次方＋3的三次方 */public class PrintNumberOfDaffodils &#123; public static boolean judge(int num)&#123; int result = 0; result = (int) (Math.pow(num/100,3) + Math.pow(num/10%10,3) + Math.pow(num%10,3)); if(result == num) return true; return false; &#125; public static void print()&#123; for (int i = 100; i &lt; 1000; i++) &#123; if(judge(i)) System.out.print(i+&quot;\\t&quot;); &#125; &#125; public static void main(String[] args) &#123; print(); &#125;&#125; 结果:153 379 371 407 判断完数一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。 例如6=1＋2＋3.编程找出1000以内的所有完数 123456789101112131415161718192021222324252627282930313233343536373839404142package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:55 * @description 判断完数 * 一个数如果恰好等于它的因子之和，这个数就称为 &quot;完数 &quot;。 * 例如6=1＋2＋3.编程找出1000以内的所有完数 */public class JudgePerfectNumber &#123; /** * 判断完数 * @param num * @return */ public static boolean judge(int num)&#123; int result = 0; //存储因子的结果 for (int i = 1; i &lt;num ; i++) &#123; if(num%i==0) result += i; &#125; if(result == num) return true; return false; &#125; /** * 打印1000以内的完数 */ public static void print()&#123; for(int i=1;i&lt;1000;i++)&#123; if(judge(i)) System.out.print(i+&quot;\\t&quot;); &#125; &#125; public static void main(String[] args) &#123; print(); &#125;&#125; 结果:6 28 496 打印菱形打印如下图形,空心的和实心的 123456789* 4 * * 3 5 * * 2 6 * * 1 7 * * 0 8 * * 1 7 * * 2 6 * * 3 5 * 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 16:05 * @description 打印菱形 * 找规律 - 找i和j之间的关系 * * 4 i=0,j=4; * * * 3 5 i=1,j=3,j=5; * * * 2 6 i=2,j=2,j=6; * * * 1 7 i=3,j=1,j=7; * * * 0 8 i=4,j=0,j=8; * * * 1 7 i=5,j=1,j=7; * * * 2 6 i=6,j=2,j=6; * * * 3 5 i=7,j=3,j=5; * * 4 i=8,j=4; * * 左上的边:i+j=4 * 右上的边:j-i=4 * 左下的边:i-j=4 * 右下的边:i+j=12 */public class PrintDiamond &#123; public static void printHollowDiamond()&#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt;9 ; j++) &#123; if(i+j==4 || j-i==4 || i-j==4 || i+j==12) System.out.print(&quot;*&quot;); else System.out.print(&quot; &quot;); &#125; System.out.println(); &#125; &#125; public static void printSolidDiamond()&#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt;9 ; j++) &#123; if(i+j&lt;4 || j-i&gt;4 || i-j&gt;4 || i+j&gt;12) System.out.print(&quot; &quot;); else System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; printHollowDiamond(); printSolidDiamond(); &#125;&#125; 判断素数输出[1~199]之间所有的质数,并且每打印7个换一行 123456789101112131415161718192021222324252627282930313233343536373839404142package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 20:10 * @description 判断素数 * 输出[1~199]之间所有的质数,并且每打印7个换一行 */public class JudgePrime &#123; public static boolean judge(int num) &#123; boolean flag = true; // 注意一下范围是Math.sqrt() for (int i = 2; i &lt;= Math.sqrt(num); i++) &#123; if (num % i == 0) &#123; flag = false; break; &#125; &#125; return flag; &#125; public static void print()&#123; int count = 0; for (int i = 2; i &lt;200 ; i++) &#123; if(judge(i))&#123; System.out.print(i+&quot;\\t&quot;); count++; if(count==7)&#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; //System.out.println(judge(13)); print(); &#125;&#125; 求某年某月的最大天数12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 8:11 * @description 求某年某月的最大天数 */public class GetMaxDay &#123; public static boolean isLeapYear(int year)&#123; if((year%4 == 0 &amp;&amp; year%100!=0) || year%400 == 0) return true; return false; &#125; /** * 获取某年某月的最大天数 * @param year * @param month * @return */ public static int getMaxDay(int year,int month)&#123; int days = 31; if(month == 4 || month == 6 || month == 9 || month == 11)&#123; days = 30; &#125;else if(month == 2)&#123; // 判断平闰年 if(isLeapYear(year)) days = 29; days = 28; &#125; return days; &#125; public static void main(String[] args) &#123; System.out.println(getMaxDay(2021,2)); &#125;&#125; 斐波那契数列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 8:32 * @description 斐波那契数列 * 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 */public class FeiBoNaQi &#123; /** * 递归实现求斐波那契数列中第n个数的值 * @param n * @return */ public static int getFei(int n)&#123; if(n==1 || n==2) return 1; return getFei(n-1) + getFei(n-2); &#125; /** * 循环实现求斐波那契数列中第n个数的值 * @param n * @return */ public static int getFei2(int n)&#123; int first = 1,second=1; int result = 0; if(n==1 || n==2) return 1; int i = 3; while(i&lt;=n)&#123; result = first + second; first = second; second = result; i++; &#125; return result; &#125; public static void main(String[] args) &#123; //System.out.println(getFei(10)); System.out.println(getFei2(10)); &#125;&#125; 求阶乘123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 11:13 * @description 求阶乘! * 1! = 1 * 2! = 1 * 2 = 2 * 3! = 1 * 2 * 3 = 6 */public class GetFactorial &#123; /** * 利用递归求阶乘 * @param n * @return */ public static int getFactorial(int n)&#123; if(n==1) return 1; return n*getFactorial(n-1); &#125; public static int getFactorial2(int n)&#123; if (n==1) return 1; int i = n; int result = 1; while(i&gt;0)&#123; result = result * i; i--; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getFactorial(4)); &#125;&#125; 求最大公约数和最小公倍数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 14:55 * @description 求两个数的最大公约数和最小公倍数 */public class GetCommonDivisor &#123; /** * 递归求最大公约数 * * @param m * @param n * @return */ public static int getDivisor2(int m, int n) &#123; if (m % n == 0) return n; return getDivisor2(n, m % n); &#125; /** * 求两个数的最大公约数 * 20 12 * 20 % 12 = 8 * 12 % 8 = 4 * 8 % 4 = 0 * @param m * @param n * @return */ public static int getDivisor(int m,int n)&#123; int first = m,second = n,result = first % second; while(result!=0)&#123; result = first % second; first = second; second =result; &#125; return first; &#125; /** * 求最小公倍数 * 最小公倍数 = m*n/最大公约数 * @param m * @param n * @return */ public static int getMultiple(int m,int n)&#123; return m*n/getDivisor(m,n); &#125; public static void main(String[] args) &#123; System.out.println(getDivisor(12,20)); System.out.println(getMultiple(12,20)); &#125;&#125; 十进制转二进制12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 14:56 * @description 十进制转二进制 */public class DecimalToBinary &#123; /** * 十进制转二进制 * 10 -&gt; 1010 * 10 / 2 = 5 ... 0 * 5 / 2 = 2 ... 1 * 2 / 2 = 1 ... 0 * 1 / 2 = 0 ... 1 * * @param n * @return */ public static int getBinary(int n) &#123; int result = 0; int count = 0; while (n!=0) &#123; int j = n % 2; result = (int) (result + Math.pow(10, count++) * j); n = n/2; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getBinary(12)); &#125;&#125; 杨辉三角12345public static int yang(int x,int y)&#123; if(x==y || y==0) return 1; return yang(x-1,y-1) + yang(x-1,y);&#125; 一维数组根据值删除元素123456789101112131415161718192021222324252627282930public static int[] deleteByTarget(int[] arr,int target)&#123; // 0.首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1. 首先判断数组中有几个这个值 // 定义count记录 int count = 0; for (int i : arr) &#123; if(i==target) count++; &#125; // 2. 根据结果进行下一步 // 2.1如果count=0,表示没有该值,直接返回原数组 if(count == 0) return arr; // 2.2 如果count不为0,则定义一个新的数组,数组长度为原数组长度-count int[] newArr = new int[arr.length-count]; // 2.3 将arr中除了target以外的值都复制到newArr中 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(!(arr[i] == target)) newArr[pos++] = arr[i]; &#125; // 3.最后返回新的数组 return newArr;&#125; 根据下标删除数组123456789101112131415public static int[] deleteByIndex(int[] arr,int index)&#123; // 要求删除指定下标,而下标是唯一的 // 1.首先判断下标是否合法 if(null==arr || arr.length==0 || index&lt;0 || index&gt;=arr.length) return new int[]&#123;-1&#125;; // 2.定义新的数组,数组长度为原来的长度-1 int[] newArr = new int[arr.length-1]; // 3.循环赋值 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(i!=index) newArr[pos++] = arr[i]; &#125; return newArr;&#125; 数组的去重 - 三种方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 数组的去重 * 思路:将数组的值放到另一个数组中,每次放入一个数,都删掉所有与它值相同的数 * @param arr * @return */public static int[] delDoubleElement(int[]arr)&#123; // 0.首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1.首先定义一个新的数组,用于存储去重后的数据 int[] newArr = new int[arr.length]; // 2.遍历arr数组 int pos = 0; while(arr.length!=0)&#123; // 3. 每次都将arr[0]添加到newArr中 newArr[pos++] = arr[0]; // 4. 删除数组中所有值为arr[0]的元素 arr = deleteByTarget(arr,arr[0]); &#125; // 5.此时得到的newArr数组的末尾可能会有0 // 利用Arrays.copyOf()方法复制 newArr = Arrays.copyOf(newArr,pos); return newArr;&#125;/** * 数组的去重 - 方法二 * 遍历元素,将该元素和后面的所有元素进行比较,如果相同,就删除后面的元素 * @param arr * @return */public static int[] delDoubleElement2(int[]arr)&#123; // 首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1.遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; // 遍历数组之后的值 for (int j = i+1; j &lt; arr.length; j++) &#123; if(arr[i] == arr[j])&#123; // 别忘了给arr重新赋值 arr = deleteByIndex(arr,j); j--; &#125; &#125; &#125; return arr;&#125;/** * 数组的去重方法三 - 利用boolean类型的数组 -&gt; 不需要依赖按下标删除或按元素删除的方法 * @param arr * @return */public static int[] delDoubleElement3(int[]arr)&#123; if(null == arr || arr.length == 0) return arr; // 1. 定义一个boolean类型的数组 boolean[] flag = new boolean[arr.length]; // 2.利用Arrays.fill方法为flag数组赋值,所有的值都赋值为true Arrays.fill(flag,true); // 3. 遍历数组 如果元素在前面已经出现过,同样的位置上,flag设置为false for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if(arr[i] == arr[j]) flag[j] = false; &#125; &#125; // 4.统计true的个数,新数组的长度就是true的个数 int count = 0; for (int i = 0; i &lt; flag.length; i++) &#123; if(flag[i]) count++; &#125; // 5.定义新的数组 int[] newArr = new int[count]; // 6.进行赋值,如果值是false就不赋值 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(flag[i]) newArr[pos++] = arr[i]; &#125; return newArr;&#125; 排序冒泡排序12345678910111213141516171819/** * 冒泡排序 - 两两比较 * @param arr * @param flag flag为true表示从小到大排序,flag为false表示从大到小排序 */public static int[] bubble(int[] arr,boolean flag)&#123; //遍历数组 for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = 0; j &lt; arr.length-1-i; j++) &#123; if(flag?arr[j]&gt;arr[j+1]:arr[j]&lt;arr[j+1])&#123; //进行值交换 arr[j] = arr[j] ^ arr[j+1]; arr[j+1] = arr[j] ^ arr[j+1]; arr[j] = arr[j] ^ arr[j+1]; &#125; &#125; &#125; return arr;&#125; 选择排序123456789101112131415161718/** * 选择排序 - 将第一个数和后面所有的数相比,如果不符合需求则交换值 * @param arr * @param flag flag为true表示从小到大,flag为false表示从大到小 * @return */public static int[] select(int[] arr,boolean flag)&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = i+1; j &lt;arr.length ; j++) &#123; if(flag?arr[i]&gt;arr[j]:arr[i]&lt;arr[j])&#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; &#125; &#125; return arr;&#125; 直接插入排序1234567891011121314151617181920 /** * 直接插入排序 - 前面的序列是有序序列,每次插入一个,都要插入在正确的位置 * @param arr * @param flag flag为true表示从小到大,flag为false表示从大到小 * @return */public static int[] insert(int[] arr,boolean flag)&#123; //下标从1开始 for (int i = 1; i &lt; arr.length; i++) &#123; // 从第二个数开始比较 for (int j = i; j &gt;0 ; j--) &#123; if(flag?arr[j]&lt;arr[j-1]:arr[j]&gt;arr[j-1])&#123; arr[j] = arr[j] ^ arr[j-1]; arr[j-1] = arr[j] ^ arr[j-1]; arr[j] = arr[j] ^ arr[j-1]; &#125; &#125; &#125; return arr;&#125; 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /** * 找基准数 * @param arr * @param start * @param end * @return */public static int getIndex(int[] arr,int start,int end)&#123; int i = start; int j = end; int x = arr[i]; //每次都先将arr[i]设为基准数 即x为基准书 while(i&lt;j)&#123; // 从右往左如果大于等于基准数则继续向左 即j-- while(i&lt;j &amp;&amp; arr[j]&gt;=x)&#123; j--; &#125; if(i&lt;j)&#123; // 此时表示从右往左找到了一个数小于基准数,那么进行占坑操作 arr[i] = arr[j]; // 在占坑以后i的指向要往后一位 i++; &#125; // 从左往右如果小于等于基准数则继续向右 即i++ while(i&lt;j &amp;&amp; arr[i]&lt;x)&#123; i++; &#125; if(i&lt;j)&#123; // 此时表示从左往右找到了一个数大于基准数,那么进行占坑操作 arr[j] = arr[i]; // 在占坑以后j的指向要往前一位 j--; &#125; &#125; //退出循环的时候 表示i&gt;=j 这个时候找到了基准数 // 所以要给基准数赋值 arr[i] = x; return i; //基准数的位置&#125;public static void quickStart(int[] arr,int start,int end)&#123; if(start&lt;end)&#123; int index = getIndex(arr,start,end); quickStart(arr,0,index-1); quickStart(arr,index+1,end); &#125;&#125; 递归类型 求某个数的阶层 12345678910111213 /** * 求某个数的阶层 * 1 = 1 * 2 = 2 * 1 * 3 = 3 * 2 *1 * @param n * @return */public static int jie(int n)&#123; if(n==1) return 1; return n*jie(n-1);&#125; 求斐波那契数列 1234567891011 /** * 斐波那契数列 * //1 1 2 3 5 8 13 21 34 55 ... * @param n * @return */public static int Fibonacci(int n)&#123; if(n==1 || n==2) return 1; return Fibonacci(n-1)+Fibonacci(n-2);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://beautifulboyy/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"hexo和github部署","slug":"blog-deployment","date":"2021-07-15T10:08:42.000Z","updated":"2021-07-31T12:20:39.509Z","comments":true,"path":"2021/07/15/blog-deployment/","link":"","permalink":"http://beautifulboyy/2021/07/15/blog-deployment/","excerpt":"","text":"博客项目Hexo安装 1.首先在某个盘目录下新建文件夹,假设为hello-hexo,这是博客项目的根目录 2.打开终端通过dos命令进入到hello-hexo目录中,输入以下命令 1&gt;E:/cxstudy/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录12E:/cxstudy/hello-hexo&gt;hexo init hello-studyE:/cxstudy/hello-hexo/hello-study&gt;nmp install 测试-启动博客服务器启动服务器代码: 1E:/cxstudy/hello-hexo/hello-study&gt;hexo s 关闭服务器:ctrl+c 打开浏览器输入:localhost:4000 主题模板的安装使用 优质主题模板:https://blog.csdn.net/zgd826237710/article/details/99671027 可以在该博客中找到自己想要的主题进行下载(从github上直接clone) 1.通过cmd进入到hello-study目录中的themes目录中 2.通过git clone命令进行克隆 12&gt;E:/cxstudy/hello-hexo/hello-study&gt;cd themes&gt;E:/cxstudy/hello-hexo/hello-study/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 配置主题模板1.指定新的主题 修改hello-study目录下的_config.yml文件 1theme: hexo-theme-pure 2.修改个人信息 修改hexo-theme-pure目录下的_config.yml文件 12345678profile: enabled: true # Whether to show profile bar avatar: images/avatar.jpg author: Sakurayo author_title: Web Developer author_description: I have nothing to say。 location: Shangrao, China follow: https://github.com/beautifulboyy 3.添加主题侧边栏 为了使得侧边栏的链接生效,将hello-study/themes/hexo-theme-pure/_source下的除了_data文件夹,其余文件夹拷贝一份到hello_study目录下的source目录中即可. 4.博客的语言环境设置 修改hello-study目录下的_config.yml文件 1language: zh-CN 5.设置图片的显示 首先需要安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 配置hello_study目录下的_config.yml文件 1post_asset_folder: true 6.内置搜索功能的实现 安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm i -S hexo-generator-json-content 7.评论功能的实现 评论功能不需要本地数据库进行存储,用的是第三方的LeanCloud 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 复制appId和appKey 在hexo-theme-pure目录下的_config.yml文件中进行配置 123valine: # Valine. https://valine.js.org appid: 复制的appid # your leancloud application appid appkey: 复制的appkey 8.字数统计和阅读时长功能的实现 安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm i -S hexo-wordcount 在hexo_theme-pure目录下的_config.yml文件中配置 1234postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 9.项目展示功能的实现 配置hexo_theme-pure目录下的_config.yml文件 12github: username: beautifulboyy # github username 新建博文1E:/cxstudy/hello-hexo/hello-study&gt;hexo n blog-deployment 部署到github中首先创建新的repository,命名规则为:用户名.github.io 例如:[beautifulboyy.github.io] 修改hello-study目录下的_config.yml文件 1234deploy: type: &#x27;git&#x27; repo: &#x27;https://github.com/beautifulboyy/beautifulboyy.github.io.git&#x27; branch: &#x27;master&#x27; 然后进行hexo三连操作 1234hexo clhexo ghexo shexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://beautifulboyy/tags/hexo/"}]}],"categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"项目","slug":"项目","permalink":"http://beautifulboyy/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"框架","slug":"框架","permalink":"http://beautifulboyy/categories/%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","permalink":"http://beautifulboyy/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://beautifulboyy/tags/mysql/"},{"name":"mybatis","slug":"mybatis","permalink":"http://beautifulboyy/tags/mybatis/"},{"name":"连接池","slug":"连接池","permalink":"http://beautifulboyy/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"jdbc","slug":"jdbc","permalink":"http://beautifulboyy/tags/jdbc/"},{"name":"索引","slug":"索引","permalink":"http://beautifulboyy/tags/%E7%B4%A2%E5%BC%95/"},{"name":"生活","slug":"生活","permalink":"http://beautifulboyy/tags/%E7%94%9F%E6%B4%BB/"},{"name":"数据库笔试题","slug":"数据库笔试题","permalink":"http://beautifulboyy/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AF%95%E9%A2%98/"},{"name":"DTL","slug":"DTL","permalink":"http://beautifulboyy/tags/DTL/"},{"name":"DDL","slug":"DDL","permalink":"http://beautifulboyy/tags/DDL/"},{"name":"DML","slug":"DML","permalink":"http://beautifulboyy/tags/DML/"},{"name":"DQL","slug":"DQL","permalink":"http://beautifulboyy/tags/DQL/"},{"name":"注解","slug":"注解","permalink":"http://beautifulboyy/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"面试题","slug":"面试题","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"反射","slug":"反射","permalink":"http://beautifulboyy/tags/%E5%8F%8D%E5%B0%84/"},{"name":"枚举","slug":"枚举","permalink":"http://beautifulboyy/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"进程","slug":"进程","permalink":"http://beautifulboyy/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://beautifulboyy/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"泛型","slug":"泛型","permalink":"http://beautifulboyy/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"IO流","slug":"IO流","permalink":"http://beautifulboyy/tags/IO%E6%B5%81/"},{"name":"序列化","slug":"序列化","permalink":"http://beautifulboyy/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"异常","slug":"异常","permalink":"http://beautifulboyy/tags/%E5%BC%82%E5%B8%B8/"},{"name":"DateFormat","slug":"DateFormat","permalink":"http://beautifulboyy/tags/DateFormat/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"http://beautifulboyy/tags/BigDecimal/"},{"name":"BigInteger","slug":"BigInteger","permalink":"http://beautifulboyy/tags/BigInteger/"},{"name":"内部类","slug":"内部类","permalink":"http://beautifulboyy/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"UML","slug":"UML","permalink":"http://beautifulboyy/tags/UML/"},{"name":"static","slug":"static","permalink":"http://beautifulboyy/tags/static/"},{"name":"字符串","slug":"字符串","permalink":"http://beautifulboyy/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"java","slug":"java","permalink":"http://beautifulboyy/tags/java/"},{"name":"集合框架","slug":"集合框架","permalink":"http://beautifulboyy/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Integer","slug":"Integer","permalink":"http://beautifulboyy/tags/Integer/"},{"name":"深拷贝浅拷贝","slug":"深拷贝浅拷贝","permalink":"http://beautifulboyy/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"Date","slug":"Date","permalink":"http://beautifulboyy/tags/Date/"},{"name":"Calendar","slug":"Calendar","permalink":"http://beautifulboyy/tags/Calendar/"},{"name":"抽象类","slug":"抽象类","permalink":"http://beautifulboyy/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"接口","slug":"接口","permalink":"http://beautifulboyy/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"面向对象","slug":"面向对象","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Scanner","slug":"Scanner","permalink":"http://beautifulboyy/tags/Scanner/"},{"name":"变量","slug":"变量","permalink":"http://beautifulboyy/tags/%E5%8F%98%E9%87%8F/"},{"name":"方法","slug":"方法","permalink":"http://beautifulboyy/tags/%E6%96%B9%E6%B3%95/"},{"name":"循环语句","slug":"循环语句","permalink":"http://beautifulboyy/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"数组","slug":"数组","permalink":"http://beautifulboyy/tags/%E6%95%B0%E7%BB%84/"},{"name":"hexo","slug":"hexo","permalink":"http://beautifulboyy/tags/hexo/"}]}