{"meta":{"title":"Welcome to my world.","subtitle":"","description":"","author":"sakura","url":"http://beautifulboyy","root":"/"},"pages":[{"title":"categories","date":"2021-07-30T03:16:21.000Z","updated":"2021-07-30T03:16:40.094Z","comments":true,"path":"categories/index.html","permalink":"http://beautifulboyy/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-30T03:15:20.000Z","updated":"2021-07-30T03:16:05.153Z","comments":true,"path":"tags/index.html","permalink":"http://beautifulboyy/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2021-07-30T03:16:59.000Z","updated":"2021-07-30T03:17:13.878Z","comments":true,"path":"link/index.html","permalink":"http://beautifulboyy/link/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql_practice","slug":"mysql-practice","date":"2021-08-21T13:03:42.000Z","updated":"2021-08-21T13:03:42.196Z","comments":true,"path":"2021/08/21/mysql-practice/","link":"","permalink":"http://beautifulboyy/2021/08/21/mysql-practice/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据库DTL","slug":"mysql03","date":"2021-08-21T02:27:00.000Z","updated":"2021-08-21T07:34:56.274Z","comments":true,"path":"2021/08/21/mysql03/","link":"","permalink":"http://beautifulboyy/2021/08/21/mysql03/","excerpt":"","text":"DTLData Transaction Language - 数据事务语言 commit,begin,start transction,savepoint,rollback 事务只要使用客户端连接到mysql-server[mysql服务器],就会自动打开一个事务 在MYSQL中,所有的DML(insert,update,delete)操作在执行之后都会有一个commit操作[隐式的] commit - 提交事务 在ORACLE中,所有的DML(insert,update,delete)操作之后,如果没有手动commit,那么在另外一个事务中是读不到最新的更新数据的. 事务的定义: 就是指一组相关的SQL操作,我们所有的操作都是处在事务中的. 控制事务 - 就是控制事务的边界(事务的开始(begin) - 事务的结束(commit,rollback)) 一个事务的结束,代表着下一个事务的开始. 注意: 在数据库中**,执行业务的基本单位是事务,不是以某一条SQL** 数据库在默认情况下,事务都是打开的,也就是说它是一直处在事务中的,一个事务的结束,代表着下一个事务的开启 执行commit或者rollback指令时,会结束当前事务 [已经提交的事务将不能够被回滚 - 已经不处于同一个事务中了,而事务与事务之间是隔离的] 作用:用来保证数据的平稳性和可预测性. 事务的四大特性(ACID): Atomicity,原子性,事务是不可再分割的,要么同时成功,要么同时失败. 转账业务(账户+money,账户-money - 一组sql - 至于一个事务当中,并且要保证原子性.) Consistency,一致性,事务一旦结束,内存中的数据和数据库中的数据是保持一致的 example：A用户和B用户进行转账1000元，A账户减少1000和B账户增加1000的sql语句必须全部执行成功，不存在一半成功，一半失败。但是无论如何执行，两个账户金额的改变加起来一定1000元，这就是一致性(完整性)。 Isolation,隔离性,事务之间互不干扰,一多个用户并发访问数据库，比如同时操作一张表。数据库为每一个用户开启事务。每个事务相互独立，互不干扰。 Durability,持久性,事务一旦提交,则数据持久化到数据库中,永久保存 [涉及到数据库的备份和恢复的一些技术,冷备份,热备份…] 事务控制语句DTL - 事务控制语句 BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 事务控制语句的演示rollback 回滚前提 - 设置成手动提交事务 如果没有设置事务点,rollback撤销所有的dml操作 12345678910111213141516171819202122232425262728293031323334353637mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec)mysql&gt; delete from video_copy where id = 2;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.11 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec) 注意的是rollback只能撤销/回滚尚未提交的事务.如果一个事务已经提交了,那么是回滚不了的 1234567891011121314151617181920212223242526272829mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; delete from video_copy where id = 2;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.12 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec) 设置事务点命令 12savepoint 事务点名称rollback to 事务点名称 效果就是会撤销到设置事务点下方的dml操作.事务点之前的dml操作将不会撤销 12345678910111213141516171819202122232425mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; delete from video_copy where id = 1;Query OK, 1 row affected (0.00 sec)mysql&gt; savepoint a;Query OK, 0 rows affected (0.00 sec)mysql&gt; delete from video_copy where id=3;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from video_copy;Empty set (0.00 sec)mysql&gt; rollback to a;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+1 row in set (0.00 sec) mysql事务处理的方法自动开始事务 当我们mysql客户端连接到mysql服务器 - 自动开启 当执行完sql语句之后,自动会commit[事务的提交 - 意味着当前事务已经结束] 一个事务的结束意味着下一个事务的开始. commit/rollback - 结束事务. 手动开启事务执行dml操作之后,就不会自动提交事务[commit],需要手动commit 用 BEGIN, ROLLBACK, COMMIT来实现 1-1. BEGIN 开始一个事务 1-2. start transaction - 手动开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 直接用 SET 来改变 MySQL 的自动提交模式: 2-1. SET AUTOCOMMIT=0 禁止自动提交 2-2. SET AUTOCOMMIT=1 开启自动提交 注意:设置成禁止自动提交的操作的话,这个操作仅仅是针对当前的会话窗口有效. 演示A事务 - 执行了delete操作,但是还没有commit. 但是在A事务当中,查询的时候,是可以查询到delete的效果的 123456789101112131415161718192021222324mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec)mysql&gt; delete from video_copy where id=2;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec) 但是在另外一个事务B中,是看不到A事务中尚未提交的数据的[仍然是可以看到id=2这条数据的] 123456789101112mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec) 对A事务执行一个commit操作 12mysql&gt; commit;Query OK, 0 rows affected (0.11 sec) B事务仍然看不到A事务提交的数据 123456789mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 2 | 学好java | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+3 rows in set (0.00 sec) B事务提交,也结束了当前的事务,自动开启一个新的事务,在新的事务中重新再查一次,可以看到A事务提交的结果了. 1234567891011mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from video_copy;+----+------------+-------+---------------------+-------------+| id | title | likes | create_time | tbl_user_id |+----+------------+-------+---------------------+-------------+| 1 | 学好myql | 100 | 2021-08-21 09:49:00 | 1 || 3 | 学习jdbc | 100 | 2021-08-21 09:49:01 | 2 |+----+------------+-------+---------------------+-------------+2 rows in set (0.00 sec) 多事务的并发处理机制原因:多个事务同时操作一个表中的同一行数据(争抢临界资源),如果这些操作是.修改操作的话,就会产生并发问题,如果不处理,则会造成数据不一致的情况. 数据库可能产生的并发问题包括: 脏读 一个事务读取到了另外一个事务中尚未提交的数据. 是指一个事务正在访问数据,并且对这个数据进行修改,而这种修改还没有提交到数据库中,而另一个事务也访问了这个数据,并且使用了这个数据解决方法:一个事务在修改数据时,该数据不能被其他事务访问 所有的数据库都是拒绝脏读 - “会读到脏数据”. 不可重复读 是指一个事务多次读取同一条记录,如果此时另一个事务也访问并且修改了该数据,则就会出现多次读取出现数据不一致的情况,原来的数据变成了不可重复读取的数据 解决方法:只有在修改事务完全提交过后才可以读取到数据 幻读 是指一个事务修改表中的多行记录,但是此时另一个事务对该表格进行了插入数据的操作,则第一个事务会发现表格中会出现没有被修改的行,就像发生了幻觉一样 解决方法:在一个事务提交数据之前,其他事务不能添加数据 不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了.幻读的重点在于新增或者删除 事务隔离级别 READ UNCOMMITTED 这是事务最低的隔离级别,它允许另外一个事务可以看到这个事务未提交的数据. 解决第一类丢失更新的问题,但是会出现脏读,不可重复读. READ COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取,即另外一个事务不能读取该事务未提交的数据. 解决第一类丢失更新和脏读的问题,但是会出现不可重复读. REPEATABLE READ 保证一个事务相同条件下前后两次获取的数据是一致的. 解决第一类丢失更新,脏读,不可重复读问题. SERIALIZABLE 事务被处理为顺序执行. 解决所有问题 - 有点类似于锁表,但性能极其低下. 提醒:mysql默认的事务隔离级别为repeatable_read 总结 事务隔离级别 脏读 不可重复读 幻读 读取未交(read uncommitted) √ √ √ 读已提交(read committed) × √ √ 可重复读(repeatable read) × × √ 串行化(serializable) × × × 事务的演示准备工作 1234567drop table account;create table account( id int(7) primary key, name varchar(20), balance double(7,2));insert into account values(1,&#x27;admin&#x27;,1000.00),(2,&#x27;tom&#x27;,&#x27;20000.0&#x27;); READ UCOMMITTED设置事务的隔离级别READ UCOMMITTED - 一个事务才可以读取到另外一个事务尚未提交的数据. A事务 1234567891011121314mysql&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) A事务 123mysql&gt; update account set balance = 1000.0 where id=2;Query OK, 1 row affected (0.10 sec)Rows matched: 1 Changed: 1 Warnings: 0 B事务:读取到了脏数据,另外一个事务中尚未提交的数据 12345678mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) A事务 12mysql&gt; rollback;Query OK, 0 rows affected (0.12 sec) B事务:在同一个事务中,多次读取到的数据不一样 12345678mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) 总结:一旦事务设置成了读未提交的隔离级别.产生脏读以及不可重复读的效果 READ COMMITTED设置事务的隔离级别为read committed A事务 1234567891011121314mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level read committed;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) A事务 123mysql&gt; update account set balance=1000.0 where id=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 B事务:此时发现balance没有改变,没有产生脏读 12345678mysql&gt; select * from account;+----+-------+----------+| id | name | balance |+----+-------+----------+| 1 | admin | 1000.00 || 2 | tom | 20000.00 |+----+-------+----------+2 rows in set (0.00 sec) A事务 12mysql&gt; commit;Query OK, 0 rows affected (0.11 sec) B事务:在当前事务中多次查询,发现读取到了不同的数据,不可重复读. 123456789mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) 总结: 一个事务只能读取到另外一个事务中已经提交的数据 不会出现脏读了,但仍然出现不可重复读 REPEATABLE READ可重复读 - 在同一个事务中,多次读取到的数据是一样的[不关心其他事务做了什么] - mysql的默认的隔离级别 A事务 1234567891011121314mysql&gt; set session transaction isolation level repeatable read;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) B事务 1234567891011121314mysql&gt; set session transaction isolation level repeatable read;Query OK, 0 rows affected (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) A事务 123mysql&gt; update account set balance=2000.0 where id=2;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 B事务:拒绝脏读 12345678mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec) A事务 12mysql&gt; commit;Query OK, 0 rows affected (0.12 sec) B事务:可重复读 1234567891011121314151617181920mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 1000.00 |+----+-------+---------+2 rows in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from account;+----+-------+---------+| id | name | balance |+----+-------+---------+| 1 | admin | 1000.00 || 2 | tom | 2000.00 |+----+-------+---------+2 rows in set (0.00 sec) 在同一个事务中,不关心其他事务是否对这个数据作任何改变,当前的事务中多次读取到的结果是一样的,如果想要读取到另外一个事务修改的数据,必须先结束自己当前的事务再去查询.","categories":[],"tags":[{"name":"DTL","slug":"DTL","permalink":"http://beautifulboyy/tags/DTL/"}]},{"title":"数据库DDL DML","slug":"mysql02","date":"2021-08-20T06:27:30.000Z","updated":"2021-08-21T02:26:30.064Z","comments":true,"path":"2021/08/20/mysql02/","link":"","permalink":"http://beautifulboyy/2021/08/20/mysql02/","excerpt":"","text":"DDLDDL [Data Definition Language] - 数据定义语言 SQL命令 create - 创建 创建表(table),视图(view),用户(user),函数(function),存储过程(procedure),数据库(database),约束(constraints) 以上构建的都是属于数据库DB的对象/单位 - DB的基本单位是table drop - 删除 删除表(table),,视图(view),用户(user),函数(function),存储过程(procedure),数据库(database),约束(constraints) 但是不能够删除具体行记录,行记录是由delete命令删除的. alter - 修改 修改列名,列的类型,修改约束 - 使用情况很少 rename to - 修改表名 comment - 创建列的时候加上注释 truncate - 清空整张表 ORM思想Object-Relational-Mapping - 对象关系映射 需要用到OO思想[第一步找出对象,分析对象的属性,分析对象的功能,考虑对象之间的关系]来进行实体类的设计 - 数据库的设计 掌握目标 - 看到实体类-&gt;表结构;看到表结构-&gt;实体类 映射规则: 实体类 - 表名 对象标识(id) - 主键(id) - primary key - 非空且唯一 普通属性 - 普通列[推荐俩者的名称保持一致.需要注意的是如果列是多个名称[匈牙利] - 小驼峰] 对象之间的关系 - 外键(foreign key) - 表与表之间是通过外键来进行关联.[进行关联查询的基础] 通常情况下某张表的外键是指向另外一张表的主键的. 对象之间的关系分析一个”小米商城”,利用OO思想,找出业务中的关键对象 登录,注册 - “用户User对象” - (id,phone,password,login_time,login_ip) 个人中心 - 其中有一块是用来负责展示用户的详情UserInfo 产品 产品详情 购物车 - id,商品id,商品名称,商品单价,num,小计算,总价,备注 订单 - 一个用户拥有多个订单,一个订单只能属于一个用户 产品分类表 1:N N:N 1:1User和UserInfo:一个用户匹配一个用户详情,一个用户详情仅属于一个用户 强调的是平等性 - 表设计中,外键可以出现在任何一方表中. 原则 - 能用单向关联解决的业务就不要使用双向关联 java实体类 12345678910111213141516171819202122232425262728293031先阶段的思想 - 实体类中没有外键的概念关系具有方向性单向关联 - 关系的维护仅仅在其中一方存在 // 情况一public class User&#123; private Integer id; private String phone; private String password; // 一个用户拥有一个用户详情对象 private UserInfo userInfo;&#125;public class UserInfo&#123; private Integer id; private String header; private Gender sex;&#125;// 情况二public class User&#123; private Integer id; private String phone; private String password;&#125;public class UserInfo&#123; private Integer id; private String header; private Gender sex; private User user;&#125; ORM思想的精髓 - 如何进行映射以及为什么需要这种思想 12345678910111213// 双向关联[不建议]public class User&#123; private Integer id; private String phone; private String password; private UserInfo userInfo;&#125;public class UserInfo&#123; private Integer id; private String header; private Gender sex; private User user;&#125; 表设计 情况一: user表 id phone password user_info_id 1 110 123456 2 2 111 123456 1 3 112 123456 3 user_info表 id header sex 1 xx.png f 2 tt.png m 3 zz.png f 情况二: user表 id phone password 1 110 123456 2 111 123456 3 112 123456 user_info表 id header sex user_id 1 xx.png f 2 2 tt.png m 1 3 yy.png f 3 1:N一个用户对象和购物车对象 一个用户可以拥有多个购物车对象,但是一个购物车对象只能属于一个用户 外键存储在多的那一方 实体类 123456789101112131415161718192021222324252627// 单向关联1public class User&#123; // 普通属性 // 一个用户可以拥有多个购物车对象 private Set&lt;Cart&gt; carts;&#125;public class Cart&#123; &#125;// 单向关联2public class User&#123; //普通属性&#125;public class Cart&#123; // // 一个购物车只能属于一个用户 private User user;&#125;// 双向关联public class User&#123; private Set&lt;Cart&gt; carts;&#125;public class Cart&#123; private User user;&#125; 推荐使用第一种单向关联的方式 表结构 user表 id phone password 1 110 123 2 114 123 3 115 123 购物车cart表 id product_id product_name user_id 1 1 mi01 3 2 2 mi02 1 3 3 mi02 2 N:N需要拆分成两个一对多 一个学生可以选择多门课程,一个课程可以被多个学生选择 一个客户可以购买多个商品,一个商品可以被多个用户购买 customer表 id cname 1 admin 2 tom product表 id pname price 1 mac 100000 2 xiaomi 8000 3 huawei 8000 4 联想 7000 需要建立第三方表,来确定customer表和product表的关系.N:N–&gt;拆分成两个1:N purchase表 -&gt; 购买表 采用的是联合主键[组合主键] 主键-primary key - 非空且唯一.作用:用来确定唯一元组[行] 所谓的”俩个1:n” - customer表和purcase表以及product表和purcase表 一个客户拥有多条购买记录[1:N] 一个产品拥有多条被购买记录[1:N] 主键列未必是单列[常见的id列] , N:N场景可以采取联合主键,主键列由俩列共同组成**(customer_id,product_id)** 外键列通常情况是引入另外一张表的主键列.在该表中.外键列有2列 分别是customer_id 引用了customer表中的id列 product_id引用了product表中的id列 customer_id product_id 1 1 1 2 2 1 2 3 2 4 另一种情况关于主键的选择.第三方表[用来维护关系的表],开发的时候,还是推荐给这张自己一个单独的主键列 id customer_id product_id 1 1 1 2 1 2 3 2 1 4 2 3 5 2 4 自关联当前表的外键列自关联到了自己表中的主键列 s_emp id first_name manager_id[上司id] 1 Carmen 2 Mark 1 3 tom 1 4 admin 2 5 jack 2 分析评论业务以抖音为例 - User - Video 关注评论功能.一个用户可以评论多个视频,一个视频可以被多个用户评论 - N:N User表 id phone password username 1 110 123 qwq 2 111 123 qaq 3 112 123 ovo Video表 一个用户可以发布多个视频,但是一个视频只能由一个用户去发布 1:N id 视频标题 视频点赞量 user_id 1 吴老师 100万+ 2 2 霍老师 2000+ 1 3 翟老师 18 1 评论表 - 重点体现出谁评论了哪个视频即可. 外键列是可以为空的 id 视频id user_id 评论内容 comment_pid 1 1 4 无语了 2 1 5 渣男 3 2 2 彼此彼此 4 1 6 就是啊 1 user_id=6的评论不是直接对视频进行评论的,属于第二层评论,它是对user_id=4的人进行评论的. 除了评论还有回复 第一层 - 评论表的数据 第二层 - 对第一层的评论继续评论 第三层 - 对第二层以及其以后的评论/回复 - 叫做回复 回复表 一个评论可以引起多个回复 - reply id comment_id content replay_id user_id 1 4 真不明白怎么会有这样的人 1 2 4 这种人真的无语了 1 2 结构: user_id=1的用户发视频 user_id=4: 无语了 ​ user_id=6: 就是啊 ​ user_id=1回复了user_id=6: 真不明白怎么会有这样的人 ​ user_id=2回复了user_id=1: 这种人真的无语了 表设计 - 三大范式表设计一定尽可能去遵守三大范式 作用:指导db的设计更加合理化,避免数据的冗余. 第一范式1NF:保证列的原子性,列不可再分割 1234567891011s_emp(id,name);但是发现外国的name比较特殊.发现name列是可再分割的.不符合1NF.需要对name进行切割s_emp(id,first_name,last_name);address只需要包含省市区school(id,name,address);1 苏州大学 江苏省苏州市工业园区2 常州大学 江苏省常州市武进区3 苏州科技学院 江苏省苏州市高新区school(id,name,province,city,area); 第二范式2NF:基于1NF,不存在非关键列部分依赖于关键列,非关键列要全部依赖于关键列. 关键列 - 主键列; 非关键列 - 非主键列. 12345678910111213141516171819202122-- student,course表 - 所有的信息合并到一张表了.--1. student信息以及course信息都会存在数据的冗余性-- 如何确定主键列[单列,组合形式] - 能够确定唯一的一条行记录 - sid,cid-- db设计中,并不是表的数量或者列的数量越少越好的 - 满足三大范式-- 关键列(sid,cid),非关键列(sname,cname)-- ①(sid,cid) -&gt; 唯一确定 sname 实际上如果关键列中的部分列sid就可以确定了sname的值 sname只需要由关键列(sid,cid)中的部分列[也就是sid列]就可以确定了. 存在了非关键列sname部分依赖于关键列,违背了2NF-- ②(sid,cid) -&gt; 唯一确定 cnamestudent_course(sid,sname,cid,cname)sid sname cid cname1 tom 1 java1 tom 2 python2 admin 1 java2 admin 3 jack为了满足2NFstudent(sid,sname);//学生表 sid-&gt;snamecourse(cid,cname);//课程表 cid-&gt;cnamesc(sid,cid,score);//选课表 (sid,cid)-&gt; score 第三范式3NF:基于2NF,不存在非关键列传递依赖于关键列,所有的非关键列要直接依赖于关键列 12345678910111213141516171819202122student(id,sname,uno,uname,address)1 tom x1001 苏州大学 江苏省2 jack x1002 社会大学 东北省3 james x1001 苏州大学 江苏省关键列只有id列①关键列id可以直接确定一个唯一的uno的②uno又可以直接确定唯一的一个uname③给定一个学生的id,也是可以确定一个唯一的unameid -&gt; uno -&gt; uname =&gt; id -&gt; unameuname是间接被id确定下来的-uname是间接依赖[通过一个uno传递依赖]于关建列id.违背了3NF,存在了非关键列传递依赖于关键列.所有的非关键列要直接依赖于关键列 - 所有的非关键列应该是直接被关键列来确定的.修改 - 拆分student(id,sname,uid);//uid就是大学的idid -&gt; uid(引用university表中的id列)university(id,uno,uname,adress)uid-&gt;uname 建表1234567891011CREATE TABLE 表名( 列名 数据类型[(长度)], 列2 数据类型[(长度)], ... ... 列 数据类型[(n)])ENGINE=InnoDB DEFAULT CHARSET=utf8;-- mysql5.7及其以上可以省略了ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 前提是my.ini文件配置好了-- 指定我们的数据的存储引擎InnoDB,表编码是utf8 数据类型列的数据类型就是用来限制你将来插入数据到该列的限制.该列是什么类型,就需要插入什么类型的数据 数字相关的 a. 整数 - int和bigint b. 小数 - float,double[使用最多],decimal 笔试题中:TINYINT(1个字节)或者smallint(2个字节) 字符串相关的 - mysql中字符串是用单引号表示的 a. char(n) - 固定长度 - 0-255 bytes[ascill] b. varchar(n) - 可变长度 - 0-65535 bytes[unicode的范围] c. text - 长文本数据 笔试题中:mysql中char和varchar的区别 123456数字5代表的是该列可以存储的字符串的个数.不是代表字节数char(5) - 定长字符的意思是即时该列仅仅保存一个字母&#x27;a&#x27;,那么在内存中,char的实际消耗的长度就是5个 - &quot;浪费&quot; 对char类型的列的读写操作效率高于varcharvarchar(5) - 可变长度[最大可保存的字符串的长度],实际存储了一个字母&#x27;a&#x27;.实际也就只消耗了一个1长度 - &quot;节约了内存&quot; - 按需分配.因此,开发中尽可能字符串使用varchar,而不使用char. 日期 a. date -&gt; 即使保存的是年月日时分秒,查询出来的也仅仅只会显示到年月日 b. datetime-&gt;年月日时分秒.即使保存的数据仅仅是年月日.但是查询出来的时候,可以显示年月日时分秒 建表demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253drop table tbl_product;create table tbl_product( id int(3), name varchar(20), create_time date, price double(10,2));-- 分析括号中的参数-- int(3)-并不会影响该列可插入数据的一个范围.范围仍然是int型的范围-- 为了看出来int(3),修改一下建表语句-- int(13)想要看出来效果,这个列一定要加上zerofill,不足位数的用0填充create table tbl_product( id int(13) zerofill, name varchar(20), create_time date, price double(7,2));mysql&gt; insert into tbl_product values(1234,&#x27;tom&#x27;,now(),123.45);mysql&gt; select * from tbl_product;+---------------+------+-------------+--------+| id | name | create_time | price |+---------------+------+-------------+--------+| 0000000001234 | tom | 2021-08-19 | 123.45 |+---------------+------+-------------+--------+总结:int(n)此处的n不会影响插入到该列的数据的大小.那么n是配合zerofill来进行的.查询的时候,不足n位的数字全部用0填充.-- 修改表结构-测试varchar(n)中的n - 个数create table tbl_product( id int(7), name varchar(2), create_time date, price double(10,2));-- 如果varchar(n)设置成了2,但是插入了&#x27;tom&#x27;,报错-- ERROR 1406 (22001): Data too long for column &#x27;name&#x27; at row 1mysql&gt; insert into tbl_product values(1,&#x27;tom&#x27;,now(),123.45);-- 总结:varchar(n) - 中的n是代表的是字符的个数[一个汉字就是代表一个]-- double(m,n)-- m代表的是总长度,n代表的是精度 - double(7,2)create table tbl_product( id int(7), name varchar(20), create_time date, price double(7,1));mysql&gt; insert into tbl_product values(2,&#x27;admin&#x27;,&#x27;2021-10-01&#x27;,123456.56789);-- double(7,2) -&gt; 7就是总的长度,2代表的精度[四舍五入] - 123456.56789 -- 插入失败了 - Out of range value for column &#x27;price&#x27; at row 1-- 插入失败的原因是123456.57 -&gt; 这个结果已经超过了总的长度7了.-- 修改double(7,1) -&gt; 123456.56789 -&gt; 123456.6 -&gt; 仍然没有超过7这个总的长度的. - 可以被插入进去的 分析括号中的参数. int(n) 并不会影响该列可插入数据的一个范围,范围仍然是int型的范围.n是配合zerofill来进行的.查询的时候,不足n位的数字全部用0填充. varchar(n)中的n代表的是字符的个数[一个汉字就代表一个],如果超过了就会报错. double(m,n)m代表的是总长度,n代表的是精度 例如double(7,2)最大可以插入的长度的例子是12345.67 1234567891011mysql&gt; show tables;mysql&gt; desc tables;-- 查看建表语句mysql&gt; show create table tbl_product CREATE TABLE `tbl_product` ( `id` int(7) DEFAULT NULL, `name` varchar(20) DEFAULT NULL, `create_time` date DEFAULT NULL, `price` double(3,2) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8 删除表在不考虑外键因素的情况下,是可以直接删除表的. 1DROP TABLE 表名; 约束constraint作用:在插入到表中列的数据进行进一步的限制 约束类型 主键约束[primary key] - 非空且唯一,用来确定唯一的行记录 – pk 非空约束[not null] - 非空 - 该列不能为null,比如插入值或给定一个默认值 - nn 唯一约束[unique] - 唯一性 - nq 外键约束[foreign key] - 表与表之间的关系是通过外键来维护的,外键列一般是对应某张表的主键列,可以为null - fk 列级添加优点:比较简单,缺点:不能给约束取名字 语法: 1234567CREATE TABLE 表名(列名 数据类型[(长度)] [约束类型1],列2 数据类型[(长度)] [约束类型2],......列 数据类型[(n)])ENGINE=InnoDB DEFAULT CHARSET=utf8; 12345678drop table tbl_product;create table tbl_product( id int(7) primary key comment &#x27;产品的id&#x27;, name varchar(20) not null unique comment &#x27;产品的名称&#x27;, create_date date not null default &#x27;2021-7-20&#x27;, price double(7,2) not null);-- 注意类型为date的时候默认值不能为now();类型为datetime才可以为now() 演示约束 1234567891011121314151617181920212223insert into tbl_product(id,name,price) values(1,&#x27;tom&#x27;,123.567);mysql&gt; select * from tbl_product;+----+------+-------------+--------+| id | name | create_date | price |+----+------+-------------+--------+| 1 | tom | 2019-01-01 | 123.57 |+----+------+-------------+--------+-- 继续插入一个id也是1的值insert into tbl_product(id,name,price) values(1,&#x27;admin&#x27;,123.567);ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;-- 违背了primary key主键约束的规则 - 重复了.-- not null-- 没有给price插入值,但是该列存在一个not null非空约束insert into tbl_product(id,name) values (2,&#x27;tom&#x27;);-- ERROR 1364 (HY000): Field &#x27;price&#x27; doesn&#x27;t have a default value-- unique 唯一性,表中已经存在了一行记录是tominsert into tbl_product(id,name,price) values(2,&#x27;tom&#x27;,12.3);-- name字段/列值重复了.ERROR 1062 (23000): Duplicate entry &#x27;tom&#x27; for key &#x27;name&#x27; 表级添加优点:可以给约束命名,列级是不支持给列取名称的. 但not null 非空约束以及default仅仅支持列级添加的方式 语法 1[constraint 约束名称] 约束类型(列) 123456789drop table tbl_product;create table tbl_product( id int(7), name varchar(20) not null, create_date date not null default &#x27;2019-1-1&#x27;, price double(7,2) not null, constraint tbl_product_id_pk primary key(id), unique(name)); 外键约束foreign key - 简称fk.用来确定表之间的关系的.外键通常是是在多的一方. 1.1:N或1:1 123456789101112131415161718192021222324252627282930drop table tbl_user;create table tbl_user( id int(7) primary key, username varchar(20) not null unique);insert into tbl_user values(1,&#x27;tom&#x27;);insert into tbl_user values(2,&#x27;admin&#x27;);drop table tbl_video;create table tbl_video( id int(7) primary key, title varchar(20), likes int(7), create_time datetime default now(), tbl_user_id int(7) references tbl_user(id));-- 一旦创建了约束,插入数据的时候需要注意的是.-- 外键列是允许为空的.insert into tbl_video values(1,&#x27;学好myql&#x27;,100,now(),1);insert into tbl_video values(2,&#x27;学好java&#x27;,100,now(),1);insert into tbl_video values(3,&#x27;学习jdbc&#x27;,100,now(),2);-- 注意.既然已经定义了外键的约束.那么插入数据的时候,引用的外键列的值在另外一张表中一定要有行记录的-- tbl_user表中是不存在id=3的行记录的insert into tbl_video values(3,&#x27;mysql太简单了&#x27;,100,now(),3);-- 报错ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`j03s`.`tbl_video`, CONSTRAINT `tbl_video_table_user_id_fk` FOREIGN KEY (`tbl_user_id`) REFERENCES `tbl_user` (`id`)) 2.N:N 123456789101112131415161718192021222324252627-- 评论表 一个用户可以对多个视频进行评论,一个视频可以被多个用户进行评论-- 拆分成两个1:N-- 组合主键+外键约束(表级添加)drop table tbl_comment;create table tbl_comment( user_id int(7), video_id int(7), content varchar(50), comment_id int(7), constraint tbl_comment_user_id_pk primary key(user_id,video_id), constraint tbl_comment_user_id_fk foreign key(user_id) references tbl_user(id), constraint tbl_comment_video_id_fk foreign key(video_id) references tbl_video(id)); -- 评论表拥有独立的主键id + 外键约束(列级添加)drop table tbl_comment;create table tbl_comment( id int(7) primary key, user_id int(7) references tbl_user(id), video_id int(7) references tbl_user(id), content varchar(50), comment_id int(7) references tbl_comment(comment_id));insert into tbl_comment(id,user_id,video_id,content) values(1,1,1,&#x27;好的,我会学会mysql的&#x27;);insert into tbl_comment values(2,2,1,&#x27;好的,我会学会mysql的&#x27;,1); 建议还是使用constraint,不然有错误都不知道. 建表补充由一张表来构建另一张表 保留原表的表结构+数据 1create table 表名 select 语句; 12345drop table video_copy;create table video_copy select * from tbl_video;drop table video_copy;create table video_copy select id,tilte from tbl_video; 保留原表的表结构,但是不需要原表的数据 12drop table video_copy;create table video_copy select id,title from tbl_video where 1=2; DMLinsert 插入数据 delete 删除数据 update 更新数据 插入语句 语法一:给表中所有的列添加数据 插入的列值要和建表语句中列顺序以及列的类型以及列的约束高度保持一致. 1INSERT INTO 表名 VALUES(列值1,列值2,列值3,..,列值N) 语法二:给表中的指定列插入数据 1INSERT INTO 表名(列名1,列名2) VALUES(列值1,列值2); insert into 表名 select 语句 把查询结果的数据插入到该表中 1234567-- 统计视频的被评论的用户量,并且保存到另外一张表中 video_id,comment_numdrop table comment_aly;create table comment_aly( video_id int(7), comment_num int(7));insert into comment_aly select video_id,count(user_id) from tbl_comment group by video_id; auto_incrementmysql中的主键的生成策略 - 自增长策略 - auto_increment[默认的是从1开始,步长为1] oracle中的主键的生成策略 - 自增长 - sequence 应用场景:以后插入的时候[除非是模拟数据],id肯定是后台自动生成 - 唯一性. 1234567drop table comment_aly;create table comment_aly( id int(7) primary key auto_increment, video_id int(7), comment_num int(7));insert into comment_aly(video_id,comment_num) select video_id,count(user_id) from tbl_comment group by video_id; mysql中提供了一个函数last_insert() 查看最后一个id插入的数据 1mysql&gt; select last_insert_id(); 希望模拟数据的时候接着使用这个自增长,那么修改自增长的初始值 12mysql&gt; alter table comment_aly auto_increment=8;insert into comment_aly(video_id,comment_num) values(1,3); 删除语句 清空表 - delete语句不带where 123delete from 表名;delete from video_copy; 带条件的删除 - 删除1条,不删除,删除多条 1234delete from 表名 where语句;-- 删除video_copy表中id=2的行记录delete from video_copy where id=2; 更新语句 更新的整张表的数据 - 不带where语句 123456789101112语法:-- 更新所有的行的单列update 表名 set 列名=新的列值;-- 更新所有的行的多列.update 表名 set 列1=新的列值1,列2=新的列值2,列n=新的列值n;-- 比如更新video_copy表中的likesupdate video_copy set likes=likes*1.1;-- 比如更新video_copy表中的likes和titleupdate video_copy set likes=200,title=&#x27;java无敌&#x27;; 更新指定条件的行记录 - where语句 12更新id=2的titleupdate video_copy set title=&#x27;python不错&#x27; where id=2; 约束注意点 先删除多的一方表,再删除的一的一方的表 删除行记录的时候,需要先把这个行记录在其他表中被引用的行记录要全部删除之后,才能删除自己. 创建表的时候,应该先创建一的一方,然后创建多的一方 删除表123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 删除表不是随意删除的 - 前提是创建了外键约束-- 先删除多的一方表,再删除的一的一方的表drop table tbl_comment;drop table tbl_user;drop table tbl_video;-- 用户表create table tbl_user( id int(7) primary key, username varchar(20) not null unique);insert into tbl_user values(1,&#x27;tom&#x27;);insert into tbl_user values(2,&#x27;admin&#x27;);-- 视频表create table tbl_video( id int(7) primary key, title varchar(20), likes int(7), create_time datetime default now(), -- 外键列命名方式 表名_另外一张表的引用列名[主键列] -- 外键列的数据类型和长度和你引用的地方保持一致 tbl_user_id int(7), -- 表级添加 constraint tbl_video_table_user_id_fk foreign key(tbl_user_id) references tbl_user(id));-- 一旦创建了约束,插入数据的时候需要注意的是.-- 外键列是允许为空的.insert into tbl_video values(1,&#x27;学好myql&#x27;,100,now(),1);insert into tbl_video values(2,&#x27;学好java&#x27;,100,now(),1);insert into tbl_video values(3,&#x27;学习jdbc&#x27;,100,now(),2);-- 评论表create table tbl_comment( id int(7) primary key, user_id int(7), video_id int(7), content varchar(50), comment_id int(7), constraint tbl_comment_user_id_fk foreign key(user_id) references tbl_user(id), constraint tbl_comment_video_id_fk foreign key(video_id) references tbl_video(id), constraint tbl_comment_id_fk foreign key(comment_id) references tbl_comment(id));insert into tbl_comment(id,user_id,video_id,content) values(1,1,1,&#x27;好的,我会学会mysql的&#x27;);insert into tbl_comment values(2,2,1,&#x27;好的,我会学会mysql的&#x27;,1); 分析删除表的顺序 12345678910-- 如果删除的是tbl_user或者tbl_video都会报错-- 报错的原因就是由外键约束存在导致的mysql&gt; drop table tbl_user;ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint failsmysql&gt; drop table tbl_video;ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint fails-- 应该要先删除子记录[外键所在的表中的记录],然后再删除父记录 - 先删除多的一方表,再删除的一的一方的表-- 多的一方的外键引用的是一的一方的主键. 删除行记录1234567891011121314151617-- id=2的用户是在tbl_comment中存在一条行记录的,它是被引用了.mysql&gt; delete from tbl_user where id=2;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tbl_comment`, CONSTRAINT `tbl_comment_user_id_fk` FOREIGN KEY (`user_id`) REFERENCES `tbl_user` (`id`))-- id=2的所有的评论的全部删除[删除子记录],然后再去删除id=2的用户mysql&gt; delete from tbl_comment where user_id=2;-- 然后才能去删除id=2的用户,已经把用户id=2这个用户的所有的评论全部删除了mysql&gt; delete from tbl_user where id=2;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`j03s`.`tbl_video`, CONSTRAINT `tbl_video_table_user_id_fk` FOREIGN KEY (`tbl_user_id`) REFERENCES `tbl_user` (`id`))id=2的用户又发布了一条视频,它也在tbl_video表中被引用了.mysql&gt; delete from tbl_video where tbl_user_id=2;-- 等把id=2的用户的所有评论信息以及发布的视频全部删除完毕之后,才可以删除自己mysql&gt; delete from tbl_user where id=2; 约束的缺点外键约束 - 保证数据的完整性和一致性.缺点 - 表之间的关系越强烈[手动创建了约束条件] - 表之间的耦合越高. 在下周DB设计 - 不要手动创建约束 - 弱化表之间的关系 - “表的关系 - 心中” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960驰星CRM系统 - 学生信息,项目经理信息-- 假设一个项目经理可以教多个学生-- dev_id是外键列student(id,sname,school,dev_id);1 杨晓轩 文正养老学院 22 闫昊 八一农垦 13 刘静 八一农垦 2dev(id,dev_name,age);1 success 182 james 453 小强 19如果建表的时候create table student( //...foreign key(dv_id) references dev(id););-- 导致的后果,不能随意删除项目经理.项目经理只要有学生信息.就不能删除项目经理.-- 现实生活中 - success上台了,james开除了...mysql&gt; delete from dev where id=2;//删除失败了.因为james在student表中有子记录-- 要想删除james,需要删除他所有的学生.实际的业务 - 肯定不允许我去删除&quot;宝贵的学生信息&quot;-- 目标 - 1. 成功删除项目经理-- 2. 知道学生曾经是哪个老师带过的.-- 因此,在建表的时候,其实是允许数据的冗余性的.drop table t_student;drop table dev;create table dev( id int(7) primary key auto_increment,dev_name varchar(20),age int(3));insert into dev values(1,&#x27;success&#x27;,18);insert into dev values(2,&#x27;james&#x27;,45);create table t_student( id int(7) primary key auto_increment,sname varchar(20),school varchar(20),-- 此处没有进行约束的添加 - &quot;关系在心中即可&quot;dev_id int(7),-- 数据的冗余 - 防止项目经理的记录被删除dev_name varchar(20));insert into t_student values(1,&#x27;杨晓轩&#x27;,&#x27;文正养老学院&#x27;,2,&#x27;james&#x27;);insert into t_student values(2,&#x27;闫昊&#x27;,&#x27;八一农垦&#x27;,1,&#x27;success&#x27;);insert into t_student values(3,&#x27;刘静&#x27;,&#x27;八一农垦&#x27;,1,&#x27;success&#x27;);-- 虽然没有给dev_id列创建约束,业务分析可以确定该列就是用来&quot;维护俩表之间的关系的&quot;-- 查询学生的姓名以及项目经理的姓名以及年龄mysql&gt; select s.sname,d.dev_name,d.age from t_student s join dev d on s.dev_id=d.id;-- 开除james,没有约束,可以直接删除mysql&gt; delete from dev where id=2; 物理删除和逻辑删除 物理删除就是真正意义上的delete语句 逻辑删除 - 建议 - 比较安全 因为数据是不能随意删除的.数据是需要后台进行数据分析的.用户的端的删除大部分都是逻辑删除. 实际上就是每张表都会增加逻辑列. 1234567891011121314drop table xx_del;create table xx_del( id int(7) primary key, name varchar(20), status int(7));insert into xx_del values(1,&#x27;tom&#x27;,0);insert into xx_del values(2,&#x27;admin&#x27;,1);-- 首页 - 加载xx_del表中所有的信息 [加载status=1的信息]select * from xx_del where status = 1;-- 删除按钮 - 逻辑删除 - 执行updateupdate xx_del set status=0 where id=1;","categories":[],"tags":[{"name":"DDL","slug":"DDL","permalink":"http://beautifulboyy/tags/DDL/"},{"name":"DML","slug":"DML","permalink":"http://beautifulboyy/tags/DML/"}]},{"title":"mysql基础","slug":"mysql01","date":"2021-08-16T01:14:08.000Z","updated":"2021-08-20T06:26:41.324Z","comments":true,"path":"2021/08/16/mysql01/","link":"","permalink":"http://beautifulboyy/2021/08/16/mysql01/","excerpt":"","text":"数据库数据库Database - 简称DB 数据按照一定的数据结构来进行组织,存储和管理的仓库. 学习的数据库mysql - 目前最主流的关系型数据库[免费的.现在属于oracle公司的] 安装的版本&gt;=5.7.x -&gt; 发展[mysql5.5.x,mysql5.6.x,mysql.5.7.x,mysql8.x] - 版本不一样,语法存在差异. SQLSQL - Structured Query Language - 结构化查询语言 作用: 脚本文件 - 以.sql为脚本的文件 我们本质上就是通过sql语法/命令来操作我们的DB 功能分类 DQL(Data Query Language) - 数据查询语言 - sql的核心 select DML(Data Manipulation Language) - 数据操纵语言 insert update delete DDL(Data definition Language) - 数据定义语言 create alter drop DCL(Data Control Language) - 数据控制语言 grant[授权] revoke[取消授权] DTL(Data Transaction Language) - 数据事务语言 commit savepoint rollback 脚本文件mysql中的script文件是以.sql为后缀的文件. mysql - 数据库 - 由若干张表组成的仓库,数据是存储在一张二维表[关系]中的. 如果一个数据库存储数据的格式是一个行和列组成表 - 关系[表格]型数据库 生成若干张表 表中插入若干条数据. 准备工作登录mysql 1mysql -uroot -p123456 操作仓库新建仓库MYSQL就是通过仓库的形式来管理我们的数据的. 语法:CREATE DATABASE 仓库名; sql的语法大小写是不敏感的. 12ysql&gt; create database j03s;Query OK, 1 row affected (0.00 sec) 查看所有的仓库12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || j03s || mysql || performance_schema || sys |+--------------------+ 使用仓库1mysql&gt; use j03s; 查看所有的表1mysql&gt; show tables; 导入脚本12mysql&gt; source sql脚本文件的绝对路径;mysql&gt; source /Users/admin/Desktop/j03s_mysql_all/教学脚本/mysql_cn.sql; 该脚本文件中的表 123456789+----------------+| Tables_in_j03s |+----------------+| s_customer || s_dept || s_emp || s_ord || s_region |+----------------+ 继续导入 - 面试中常常使用到的一个脚本 12345678+----------------+| Tables_in_j03s |+----------------+| course || sc || student || teacher |+----------------+ 确认数据的编码建议修改编码之后,建议重启mysql服务 右击计算机 - 管理 - 服务 - 服务和应用程序 - 右边的窗口 - mysql - 右击重启 1mysql&gt; show variables like &#x27;char%&#x27;; 123456789101112+--------------------------+-----------------------------------------------------------+| Variable_name | Value |+--------------------------+-----------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql-5.7.28-macos10.14-x86_64/share/charsets/ |+--------------------------+-----------------------------------------------------------+ 需要对每一项进行单独的设置 1mysql&gt;set character_set_client=utf8; mysql插入中文乱码 检测上面的编码 my.ini文件在哪里 1234567[client]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8 本身自己的cmd的编码 如果还有问题,卸载重来. 查询简单查询属于DQL命令 - select命令 query语法 查询的本质 查什么 到哪里查[必须先使用数据库,然后才能查看这个库下的表] 1234-- 查询整张表的某些列SELECT 列1,列2,列n FROM 表名;-- 查询整张表中的所有列,*代表所有的列SELECT * FROM 表名; 查询表结构1234567891011desc 表名;mysql&gt; desc student;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(10) | YES | | NULL | || sname | varchar(10) | YES | | NULL | || age | datetime | YES | | NULL | || sex | varchar(10) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+ 查询练习 查询student表中的姓名sname 1234567891011121314151617181920212223242526 select sname from student;2. 查询student表中的学生信息 ~~~mysql select * from student;3. 查询s_emp员工表中的first_name和last_name ~~~mysql select first_name,last_name from s_emp;4. 查询客户[s_customer]的姓名以及客户的电话号码 ~~~mysql select name,phone from s_customer;5. 查询s_emp中的title列 ~~~mysql select title from s_emp;6. 排重关键字distinct 列名 ~~~mysql select distinct title from s_emp; 条件查询query-conditional语法 如果查询语句后面不加where条件,查询的是整张表中的数据 需要对数据进行筛选,需要使用条件查询 语法 1234-- 查询满足条件表达式的数据SELECT 列1,列2,列nFROM 表名WHERE 条件表达式; 运算符 比较运算符 =,&gt;,&lt;,&gt;=,&lt;=,!= 其他运算符 2-1. in(集合列表) 2-2. not in(集合列表) 2-3. between … and … 在 … 和 …区间 - 是一个闭区间 is null - 判断某列是否为空,注意判断是否为空,不能使用= is not null - 判断某列是否不为空,不能使用!= 逻辑运算符 not and - 用来连接多个条件的,多个条件同时为true,才能返回结果 or - 用来连接多个条件的,只要有一个条件成立,就会返回结果. 条件查询练习 查询工资高于1200的员工的信息[id,first_name,salary] 1select id,first_name,salary from s_emp where salary &gt; 1200; 把部门编号为41,42,43的员工信息查询出来 12345678910111213141516 select id,first_name,dept_id from s_emp where dept_id in(41,42,43);3. 查询工资在1200~1450之间的员工的信息 ~~~mysql select id,first_name,salary from s_emp where salary between 1200 and 1450;4. 查询title[职称]为Stock Clerk的员工信息 ~~~mysql select id,first_name,title from s_emp where title = &#x27;Stock Clerk&#x27;;5. 查询有提成[commission_pct]的员工信息 ~~~mysql select id,first_name,commission_pct from s_emp where commission_pct is not null; 列别名和列的计算 可以给列重新命名 1234567891011121314-- 语法一:列1 列别名1 - 推荐使用的语法mysql&gt; SELECT 列1 列别名1,列2 列别名2 FROM 表名 [WHERE条件查询];mysql&gt; select id 编号,first_name 名字,salary 工资 from s_emp;-- 语法二: 列1 as 列别名1 - 不推荐使用mysql&gt;select id as 编号,first_name as 名字,salary as 工资 from s_emp;-- 语法三: mysql中可以使用双引号来保持/包裹格式-- 列1 &quot;列别名1&quot;mysql&gt; select id &quot;编号&quot;,first_name &quot;名字&quot;,salary &quot;工资&quot; from s_emp;-- 需求:希望列别名每个汉字间距一点[空一格]mysql&gt; select id &quot;编 号&quot;,first_name &quot;名 字&quot;,salary &quot;工 资&quot; from s_emp; mysql中的列支付计算 12-- 查询员工的年薪mysql&gt; select first_name,salary*12 年薪 from s_emp; 练习:查询员工的年薪,但是要包括提成 在mysql中null值直接进行计算,结果还是null值*,因此一般需要对null值进行处理,如果是数字列为null.需要作为0来进行处理 mysql中内置了很多函数 - 空值置换函数 - coalesce(m,n) 计算规则类似于java中的三元操作符m==null?n:m 1select id,first_name,salary*12*(1+coalesce(commission_pct,0)/100) 年薪 from s_emp; 模糊查询使用like关键字 % - 占位符 - 代表任意多个任意字符 _ 占位符 - 代表任意单个任意字符 模糊查询练习 比如查询teacher表中所有的李姓老师 1select * from teacher where tname like &#x27;李%&#x27;; 比如查询first_name第三个字母是e的员工信息 123456 select id,first_name from s_emp where first_name like &#x27;__e%&#x27;;3. 查询职称title中包含VP的并且工资高于1200的员工信息 ~~~mysql select id,first_name,title,salary from s_emp where title like &#x27;%VP%&#x27; and salary&gt;1200; 查询first_name以M开头的员工信息 1select id,first_name from s_emp where first_name like &#x27;M%&#x27;; 查询first_name中不包含字母n的员工信息 1select id,first_name from s_emp where first_name not like &#x27;%n%&#x27;; 找出非41,42,43部门的员工 1select id,first_name,dept_id from s_emp where dept_id not in(41,42,43); 转义字符了解即可 12mysql&gt; update s_emp set first_name=&#x27;Car_men&#x27; where id=1;mysql&gt; update s_emp set first_name=&#x27;Ma_rk&#x27; where id=4; 需求 - 查询first_name中包含_的员工信息 1234567mysql&gt; select first_name from s_emp where first_name like &#x27;%_%&#x27;;默认的转义字符mysql&gt; select first_name from s_emp where first_name like &#x27;%\\_%&#x27;;自定义转义字符mysql&gt; select first_name from s_emp where first_name like &#x27;%?_%&#x27; escape &#x27;?&#x27;; 列的拼接功能s_emp表中first_name[名]和last_name[姓] db设计满足三大范式.第一范式保证列的原子性 - 列不可再分割. 姓名 -姓一列+名一列 12-- 拼接的过程也使用到了内置函数concat(...) - 可变长列表mysql&gt; select concat(last_name,&#x27; &#x27;,first_name) 姓名 from s_emp; 排序12345-- 排序的语法SELECT 列1,列2,列nFROM 表名[WHERE 条件表达式][ORDER BY 列名] [asc | desc]; 练习 查看员工的信息,找出工资大于1200的,并且根据salary来升序 123456-- order by + 列名select id,first_name,salary from s_emp where salary&gt;1200 order by salary desc;-- order by + 列的序号 列的序号是查询语句中的列的序号,列的序号是从1开始的[推荐使用]select id,first_name,salary from s_emp where salary&gt;1200 order by 3 desc;-- order by + 列别名select id,first_name,salary _sal from s_emp where salary&gt;1200 order by _sal desc; 查看员工的信息,找出工资大于1200的,并且根据salary来降序.如果salary一样,那么继续根据first_name来进行一个升序. 1select first_name,salary from s_emp where salary&gt;1200 order by 2 desc,1; 找出年薪高于21000的员工的信息[包括提成的],并且根据年薪降序排. 1select first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp where salary*12*(1+coalesce(commission_pct,0)/100)&gt;21000 order by 2 desc; 利用子查询求解 1select * from (select id,first_name,salary*12*(1+coalesce(commission_pct,0)/100) year_salary from s_emp) temp where year_salary&gt;21000 order by 3 desc; 高级查询多表查询,表和表之间的关系 - 通过外键列来维护的. RDBMS专业术语 主键列 外键列 - 确定好外键列是进行多表查询的前提,通常外键列是交给多的一方进行维护的 关联查询传统的写法 错误的写法 - 笛卡尔积 123456789-- 查询员工(s_emp)的id,first_name以及这个员工所在的部门(s_dept)的id以及部门的名称mysql&gt; select id,first_name,id,name from s_emp,s_dept;ERROR 1052 (23000): Column &#x27;id&#x27; in field list is ambiguous如果查询的结果中出现多个表中同名的列,请你给表取别名,通过表别名.列名mysql&gt; select e.id,e.first_name,d.id,d.name from s_emp e,s_dept as d;总共出现了300条 = 25 * 12 进行筛选 - 去除错误的笛卡尔积 1mysql&gt; select e.id,e.first_name,d.id,d.name from s_emp e,s_dept as d where e.dept_id = d.id; 练习 3-1. 找出外键列 3-2. 去除笛卡尔积 12345-- 找出区域在&#x27;Asia&#x27;的所有的员工信息mysql&gt; select e.first_name,r.name from s_emp e,s_dept d,s_region r where r.name=&#x27;Asia&#x27; and r.id = d.region_id and e.dept_id=d.id;-- 缺点 - 如果表的数量一旦增多,发现哪些表和哪些之间是否有直接的关系.我们体验不会太好 查看学生的姓名,课程的名字,以及该课程授课的老师的名字以及该学生在这门课的得分情况 student,course,teacher,sc 1mysql&gt;select s.sname,c.cname,t.tname,_sc.score from student s,course c,teacher t,sc _sc where _sc.sid = s.id and _sc.cid = c.id and c.tid = t.id; join + on写法表 join 表 on 一的一方的主键 = 多的一方的外键. on的目的不是为了进行条件筛选 - 目的去除笛卡尔积 只要具有直接关系的俩张表才能够使用join进行连接 内连接 - 默认的inner join,但是inner可以省略不写 练习 查询部门id为31的部门名称以及该部门下的员工的名字和薪水 1select e.first_name,e.salary,d.name from s_emp e join s_dept d on d.id = e.dept_id; 找出区域在’Asia’的所有的员工信息 12345678910111213141516 select e.id,e.first_name,e.dept_id,d.name,r.name from s_emp e join s_dept d on e.dept_id = d.id join s_region r on d.region_id = r.id;3. 李老师的授课情况信息,包括教的学生的姓名,课程的名字,以及该课程授课的老师的名字以及该学生在这门课的得分情况 ~~~mysql select s.sname,c.cname,t.tname,sc.score from sc join student s on sc.sid = s.id join course c on c.id = sc.cid join teacher t on t.id = c.tid where t.tname like &#x27;李%&#x27;;4. 查看顾客的id,姓名以及该顾客拥有的订单信息[订单所有列] ~~~mysql select c.id,c.name,o.* from s_customer c join s_ord o on o.customer_id = c.id;5. 查看所有区域,以及这个区域上的部门信息 ~~~mysql select * from s_dept d join s_region r on d.region_id = r.id; 左连接和右连接 内连接 - inner join 查看顾客的id,姓名以及该顾客拥有的订单id - 拥有订单的客户才能够被查询出来 - inner join 12345678910111213141516171819202122232425262728mysql&gt;select c.id,c.name,o.id oid from s_customer c inner join s_ord o on c.id = o.customer_id;-- 总共查询得到16条数据-- inner join - 结果中少掉了207和215俩个客户 - 因为查看订单表s_ord,发现这俩个人就没有订单信息-- inner join - 内连接的写法,A表 join B表 - 如果A表中的记录在B表中不存在.那么关联查询之后.这个在B表中不存在的A表中的-- 这个记录也同样不会被关联查询出来.mysql&gt; select c.id,c.name,o.id oid from s_customer c inner join s_ord o on c.id = o.customer_id;+-----+----------------------------+-----+| id | name | oid |+-----+----------------------------+-----+| 201 | Unisports | 97 || 202 | OJ Atheletics | 98 || 203 | Delhi Sports | 99 || 204 | Womansport | 100 || 205 | Kam&#x27;s Sporting Goods | 101 || 206 | Sportique | 102 || 208 | Muench Sports | 103 || 208 | Muench Sports | 104 || 209 | Beisbol Si! | 105 || 210 | Futbol Sonora | 106 || 211 | Kuhn&#x27;s Sports | 107 || 212 | Hamada Sport | 108 || 213 | Big John&#x27;s Sports Emporium | 109 || 214 | Ojibway Retail | 110 || 204 | Womansport | 111 || 210 | Futbol Sonora | 112 |+-----+----------------------------+-----+16 rows in set (0.00 sec) 分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344mysql&gt; select c.id,c.name from s_customer c;+-----+----------------------------+| id | name |+-----+----------------------------+| 201 | Unisports || 202 | OJ Atheletics || 203 | Delhi Sports || 204 | Womansport || 205 | Kam&#x27;s Sporting Goods || 206 | Sportique || 207 | Sweet Rock Sports || 208 | Muench Sports || 209 | Beisbol Si! || 210 | Futbol Sonora || 211 | Kuhn&#x27;s Sports || 212 | Hamada Sport || 213 | Big John&#x27;s Sports Emporium || 214 | Ojibway Retail || 215 | Sporta Russia |+-----+----------------------------+15 rows in set (0.00 sec)mysql&gt; select o.id,o.customer_id from s_ord o;+-----+-------------+| id | customer_id |+-----+-------------+| 97 | 201 || 98 | 202 || 99 | 203 || 100 | 204 || 101 | 205 || 102 | 206 || 103 | 208 || 104 | 208 || 105 | 209 || 106 | 210 || 107 | 211 || 108 | 212 || 109 | 213 || 110 | 214 || 111 | 204 || 112 | 210 |+-----+-------------+16 rows in set (0.00 sec) 左连接 - left join A表 join B表 - 以left join左边的表为基准表.右边的表非基准表.如果基准表中的记录在非基准表不存在.但是也能够查询出来. 如果这个客户没有订单信息,那么也要将这个客户的信息查询出来 12345678910111213141516171819202122232425mysql&gt; select c.id,c.name,o.id oid from s_customer c left join s_ord o on c.id = o.customer_id;+-----+----------------------------+------+| id | name | oid |+-----+----------------------------+------+| 201 | Unisports | 97 || 202 | OJ Atheletics | 98 || 203 | Delhi Sports | 99 || 204 | Womansport | 100 || 205 | Kam&#x27;s Sporting Goods | 101 || 206 | Sportique | 102 || 208 | Muench Sports | 103 || 208 | Muench Sports | 104 || 209 | Beisbol Si! | 105 || 210 | Futbol Sonora | 106 || 211 | Kuhn&#x27;s Sports | 107 || 212 | Hamada Sport | 108 || 213 | Big John&#x27;s Sports Emporium | 109 || 214 | Ojibway Retail | 110 || 204 | Womansport | 111 || 210 | Futbol Sonora | 112 || 207 | Sweet Rock Sports | NULL || 215 | Sporta Russia | NULL |+-----+----------------------------+------+18 rows in set (0.00 sec) 右连接 - right join A表 join B表 - 以right join右边的表为基准表.左边的表非基准表.如果基准表中的记录在非基准表不存在.但是也能够查询出来. 1select c.id,c.name,o.id oid from s_ord o right join s_customer c on c.id = o.customer_id; 自关联 - 自己关联自己 – 员工s_emp表中的manager_id - 上司的id -&gt; 绑定的就是s_emp表中的id 12345678910111213141516171819202122232425262728293031mysql&gt; select id,first_name,manager_id from s_emp;+----+------------+------------+| id | first_name | manager_id |+----+------------+------------+| 1 | Car_men | NULL || 2 | LaDoris | 1 || 3 | Midori | 1 || 4 | Ma_rk | 1 || 5 | Audry | 1 || 6 | Molly | 2 || 7 | Roberta | 2 || 8 | Ben | 2 || 9 | Antoinette | 2 || 10 | Marta | 2 || 11 | Colin | 3 || 12 | Henry | 3 || 13 | Yasmin | 3 || 14 | Mai | 3 || 15 | Andre | 3 || 16 | Elena | 6 || 17 | George | 6 || 18 | Akira | 7 || 19 | Vikram | 7 || 20 | Chad | 8 || 21 | Alexander | 8 || 22 | Eddie | 9 || 23 | Radha | 9 || 24 | Bela | 10 || 25 | Sylvie | 10 |+----+------------+------------+25 rows in set (0.00 sec) 练习 123-- 查询员工的名字,以及这个员工的上司的名字 - 一个上司拥有多个下属的.-- 效果:这个员工没有上司,也要能够查询出来.mysql&gt; select e1.first_name 员工名字,e2.first_name 上司 from s_emp e1 left join s_emp e2 on e2.id = e1.manager_id 分组查询语法 123456SELECT 语句FROM 表WHERE 语句GROUP BY 语句[HAVING 组函数判断]ORDER BY 语句 多行函数 count函数 - 统计个数 1234567891011121314-- 统计s_emp的员工的个数mysql&gt; select count(*) from s_emp;-- 除了可以写*,那么还可以推荐写idmysql&gt; select count(e.id) from s_emp e;-- 重复的数据也算1个mysql&gt; select count(title) from s_emp;-- 统计职称,重复的数据,只要统计一次mysql&gt; select count(distinct title) from s_emp;-- 如果遇到null值,忽略null值的统计mysql&gt; select count(commission_pct) from s_emp; avg,sum,min,max - 忽略null值 12-- 统计学生的得分情况mysql&gt;select avg(score),sum(score),min(score),max(score) from sc; group by 统计各个部门编号,以及整个部门的员工数量 1mysql&gt; select dept_id,ount(*) from s_emp group by dept_id; 统计部门人数大于等于3的部门的编号以及人数信息 1mysql&gt; select dept_id,count(*) from s_emp group by dept_id having count(*)&gt;=3; 统计部门[41,42,42]人数大于等于4的部门的编号以及人数信息 1mysql&gt; select dept_id,count(*) from s_emp where dept_id in(41,42,43) group by dept_id having count(*)&gt;=4; 统计部门[41,42,43]人数大于等于3的部门的编号以及人数信息,并且根据部门编号降序排列 1mysql&gt; select dept_id,count(*) from s_emp where dept_id in(41,42,43) group by dept_id having count(*)&gt;=3 order by 1 desc; 分组练习 经常分组统计 - 分组+统计.也是可以只进行分组的动作. 12345-- 统计每个职称的人数 - 分组+统计了mysql&gt; select title,count(id) from s_emp group by title;-- 只是分组 - 除了可以使用distinct来去重.那么我们也可以直接使用分组进行去重.mysql&gt; select title from s_emp group by title; 统计部门的名称,编号以及该部门上的员工的数量 1234567891011mysql&gt; select d.id,d.name,count(e.id) from s_emp e join s_dept d on e.dept_id = d.id group by d.id,d.name;-- 注意点,写group by 容易发生错误的地方.-- mysql5.7以后对group by的写法要求变得高了.推荐.-- 如果select后面除了存在组函数以外,还存在其他列.那么group by后面的列一定要和select后面的列高度保持一致.-- 1. select 列1,列2,组函数 from 表 group by 列1,列2-- 但是如果select后面只有组函数select count(e.id) from s_emp e join s_dept d on e.dept_id = d.id group by d.id; 统计每个客户的订单数量[超过1的统计出来],没有订单的客户也要能够统计出来 1mysql&gt; select c.id,c.name,count(o.id) from s_customer c left join s_ord o on c.id = o.customer_id group by c.id,c.name having count(o.id)&gt;1; 统计每个区域的部门的数量 1mysql&gt; select r.id,r.name,count(d.id) from s_region r join s_dept d on r.id = d.region_id group by r.id,r.name; 统计每个区域上的员工的数量 12mysql&gt;select r.name,r.id,count(e.id) from s_region r join s_dept d on r.id = d.region_id join s_emp eon e.dept_id = d.id group by r.name,r.id; 统计每个学生的课程的总分,平均分 12345mysql&gt; select v.sid,sum(v.score),avg(v.score) from sc v group by v.sid;-- 统计每个学生的id,姓名以及他的课程的总分,平均分mysql&gt; select s.id,s.sname,sum(v.score),avg(v.score) from student s left join sc v on s.id = v.sidgroup by s.id,s.sname; 统计每个老师授课的课程的数量 1mysql&gt; select t.id,t.tname,count(c.id) from teacher t join course c on t.id = c.tid group by t.id,t.tname; 统计每个课程的最低分,最高分,平均分 12mysql&gt; select c.id,c.cname,min(v.score),max(v.score),avg(v.score) from course c join sc v on c.id = v.cid group by c.id,c.cname; 统计李老师的学生数量 1234mysql&gt; select t.id,t.tname,count(v.sid) from teacher t join course c on t.id = c.tidjoin sc v on v.cid = c.id where t.tname like &#x27;李%&#x27;group by t.id,t.tname; 子查询子查询是效率不如关联查询.但是子查询更加灵活.能用关联查询解决的查询,肯定也是可以通过子查询去解决. 但是子查询可以解决关联查询解决的查询.使用原则优先使用关联查询. 注意点:子查询必须要使用()括号 三个维度 子查询作为外部查询的列. 子查询作为外部查询的where语句中 子查询可以看做是一张”虚拟表/临时表”,可以对这个”虚拟表”再次进行查询. 子查询作为外部查询的where语句中12345678910-- 查询和&#x27;Ben&#x27;在同一个部门的员工first_name,dept_id;-- 分解 - 找出&#x27;Ben&#x27;的部门idmysql&gt; select dept_id from s_emp where first_name=&#x27;Ben&#x27;;//43-- 找出43部门的所有的员工,但是不包含Benmysql&gt; select first_name,dept_id from s_emp where first_name!=&#x27;Ben&#x27; and dept_id=43;-- 整合到一块儿mysql&gt; select first_name,dept_id from s_emp where first_name!=&#x27;Ben&#x27; and dept_id=(select dept_id from s_emp where first_name=&#x27;Ben&#x27;); 子查询作为外部查询的列123456-- 查询客户的id,客户的姓名,以及该客户的订单个数mysql&gt; select c.id,c.name,(select count(o.customer_id) from s_ord o where c.id=o.customer_id) 订单数量from s_customer c;-- 查询部门的id,部门的名称,以及这个部门上的员工的个数mysql&gt; select d.id,d.name,(select count(e.id) from s_emp e where e.dept_id = d.id) 员工数 from s_dept d; 子查询可以看做是一张”虚拟表/临时表”,可以对这个”虚拟表”再次进行查询12345678910111213141516171819202122-- 用子查询来实现 - 查询和&#x27;Ben&#x27;在同一个部门的员工first_name,dept_id-- (select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27;)结果必须返回单个值mysql&gt; select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27;) from s_emp e;和下面的这个效果是一样的mysql&gt; select e.first_name,e.dept_id from s_emp e;-- 修改-- 思路 e.first_name,子查询e.dept_id - 判断成立 - 有值,否则为null-- e.dept_id是否和&#x27;Ben&#x27;是一个部门的.select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27; and e.dept_id=e1.dept_id) didfrom s_emp e;-- 把上面的查询的结果作为&quot;虚拟表&quot; - 别名 - core_select * from ( select e.first_name,(select e.dept_id from s_emp e1 where e1.first_name=&#x27;Ben&#x27; and e.dept_id=e1.dept_id) did from s_emp e) core_ where core_.did is not null and core_.first_name&lt;&gt;&#x27;Ben&#x27;; exists和not exists用法 exists - 是否存在.只要存在,那么就返回true - 顺利被查询出来 not exists - 不存在 如果是false,反而会被顺利查询出来 案例 1234-- exists(子查询 - 如果有结果,返回true,否则返回false)mysql&gt;select first_name from s_emp where exists(select 1 from s_emp where 1=1);mysql&gt;select first_name from s_emp where not exists(select 1 from s_emp where 1=2); 练习 查询和’Ben’在同一个部门的员工first_name,dept_id 1select e1.first_name,e1.dept_id from s_emp e1 where exists (select 1 from s_emp e2 where e1.dept_id = e2.dept_id and e2.first_name = &#x27;Ben&#x27;) and e1.first_name&lt;&gt;&#x27;Ben&#x27;; 找出各个部门工资排名前二的员工 “e-我”这个部门中,如果还有人工资比我高.那么这个数量不能超过1个. 1select e1.first_name,e1.salary,e1.dept_id from s_emp e1 where exists(select 1 from s_emp e2 where e1.dept_id = e2.dept_id and e2.salary&gt;e1.salary having count(*)&lt;=1) order by 3; not exists来实现的 12345不存在&#x27;我e&#x27;这个部门中,有人的工资比我高.并且这个数量超过1个.mysql&gt; select e.dept_id,e.first_name,e.salary from s_emp e where not exists( select 1 from s_emp e1 where e.dept_id = e1.dept_id and e1.salary&gt;e.salary having count(*)&gt;1) order by 1; 找出各个部门中工资最高的 1select e1.first_name,e1.salary,e1.dept_id from s_emp e1 where exists(select 1 from s_emp e2 where e1.dept_id = e2.dept_id and e2.salary &gt; e1.salary having count(*) &lt; 1) order by 3; 这块不是特别懂!!!要多做做题 mysql函数字符串函数 instr(str,substr) - 返回字符串substr在字符串str第一次出现的位置(str不包含substr时返回0) mysql下标索引从1开始的 1mysql&gt;select instr(&#x27;ppopo&#x27;,&#x27;o&#x27;);//3,找不到则返回0 lpad(str,len,padstr) - 用字符串padstr填补str左端直到字串长度为len并返回 1mysql&gt; select lpad(&#x27;parttime&#x27;,22,&#x27;nice&#x27;);//niceniceniceniparttime rpad(str,len,padstr) - 用字符串padstr填补str右端直到字串长度为len并返回 1mysql&gt;select rpad(&#x27;abc&#x27;,6,&#x27;do&#x27;);//abcdod left(str,len) - 返回字符串str的左端len个字符 1mysql&gt; select left(&#x27;sakurayo&#x27;,2);//sa right(str,len) - 返回字符串str的右端len个字符 1mysql&gt; select right(&#x27;sakurayo&#x27;,2);//yo substring(str,pos,len) - 返回字符串str的位置pos起len个字符 1mysql&gt; select substring(&#x27;sakura&#x27;,3,2);//ku substring(str,pos) - 返回字符串str的位置pos起后面的子串 1mysql&gt; select substring(&#x27;sakura&#x27;,3);//kura ltrim(str) - 返回删除了左空格的字符串str 1mysql&gt; select ltrim(&#x27; qq &#x27;); //qq rtrim(str) - 返回删除了右空格的字符串str 1mysql&gt; select rtrim(&#x27; qq &#x27;);// qq space(n) - 返回由n个空格字符组成的一个字符串 1mysql&gt; select space(4); replace(str,from_str,to_str) - 用字符串to_str替换字符串str中的子串from_str并返回 1mysql&gt; select replace(&#x27;skura&#x27;,&#x27;ku&#x27;,&#x27;sasasa&#x27;);//ssasasara reverse(str) - 颠倒字符串str的字符顺序并返回 1mysql&gt; select reverse(&#x27;sakura&#x27;);//arukas insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串 12mysql&gt; select insert(&#x27;Carmen&#x27;,2,5,&#x27;*****&#x27;);//C*****mysql&gt; select insert(&#x27;Carmen&#x27;,3,2,&#x27;*&#x27;); //Ca*en lower(str) - 返回小写的字符串str 1mysql&gt; select lower(&#x27;AbcD&#x27;);//abcd upper(str) - 返回大写的字符串str 1mysql&gt; select upper(&#x27;abCd&#x27;);//ABCD char_length(str) - 不管汉字还是数字或者是字母都算是一个字符。 12mysql&gt; select char_length(&#x27;sqwe&#x27;);//4mysql&gt; select char_length(&#x27;s我e&#x27;);//3 length(str);//汉字占3个,其他占1个. 12mysql&gt; select length(&#x27;sqwe&#x27;);//4mysql&gt; select length(&#x27;s我e&#x27;);//5 concat(a,b…n);//字符串 s1,s2 等多个字符串合并为一个字符串 1mysql&gt; select concat(&#x27;hello!&#x27;,&#x27;看我!&#x27;,&#x27;你在&#x27;,&#x27;害怕&#x27;,&#x27;什么&#x27;);//hello!看我!你在害怕什么 列中的应用123456789101112131415161718192021222324252627282930-- 将first_name列的数据全部反转mysql&gt; select first_name,reverse(first_name) from s_emp;-- 这些函数是允许嵌套使用的mysql&gt; select first_name,upper(reverse(first_name)) from s_emp;-- 练习 - 模拟银行账户的输出方式-考虑该列是中文的情况.-- 查询效果-- Car_men C******-- 吴亦凡 吴**-- Mark M**-- concat函数 - 字符串的拼接mysql&gt; select first_name,concat(substring(first_name,1,1),rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 显示账户 from s_emp;-- replace函数-- replace(str,oldStr,newStr);mysql&gt; select first_name,replace(first_name,substring(first_name,2),rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 账户 from s_emp;-- 直接使用rpad函数-- rpad(str,拼接之后总的长度,appendStr);mysql&gt;select first_name,rpad(substring(first_name,1,1),char_length(first_name),&#x27;*&#x27;) 账户 from s_emp;-- 使用insert函数-- insert(str,pos,len,newstr) - 把字符串str由位置pos起len个字符长的子串替换为字符串-- insert函数的基本使用mysql&gt; select insert(&#x27;abcde&#x27;,2,3,&#x27;*&#x27;);//a*emysql&gt; select first_name,insert(first_name,2,char_length(first_name)-1,rpad(&#x27;*&#x27;,char_length(first_name)-1,&#x27;*&#x27;)) 账户 from s_emp; 数字函数 abs(n) - 求绝对值 mod(n,m) - 取模运算,返回n被m除的余数(同%操作符) floor(n) - 返回不大于n的最大整数值 - 向下取整 ceiling(n) - 返回不小于n的最小整数值 - 向上取整 round(n[,d]) - 返回n的四舍五入值,保留d位小数(d的默认值为0) 123mysql&gt;select round(3.5);mysql&gt;select round(3.456,2);//3.46 pow(x,y) - 返回值x的y次幂 sqrt(n) - 返回非负数n的平方根 pi() - 返回圆周率 rand() - 返回在范围**[0到1.0)**内的随机浮点值 truncate(n,d) - 保留数字n的d位小数并返回 - 直接截取 练习 求1~3之间的随机整数 12mysql&gt; select floor(rand()*3+1);mysql&gt; select truncate(rand()*3+1,0); 计算年薪 - 保留小数点2位 1select first_name,truncate(salary*12*(1+coalesce(commission_pct,0)/100),2) 年薪 from s_emp; 日期函数查询当前系统的日期 - select now(); dayofweek(date) - 返回日期date是星期几(1=星期天,2=星期一,……7=星期六,odbc标准) weekday(date) - 返回日期date是星期几(0=星期一,1=星期二,……6= 星期天) year(date) - 返回date的年份(范围在1000到9999) month(date) - 返回date中的月份数值 dayofmonth(date) - 返回date是一月中的第几日(在1到31范围内) hour(time) - 返回time的小时数(范围是0到23) minute(time) - 返回time的分钟数(范围是0到59) second(time) - 返回time的秒数(范围是0到59) period_add(p,n) - 增加n个月到时期p并返回(p的格式yymm或yyyymm) 1234mysql&gt; select period_add(&#x27;202108&#x27;,3);-- 需求把s_emp表中的start_date往后延1个月mysql&gt; select start_date,period_add(date_format(start_date,&#x27;%Y%m&#x27;),1) from s_emp; 注意:p可以是字符串,一定要满足一定的格式,或者可以直接使用date类型. period_diff(p1,p2) - 返回在时期p1和p2之间月数(p1和p2的格式yymm或yyyymm) p1-p2 curdate() - 以’yyyy-mm-dd’或yyyymmdd格式返回当前日期值(根据返回值所处上下文是字符串或数字) curtime() - 以’hh:mm:ss’或hhmmss格式返回当前时间值(根据返回值所处上下文是字符串或数字) now() - 以’yyyy-mm-dd hh:mm:ss’或yyyymmddhhmmss格式返回当前日期时间(根据返回值所处上下文是字符串或数字) last_day(date) - date日期所在月的最后一天是什么时候 datediff(d1,d2) - 两个日期d1,d2之间相差的天数 timestampdiff(type,d1,d2) - type - year,month,day… mysql中,虽然日期date_format函数来转成字符串类型的,mysql内部为了简化我们的写法,有的时候有的函数. 只要你传入的字符串满足一定的格式,那么它就会自动被转成日期函数. 补充1234567891. date_add(date,interval n type)2. date_sub(date,interval n type)type:yearmonthdayhourminutesecond 日期格式化date_format(date,format) - 把日期转换成指定模板的字符串. 根据format字符串格式化date值 (在format字符串中可用标志符: %m 月名字(january……december) %w 星期名字(sunday……saturday) %d 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(sun……sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(jan……dec) %j 一年中的天数(001……366) %H 24时制小时(00……23) %k 小时(0……23) %h 12时小时(01……12) %i 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [ap]m) %t 时间,24 小时(hh:mm:ss) %s 秒(00……59) %p am或pm %w 一个星期中的天数(0=sunday ……6=saturday ） 1mysql&gt; select start_date,date_format(start_date,&#x27;%Y-%m-%d %H:%i:%s&#x27;) from s_emp; 日期练习 找出员工的工作月数 - 和当前的日比较的 1mysql&gt; select first_name,start_date,timestampdiff(month,start_date,now()) 月份 from s_emp; 查询员工的工作天数 123mysql&gt; select first_name,start_date,timestampdiff(day,start_date,now()) 天数 from s_emp;mysql&gt; select first_name,start_date,abs(datediff(start_date,now())) 天数 from s_emp; 计算一年前,当前,一年后的日期 date_add(date,interval n type) date_sub(date,interval n type) 123mysql&gt; select date_sub(now(),interval 1 year) 一年前,now() 当前,date_add(now(),interval 1 year) 一年后;mysql&gt; select date_add(now(),interval -12 month) 一年前,now() 当前,date_add(now(),interval 12 month) 一年后; 当前日期前6个月的最后一天 1mysql&gt; select last_day(date_sub(now(),interval 6 month)); 把员工的入职日期格式化为年/月/日 1234mysql&gt; select start_date,date_format(start_date,&#x27;%Y-%m-%d&#x27;) from s_emp;-- 1990年05月03日mysql&gt; select start_date,date_format(start_date,&#x27;%Y年%m月%d日&#x27;) from s_emp; 找出5月份入职的员工 1mysql&gt; select first_name,start_date from s_emp where month(start_date)=5; 类型的转换日期转字符串数据查询出来之后显示用的. date_format(date,模板); 字符串转日期插入数据的时候,需要将日期列的字符串转换成日期类型,才能够插入到date类型列. mysql中只要你的字符串满足默认支持的格式.那么就会默认转成date类型. 123456789-- date列insert into test_date values(3,&#x27;xx&#x27;,&#x27;2019-09-08&#x27;);//ok &#x27;2019-09-08&#x27;insert into test_date values(4,&#x27;xx&#x27;,&#x27;2019/10/08&#x27;);//ok &#x27;2019/10/08&#x27;insert into test_date values(5,&#x27;xx&#x27;,&#x27;20191105&#x27;);//ok &#x27;20191105&#x27;insert into test_date values(5,&#x27;xx&#x27;,&#x27;2018-11-05 13:08:09&#x27;);//ok假设如果指定的是一个非法的字符串模板mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;05/11/2023&#x27;);ERROR 1292 (22007): Incorrect date value: &#x27;05/11/2023&#x27; for column &#x27;d1&#x27; at row 1 解决一个非法模板的字符串 - mysql不能把这个形式的字符串自动转换成date/datetime类型 str_to_date(str,pattern) 123str的格式也必须要和pattern是匹配 - 实现str-date类型的转换mysql&gt; insert into test_date values(6,&#x27;xx&#x27;,str_to_date(&#x27;05/11/2023&#x27;,&#x27;%d/%m/%Y&#x27;)); date和datetimedate - 年月日 datetime - 年月日时分秒 mysql中列如果是一个日期,常用的俩个类型分别是date和datetime 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051drop table test_date;create table test_date( id int(7), name varchar(20), d1 date);-- 插入数据insert into test_date values(1,&#x27;admin&#x27;,now());-- 插入指定的日期到表中mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;20191105&#x27;);-- 列是date,但是插入数据包含时分秒的mysql&gt; insert into test_date values(5,&#x27;xx&#x27;,&#x27;2018-11-05 13:08:09&#x27;);-- 查询出来的d1列的内容默认显示的日期的格式%Y-%m-%dmysql&gt; select * from test_date;+------+-------+------------+| id | name | d1 |+------+-------+------------+| 1 | admin | 2021-08-17 |+------+-------+------------+drop table test_datetime;create table test_datetime( id int(7), name varchar(20), d1 datetime);insert into test_datetime values(1,&#x27;tom&#x27;,now());-- 效果,如果列设置成了datetime,查询出来的模板是-%Y-%m-%d %H:%i:%smysql&gt; select * from test_datetime;+------+------+---------------------+| id | name | d1 |+------+------+---------------------+| 1 | tom | 2021-08-17 10:12:18 |+------+------+---------------------+-- 插入一个指定的日期 - 仅仅包含年月日mysql&gt; insert into test_datetime values(5,&#x27;xx&#x27;,&#x27;2019-09-08&#x27;);-- 时分秒是自动归05 | xx | 2019-09-08 00:00:00 mysql&gt;insert into test_datetime values(5,&#x27;xx&#x27;,&#x27;2019/09/08 13:12:18&#x27;);5 | xx | 2019-09-08 13:12:18","categories":[],"tags":[{"name":"DQL","slug":"DQL","permalink":"http://beautifulboyy/tags/DQL/"}]},{"title":"注解","slug":"java16","date":"2021-08-15T11:33:33.000Z","updated":"2021-08-15T11:40:49.480Z","comments":true,"path":"2021/08/15/java16/","link":"","permalink":"http://beautifulboyy/2021/08/15/java16/","excerpt":"","text":"注解jdk5.0开始引入了注解的机制. 框架的配置,框架的使用 - 1. 基于xml的配置方式 2. 基于注解的配置/开发方式 - 简洁 学习注解的目的是为了以后能够知道我们框架的使用中遇到注解,知道这个注解背后是个大概什么底层即可. 内置注解 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 @SuppressWarnings(“all”) - 抑制所有的警告 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 自定义注解 使用@interface来修饰注解,自动以的注解默认都会继承java.lang.Annotation @Target - 指定注解可以在什么地方被使用 类,方法,参数,接口,局部变量,属性,构造 值可以设置成枚举类型java.lang.annotation.ElementType中的枚举常量 123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; @Retention(RetentionPolicy.RUNTIME) 可以在程序的运行过程中通过反射的技术来得到注解的信息. 注解中只有方法的概念,没有属性的概念. 反射获取注解的值有办法来判断类或者方法是否加入了注解 有办法通过反射技术来获取类/方法上加入注解的属性值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package tech.aistar.day16.anno;import java.lang.reflect.Method;import java.util.Arrays;/** * 本类用来演示: 反射获取注解的值 * * @author: success * @date: 2021/8/13 2:39 下午 */public class MyAnnoTest &#123; public static void main(String[] args) &#123; //1. 判断某个类或者某个方法上是否有注解 //有注解 - 标志 - 对这个有注解的类该干嘛干嘛... //注解还配置了属性值 - 需要取出属性值,然后再进行进一步的处理... //类 Class&lt;?&gt; c = UseMyAnno.class; //1. 判断类上是否加入了MyAnno注解 boolean flag = c.isAnnotationPresent(MyAnno.class); if(flag)&#123; System.out.println(c.getSimpleName()+&quot;加入了注解!&quot;); //获取注解的属性值 - 前提是有 MyAnno myAnno = c.getAnnotation(MyAnno.class); //获取属性值 String[] arr = myAnno.value(); System.out.println(Arrays.toString(arr)); &#125;else&#123; System.out.println(c.getSimpleName()+&quot;上没有加入注解!&quot;); &#125; System.out.println(&quot;====方法上的注解的信息 - 反射技术===&quot;); try &#123; Method m = c.getDeclaredMethod(&quot;add&quot;); if(m.isAnnotationPresent(MyAnno.class))&#123; System.out.println(&quot;方法上有注解!&quot;); MyAnno myAnno = m.getAnnotation(MyAnno.class); String[] arr = myAnno.value(); System.out.println(Arrays.toString(arr)); &#125;else&#123; System.out.println(&quot;方法上没有注解...&quot;); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Mybatis注解开发方法mybatis底层使用到的是jdbc技术 - 和数据库打交道的技术 12345678910jdbc步骤很繁琐,步骤比较多~打开Connection con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;);String sql=&quot;delete from user&quot;;PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery();关闭rs.close();pstmt.close();con.close(); mybatis就是会对jdbc的代码进行一个封装 12345678public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll();&#125; 注解本身是不会完成任何的业务逻辑的 123456789101112通过反射的技术-&gt;select * from user 工具类&#123; Connection con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;); String sql=&quot;反射技术获取的&quot;; PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); 关闭 rs.close(); pstmt.close(); con.close();&#125;","categories":[],"tags":[{"name":"注解","slug":"注解","permalink":"http://beautifulboyy/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"面试题汇总","slug":"Interview-questions","date":"2021-08-13T13:18:04.000Z","updated":"2021-08-21T13:03:01.371Z","comments":true,"path":"2021/08/13/Interview-questions/","link":"","permalink":"http://beautifulboyy/2021/08/13/Interview-questions/","excerpt":"","text":"面试题汇总抽象类和接口的异同 相同点 抽象类和接口都属于抽象的数据类型,不能被实例化,只能被继承或实现. 抽象类和接口都可以包含抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法,但是如果这个子类是抽象的,就可以选择实现也可以选择不实现. 不同点 抽象类的关键字是abstract,接口的关键字是interface. 抽象类中允许存在构造方法,普通方法以及抽象方法.接口中不允许出现构造方法,允许出现抽象方法以及由default修饰的普通方法[jdk8.x]. 抽象类中允许定义普通属性,接口中只能定义公开静态的常量属性. 一个子类中最多只能继承一个抽象类,而一个实现类可以同时实现多个接口. int和Integer之间的区别 Integer是int的包装类型;int是基本数据类型. Integer变量必须实例化后才能使用;int变量不需要. Integer实际是对象的引用,指向此new的Integer对象;int是直接存储数据值. Integer的默认值是null;int的默认值是0. 泛型不支持int,但是支持Integer. int存储在栈中,Integer对象的引用存储在栈空间中,对象的数据存储在堆空间中. == 和 equals的区别 == - 基本数据类型比较,比较的是基本类型的值. equals - 对象类型比较,如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这时候仍然使用到的是==比较.如果重写了equals方法,就看equals提供的是哪些属性一致的时候,才返回true. synchronized和Lock的区别synchronized和lock都属于独占锁. 实现层面不同.synchronized是java关键字,jvm层面实现加锁和释放锁.Lock是一个接口,在代码层面实现加锁和释放锁. 是否自动释放锁.synchronized在线程代码执行完或出现异常时自动释放锁.Lock不会自动释放锁,需要在finally{}代码块中显式地释放锁. 是否一致等待.synchronized线程拿不到锁时会一直等待.Lock可以设置尝试获取锁或者获取锁失败一定时间超时 获取锁成功是否可知.synchronized无法得知是否获取锁成功.Lock可以通过tryLock判断是否获取锁成功. 功能复杂性.synchronized加锁可重入,不可中断,非公平.Lock可重入,可中断,可公平和不公平,细分读写锁提高效率. String,StringBuilder,StringBuffer的异同 相同点:三者之间都是用final修饰的,都是不可以被继承的. 不同点 String是不可变的字符串,线程安全,比较耗费系统资源和内存.性能是三者之中最低的. StringBuilder是可变的字符串,线程不安全,效率最高. StringBuffer是可变的字符串,线程安全,效率低于StringBuilder,但是高于String 方面 区别 可变与不可变 String类是不可变的,StringBuffer和StringBuilder是可变的. 线程是否安全 String类线程安全,StringBuilder类线程非安全,StringBuffer线程安全 效率 String&lt;StringBuffer&lt;StringBuilder final和finally和finalize三者之间的区别final: 修饰的局部变量一旦赋值成功,不可改变. 修饰的属性一旦赋值成功,不可改变. 修饰的类不可被继承 修饰的方法不可被重写 finally 一般是和try…catch搭配使用的,try块无论是否出现异常,finally块中代码都会执行. finally块中一般写的是释放或者关闭资源的代码. finalize finalize是Object类中提供的方法,当GC想去回收一个垃圾对象之前,会去调用这个对象的finalize方法,是由jvm去调用的. 该方法未必一定会被调用的到. HashMap和HashTable的区别 线程安全 - HashMap是非线程安全的,HashTable是线程安全的,HashTable内部的方法基本都经过synchronized修饰. 效率 - 由于线程安全问题,HashMap的效率高于HashTable 对于null key和null value的支持 - HashMap允许将null作为一个key或者value,而HashTable不允许. 初始容量大小和每次扩容大小的不同 创建时如果不指定容量初始值,HashTable的默认初始大小为11,之后每次扩容容量变为原来的2n+1.而HashMap默认初始大小为16,之后每次扩容容量变为原来的2倍. 创建时如果给定了容量初始值,HashTable会直接使用给定的初始值,而HashMap会将其扩充为2的幂次方大小. 底层数据结构 - JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化,当链表大于阈值(默认为8)时,将链表转化为红黑树,以减少搜索时间.HashTable没有这样的机制. 注:HashTable是保留类不建议使用,推荐在单线程环境下使用HashMap,多线程环境下使用ConcurrentHashMap.","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"反射技术","slug":"java15","date":"2021-08-12T03:18:20.000Z","updated":"2021-08-15T11:33:36.746Z","comments":true,"path":"2021/08/12/java15/","link":"","permalink":"http://beautifulboyy/2021/08/12/java15/","excerpt":"","text":"反射 反射式编程（英语：reflective programming）或反射（英语：reflection)或者内省 是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。[1]用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 通俗讲 - 通过反射技术在程序的运行过程中,来获取类/接口的信息[修饰符,类的名称,父类],属性的信息[修饰符,数据类型,属性名],方法的信息[修饰符,数据类型,名称]等. 在运行的时候才知道我操作的是哪个类. 掌握目录: 3-1. 通过反射技术来动态获取属性的信息以及操作属性[反射的技术来对属性的值进行设置和获取] 3-2. 通过反射技术来动态调用类中的构造方法以及获取构造方法的信息[修饰符,方法名,参数列表] 3-3. 通过反射技术来动态获取类里面的方法的信息[修饰符,数据类型,方法名以及方法参数列表]以及反射调用方法 api包 - java.lang.reflect 反射优势 - “很流氓” - 破坏封装性 学好反射和设计模式,帮助我们未来读懂一些框架源码.所有的框架底层都是基于反射技术来实现的. java.lang.Class class实例 - 一个类无论被实例化多少次,那么它在jvm中的class实例永远只有一个. 它是学习反射技术的必备的类 - 提供了很多api来完成掌握目标中的动作 所有被类加载器加载到内存中的类都是属于Class的对象 - Class是用来描述类的类[用来描述类的元信息] 我们的类在Class面前,就是Class的一个对象而已. 获取类的Class实例的方式 类名.class 调用java.lang.Object类提供的方法Class&lt;?&gt; getClass(); 框架底层喜欢的使用一种,更加灵活 Class类中提供的static Class&lt;?&gt; forName(“类的全限定名”);//需要抓取一个非运行时异常java.lang.ClassNotFoundException类型找不到异常 基本类型.class 1234567891011121314151617181920212223242526272829303132333435package tech.aistar.day16;/** * @Author liuWenXiu * @Date 2021/8/12 19:52 * @description Class创建 */public class ClassDemo &#123; public static void main(String[] args) &#123; // 1.类名.class Class&lt;?&gt; c1 = Point.class; System.out.println(c1); //class tech.aistar.day16.Point Point p = new Point(); // 2.Object类提供的getClass方法 Class&lt;?&gt; c2 = p.getClass(); System.out.println(c2); //class tech.aistar.day16.Point System.out.println(c1 == c2); //true // 3.Class类提供的static Class&lt;?&gt; forName(&quot;类的全限定名&quot;) // 非运行时异常 try &#123; Class&lt;?&gt; c3 = Class.forName(&quot;tech.aistar.day16.Point&quot;); System.out.println(c3); //class tech.aistar.day16.Point System.out.println(c2 == c3); //true &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; // 4.基本类型.class System.out.println(int.class); //int System.out.println(String.class); //class java.lang.String System.out.println(boolean.class); //boolean &#125;&#125; 反射相关api Field getField(String name); //根据属性的名称来获取非私有的Field对象 Filed[] getFields(); // 获取类里面的非私有的Field属性数组 Fileld getDeclaredField(String name); // 根据属性的名称来得到Filed对象 Field[] getDeclaredFields(); // 获取类里面的所有的Field属性数组 String getName();//获取类的全限定名 String getSimpleName();//获取类的简称 T newInstance();//调用空参构造 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes); 根据指定的参数类型来得到指定的构造对应的实例Constructor对象. 如果什么参数都不传入,拿到的就是空参构造对应的Constructor对应的实例. Constructor&lt;?&gt;[] getDeclaredConstructors(); 直接获取类中的所有的构造,每个构造对应一个Constructor. Method getDeclaredMethod(String methodName,Class&lt;?&gt;… parameterTypes); Method][] getDeclaredMethods(); Fieldjava.lang.reflect.Field api int getModifiers();返回由该 Field对象表示的字段的Java语言修饰符，作为整数。 1234//默认的 - 0//public -1//private - 2//protected - 4 Class&lt;?&gt; getType();//返回属性的数据类型 String getName();//属性的名称 void set(Object obj,Object value);//通过属性对应的Field对象来告知JVM,应该把value设置到哪个obj对象上去. void setAccessible(boolean on);//反射操作私有属性,必须要设置为true,否则会抛出-java.lang.IllegalAccessException 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package tech.aistar.day16;import java.lang.reflect.Field;import java.lang.reflect.Modifier;/** * @Author liuWenXiu * @Date 2021/8/12 20:10 * @description 反射技术来操作属性 */public class FieldDemo &#123; public static void main(String[] args) &#123; // 首先获取Class实例 Class&lt;?&gt; c = Point.class; // 获取Field对象 Field[] fields = c.getDeclaredFields(); for (Field field : fields) &#123; // 1. int getModifiers() 返回Field对象表示的字段java语言修饰符作为整数 //默认的-0 public-1 private-2 protected-4 //System.out.println(field+&quot;:&quot;+field.getModifiers()); // 想要打印输出具体的private等,需要调用下面的方法啊 // Modifier.toString()方法 System.out.print(Modifier.toString(field.getModifiers())+&quot; &quot;); // 2.获取属性的数据类型 Class&lt;?&gt; c1 = field.getType(); System.out.print(c1.getSimpleName()+&quot; &quot;); // 3. 获取属性的名称 System.out.println(field.getName()); &#125; System.out.println(&quot;-----------------------&quot;); try &#123; Point p = new Point(); Field x = c.getDeclaredField(&quot;x&quot;); System.out.print(Modifier.toString(x.getModifiers()) + &quot; &quot;); System.out.print(x.getType().getSimpleName()+&quot; &quot;); System.out.println(x.getName()); // 4.void set(Object obj,Object value); 通过属性对应的Filed对象来告知jvm应该把value设置到哪个对象上 // 可能会报异常java.lang.IllegalAccessException // 这个是因为属性可能是私有的,所以需要进行一个操作 // 5.void setAccessible(boolean on); x.setAccessible(true); x.set(p,21); System.out.println(p); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Constructor调用空参构造直接调用java.lang.Class提供的方法T newsIntance(); java.lang.reflect.Constructor提供了方法 1234public T newInstance(Object... initargs)Constructor&lt;?&gt; c1 = c.getDeclaredConstructor();Point p2 = (Point) c1.newInstance();//可变长列表的方法 调用带参构造java.lang.reflect.Constructor - 提供的方法 public T newInstance(Object … initargs) 构造demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package tech.aistar.day16;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * @Author liuWenXiu * @Date 2021/8/12 20:43 * @description 反射调用构造 */public class ConstructorDemo &#123; public static void main(String[] args) &#123; // 首先获取Class实例 Class&lt;?&gt; c = Point.class; // 第一种方式:直接利用反射调用空参构造 // 这种方法只能调用空参的构造,要抛出异常并且进行类型转换 try &#123; Point p1 = (Point) c.newInstance(); System.out.println(p1); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; // 第二种方式:利用可边长参数列表获取Constructor实例 try &#123; // 2.1 无参 - 同样需要抛出异常并强制类型转换 Constructor&lt;?&gt; c1 = c.getDeclaredConstructor(); Point p2 = (Point) c1.newInstance(); System.out.println(p2); // 2.2 一参 - 参考Point类的一参构造 //private Point(int x) Constructor&lt;?&gt; c2 = c.getDeclaredConstructor(int.class); //注意这个实参是正好与形参的Class对应的 // 还需要注意的是一个一参构造的修饰符是private,所以需要设置权限 c2.setAccessible(true); // 调用一参构造 Point p3 = (Point) c2.newInstance(10); // 这里的实参也是要对应的填入相应的值 System.out.println(p3); // 2.3 两参 - 参考Point类的两参构造 // public Point(int x, String y) Constructor&lt;?&gt; c3 = c.getDeclaredConstructor(int.class,String.class); Point p4 = (Point) c3.newInstance(10,&quot;sak&quot;); System.out.println(p4); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 常用方法 int getModifiers();//获取修饰符对应的数字 String getName();//构造方法的名称 - [类的全限定名] void setAccessible(boolean on);//如果设置true,直接调用私有的的构造方法 它可以破坏单例!!!! 1234567891011121314151617181920212223Constructor&lt;?&gt;[] constructors = c.getDeclaredConstructors();if(null!=constructors &amp;&amp; constructors.length&gt;0)&#123; // 遍历 for (Constructor&lt;?&gt; constructor : constructors) &#123; // 1.1 打印修饰符 System.out.print(Modifier.toString(constructor.getModifiers())+&quot; &quot;); // 1.2 打印构造名称 System.out.print(constructor.getName()+&quot;(&quot;); // 1.3 打印形参列表 Class&lt;?&gt; [] types = constructor.getParameterTypes(); if(null!=types &amp;&amp; types.length&gt;0)&#123; // 遍历形参列表 for (int i = 0; i &lt; types.length; i++) &#123; //调整格式 if(i!=types.length-1)&#123; System.out.print(types[i].getSimpleName()+&quot;,&quot;); &#125;else&#123; System.out.print(types[i].getSimpleName()); &#125; &#125; &#125; System.out.println(&quot;)&quot;); &#125; Methodjava.lang.reflect.Method 常用方法 int getModifiers();返回由该 method对象表示的字段的Java语言修饰符，作为整数。 Class&lt;?&gt; getReturnType();//返回方法的返回类型 String getName();//方法的名称 Class&lt;?&gt;[] getParameterTypes();//返回方法的参数列表. Object invoke(Object obj,Object… args);//反射调用方法 void setAccessible(boolean on);//调用私有方法需要调用之前来设置可见性 - true 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day16;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Type;/** * @Author liuWenXiu * @Date 2021/8/13 11:00 * @description 反射获取方法的信息 */public class MethodInfoDemo &#123; public static void main(String[] args) &#123; Class&lt;?&gt; c = Point.class; Method[] methods = c.getDeclaredMethods(); if(null!=methods &amp;&amp; methods.length&gt;0)&#123; // 遍历 for (Method method : methods) &#123; // 打印信息 // 修饰符 System.out.print(Modifier.toString(method.getModifiers())+&quot; &quot;); // 返回类型 - 返回类型是Class的 System.out.print(method.getReturnType().getSimpleName()+&quot; &quot;); // 方法名 System.out.print(method.getName()+&quot;(&quot;); // 参数列表 Class&lt;?&gt;[] types = method.getParameterTypes(); if(null!=types &amp;&amp; types.length&gt;0)&#123; // 遍历打印参数列表 for (int i = 0; i &lt;types.length ; i++) &#123; if(i!=types.length-1)&#123; System.out.print(types[i].getSimpleName()+&quot;,&quot;); &#125;else &#123; System.out.print(types[i].getSimpleName()); &#125; &#125; &#125; System.out.println(&quot;)&quot;); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package tech.aistar.day16;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @Author liuWenXiu * @Date 2021/8/13 11:40 * @description 反射调用方法 */public class MethodInvokeDemo &#123; public static void main(String[] args) &#123; // 1.首先构建实例 Class&lt;?&gt; c = Point.class; // 2.通过反射创建对象 try &#123; Point p = (Point) c.newInstance(); // 获取Method // 1. 公有非静态无参无返回值方法 // public void test() Method m1 = c.getDeclaredMethod(&quot;test&quot;); // 调用方法 m1.invoke(p); // 2. 公有非静态有参有返回值方法 // public String test(int) Method m2 = c.getDeclaredMethod(&quot;test&quot;,int.class); String s = (String) m2.invoke(p,10); System.out.println(s); // 3.公有非静态两参无返回值方法 // public void test(int,String) Method m3 = c.getDeclaredMethod(&quot;test&quot;,int.class,String.class); m3.invoke(p,10,&quot;saku&quot;); // 4.私有非静态无参无返回值类型方法 // private void testPrivate() Method m4 = c.getDeclaredMethod(&quot;testPrivate&quot;); m4.setAccessible(true); m4.invoke(p); // 5.公有静态有参无返回值方法 // public static void test(String) Method m5 = c.getDeclaredMethod(&quot;test&quot;,String.class); m5.invoke(null,&quot;sa&quot;); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Modifierjava.lang.reflect 传入一个修饰符对应的数字,来返回修饰的具体的中文的名称 1234567891011121314151617181920212223public static String toString(int mod) &#123; StringBuilder sb = new StringBuilder(); int len; if ((mod &amp; PUBLIC) != 0) sb.append(&quot;public &quot;); if ((mod &amp; PROTECTED) != 0) sb.append(&quot;protected &quot;); if ((mod &amp; PRIVATE) != 0) sb.append(&quot;private &quot;); /* Canonical order */ if ((mod &amp; ABSTRACT) != 0) sb.append(&quot;abstract &quot;); if ((mod &amp; STATIC) != 0) sb.append(&quot;static &quot;); if ((mod &amp; FINAL) != 0) sb.append(&quot;final &quot;); if ((mod &amp; TRANSIENT) != 0) sb.append(&quot;transient &quot;); if ((mod &amp; VOLATILE) != 0) sb.append(&quot;volatile &quot;); if ((mod &amp; SYNCHRONIZED) != 0) sb.append(&quot;synchronized &quot;); if ((mod &amp; NATIVE) != 0) sb.append(&quot;native &quot;); if ((mod &amp; STRICT) != 0) sb.append(&quot;strictfp &quot;); if ((mod &amp; INTERFACE) != 0) sb.append(&quot;interface &quot;); if ((len = sb.length()) &gt; 0) /* trim trailing space */ return sb.toString().substring(0, len-1); return &quot;&quot;;&#125; Properties 属于集合框架的类 - 属于Map[I] java.util.Properties extends java.util.Hashtable[哈希表,多线程安全的] 作用:通过io流把本地的.properties文件读取到内存中,然后映射到Properties对象. Properties对象就是.properties属性文件[encoding=utf-8]在内存中的映射. File - 本地磁盘的文件在java内存中的映射的那个对象. 存储数据的格式是一个键值对的形式 123# key=value - key不要重复username=tompassword=123 根据key来获取value的方法 1String getProperty(String key); Arrayjava.lang.reflect Array类提供静态方法来动态创建和访问Java数组 - 反射技术操作java数组 常用方法 static int getLength(Object array)返回指定数组对象的长度，如 int 。 static Object get(Object array, int index)返回指定数组对象中的索引组件的值。 static Object newInstance(Class&lt;?&gt; componentType, int length)创建具有指定组件类型和长度的新数组。 static void set(Object array, int index, Object value)将指定数组对象的索引组件的值设置为指定的新值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package tech.aistar.day16;import java.lang.reflect.Array;/** * @Author liuWenXiu * @Date 2021/8/13 14:04 * @description 反射操作java数组 */public class ArrayDemo &#123; public static void main(String[] args) &#123; Integer[] arr1 = &#123;1,3,4,5,7&#125;; String[] arr2 = &#123;&quot;saku&quot;,&quot;rose&quot;,&quot;jack&quot;&#125;; // 利用反射技术打印数组元素 printArr(arr1); System.out.println(&quot;-----&quot;); printArr(arr2); &#125; /** * 利用反射技术打印数组元素 * 注意点:Integer[] 和String[] 数组都是继承于Object的,不是继承于Object[] * @param arr */ public static void printArr(Object arr)&#123; // 1.获取数组的长度 int len = Array.getLength(arr); // 2.打印输出 for (int i = 0; i &lt; len; i++) &#123; // 反射技术通过下标去取元素 Object obj = Array.get(arr,i); System.out.println(obj); &#125; &#125; /** * 利用反射技术实现数组的扩容 * @param arr * @return */ public static Object extendsArr(Object arr)&#123; // 创建数组的条件:数组的元素类型,数组的长度 // 1.获取长度 int oldLen = Array.getLength(arr); // 2.获取元素类型 Class&lt;?&gt; c = arr.getClass().getComponentType(); // 3.通过反射创建新的数组 Object newArr = Array.newInstance(c,oldLen*2); // 4.赋值 for (int i = 0; i &lt; oldLen; i++) &#123; Object o = Array.get(arr,i); Array.set(newArr,i,o); &#125; return newArr; &#125;&#125; 面试题 - Arrays和Array的区别拓展应用反射可以破坏双重锁单例1234567891011121314151617181920212223242526272829public class ReflectPoSingleton &#123; public static void main(String[] args) &#123; //1. 获取单例的Class实例 try &#123; Class&lt;?&gt; c = Class.forName(&quot;tech.aistar.design.singleton.version03.Singleton03&quot;); //2. 获取空参构造对应的Constructor实例 Constructor&lt;?&gt; c1 = c.getDeclaredConstructor(); //3. 调用私有的空参构造 c1.setAccessible(true); //4. 调用 Singleton03 s1 = (Singleton03) c1.newInstance(); //反射连续调用俩次私有的空参构造 Singleton03 s2 = (Singleton03) c1.newInstance(); System.out.println(s1 == s2);//false &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反射不可以破坏枚举单例分析-NoSuchMethodException 123//记载类,初始化静态属性,调用空参构造 Class&lt;?&gt; c5 = Class.forName(&quot;tech.aistar.design.singleton.version05.Singleton05&quot;);Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(); 12345678控制台效果比较繁琐的操作的事情,费时费力的事情//不存在一个空参构造的方法让我们去调用java.lang.NoSuchMethodException: tech.aistar.design.singleton.version05.Singleton05.&lt;init&gt;() at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.getDeclaredConstructor(Class.java:2178) at tech.aistar.day16.ReflectPoSingleton.main(ReflectPoSingleton.java:36) 控制台 hello.java 123public enum hello&#123; INSTANCE&#125; 1234确认jdk-bin-jad.exe - 没有下载 - http://varaneckas.com/jad/javac hellojad -s java hello反编译之后出来之后 hello(String.class,int.class) 解决方案1Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,int.class); 分析 - IllegalArgumentException12345678910//加载这个类Class&lt;?&gt; c5 = Class.forName(&quot;tech.aistar.design.singleton.version05.Singleton05&quot;);Constructor&lt;?&gt; cc = c5.getDeclaredConstructor(String.class,int.class);//java.lang.NoSuchMethodException - 抛出一个不存在这个方法cc.setAccessible(true);//Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: // Cannot reflectively create enum objectsSingleton05 s05 = (Singleton05) cc.newInstance(); 原因剖析newInstance方法 1234567891011@CallerSensitivepublic T newInstance(Object ... initargs)throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException&#123;//判断是否为枚举类型,如果是枚举类型直接抛出了这个异常了.if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)&#123; throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);&#125;return inst;&#125; 结论 - 不允许我们用反射的技术来构建枚举类型的实例,底层会进行类型的判断,发现如果是枚举类型对应的class实例,直接抛出异常","categories":[],"tags":[{"name":"反射","slug":"反射","permalink":"http://beautifulboyy/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"枚举类型","slug":"java14","date":"2021-08-10T00:16:32.000Z","updated":"2021-08-10T14:48:44.282Z","comments":true,"path":"2021/08/10/java14/","link":"","permalink":"http://beautifulboyy/2021/08/10/java14/","excerpt":"","text":"枚举类型枚举常量 - 类型安全的常量 - 公共的静态的常量[final]属性 - 不可改变的. jdk5.0开始提供的,以前的作用就是用来替代常量接口的. 常量接口 1234567891011public interface IConsts&#123; // 最全的写法 // 公开的静态的常量属性[接口中只能定义这种类型的属性] public static final int CAR = 1; // 精简的写法 public int CAR = 1; // 最精简的写法 int CAR = 1;&#125; 关键字使用enum关键字来定义一个枚举类型的 switch()中的参数类型可以是byte,short,int,char,enum,String,Byte,Short,Integer 特点 枚举常量在定义时使用,隔开.最后一个枚举常量不需要使用逗号.如果最后一个枚举常量下面还有代码的话,需要使用分号隔开. 允许存在构造方法,但是访问修饰符不能是public或者protected. 枚举类型是不能被实例化的. 枚举类型中可以提供普通属性 每个枚举类型默认都会自动继承java.lang.Enum&lt;E extends Enum&gt; 枚举类型中是可以存在抽象方法的,但是每个枚举常量必须要实现这个抽象方法. 枚举类型不支持再去继承另外一个枚举类型 枚举烈性不支持再去手动继承另外一个类.","categories":[],"tags":[{"name":"枚举","slug":"枚举","permalink":"http://beautifulboyy/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"进程和线程","slug":"java13","date":"2021-08-09T10:17:57.000Z","updated":"2021-08-15T12:23:38.511Z","comments":true,"path":"2021/08/09/java13/","link":"","permalink":"http://beautifulboyy/2021/08/09/java13/","excerpt":"","text":"进程和线程一个程序至少一个进程,一个进程至少一个线程.线程不能单独运行,它一定是运行在进程的内部的. Java程序的启动 启动java程序实际上就是启动JVM[对字节码文件进行逐行翻译 - 翻译成底层的机器语言] 开启一个JVM进程 - jvm.exe[windows中的可执行文件,C语言写的程序字节编译成了.exe可执行文件] 当JVM进程启动之后,同时开启两个线程 - 分别是main主线程以及一个GC线程[后台守护线程] 守护线程 - 如果后台只剩下守护线程在执行的时候,进程就会结束. -&gt; 进程的结束不需要等到守护线程全部执行完才会结束. main线程负责执行main方法中的程序 - main方法中的程序全部执行完之后,main线程运行结束.GC线程负责进行垃圾对象的回收. 进程正在执行中的应用程序: 是并发执行的程序在执行过程中分配和管理资源的基本单位,是一个动态概念. 竞争计算机系统资源的基本单位。 - “多任务操作系统” - “多个进程在**”同时”**在运行” - CPU分配资源 - “分时分片” - CPU调度的基本单位 线程是进程的一个执行单元，是进程内部调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。 一个进程可以拥有多个线程的同一个进程内部的多个线程是可以共享进程资源的 线程的创建[传统方式] 写一个类去继承java.lang.Thread类 - 重写里面的run方法 12345678910111213141516171819202122232425262728public class Thread01 extends Thread&#123; @Override public void run() &#123; // 获取当前线程的名称 System.out.println(Thread.currentThread().getName()); &#125;&#125;class TestThread01&#123; public static void main(String[] args) &#123; // 1.创建线程 Thread t1 = new Thread01(); // 面向父类编程 Thread t2 = new Thread01(); // A.当线程对象一旦被创建成功,线程处于新建状态/瞬态 // 2.设置线程属性 // 设置线程的属性一定是在启动线程之前完成的 t1.setName(&quot;线程01&quot;); t2.setName(&quot;线程02&quot;); // 3.启动线程 t1.start(); t2.start(); // B.一旦调用了start方法,表示线程已经处于就绪态[并不是运行态] // C.运行态 - 程序正常运行的过程 // D.Dead[死亡状态] - 结束状态 - 线程执行结束了 &#125;&#125; 注意要点: 目前接触的线程状态 新建状态/瞬态: 线程对象被创建new成功时的状态 就绪态: 启动线程时调用start方法后的状态 运行态: 程序正常运行的状态 死亡态: 线程执行结束的状态 设置线程的属性一定在启动线程之前完成. 如果没有给线程设置名称,那么系统会自动默认给线程分配名称.格式: Thread-数字 线程的启动调用的是start方法,重写的是run方法.底层是让jvm调度线程,所以run方法是由jvm进行调度的. 并不是先启动哪个线程,就一定会先去执行哪个线程 - 线程的执行是由cpu控制的 - 不是人为进行控制的.所以程序的运行结果不是一定的. 写一个类去实现java.lang.Runnale接口 - 重写里面的run方法 123456789101112131415161718192021222324252627282930313233package tech.aistar.day15.thread01;/** * @Author liuWenXiu * @Date 2021/8/9 18:46 * @description 线程的创建 - 实现Runnable接口 */public class Thread02 implements Runnable&#123; @Override public void run() &#123; // 获取当前线程的名称 System.out.println(Thread.currentThread().getName()); &#125;&#125;class TestThread02&#123; public static void main(String[] args) &#123; // 1.线程的创建 Runnable r = new Thread02(); // 构造:public Thread(Runnable target) Thread t1 = new Thread(r); Thread t2 = new Thread(r); // 2.设置线程属性 t1.setName(&quot;线程-1&quot;); t2.setName(&quot;线程-2&quot;); // 3.启动线程 t1.start(); t2.start(); &#125;&#125; 写一个类去实现java.util.concurrent包下的Callable接口 - 重写里面的call方法. 12345678910111213141516171819202122232425262728293031323334 ~~~ #### Thread和Runnable的区别* Thread:**共享代码,不共享资源** ~~~java public class DiffDemo &#123; public static void main(String[] args) &#123; // 创建线程 Thread t1 = new T1(); Thread t2 = new T1(); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125; &#125; class T1 extends Thread&#123; // 定义一个属性 private Integer tickets = 10; @Override public void run() &#123; for (int i = 10; i &gt; 0 ; i--) &#123; if(tickets &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;正在购票,剩余:&quot;+(--tickets)); &#125; &#125; &#125; &#125; 123456789101112131415161718192021运行结果:线程1正在购票,剩余:9线程2正在购票,剩余:9线程1正在购票,剩余:8线程1正在购票,剩余:7线程1正在购票,剩余:6线程1正在购票,剩余:5线程1正在购票,剩余:4线程1正在购票,剩余:3线程1正在购票,剩余:2线程1正在购票,剩余:1线程1正在购票,剩余:0线程2正在购票,剩余:8线程2正在购票,剩余:7线程2正在购票,剩余:6线程2正在购票,剩余:5线程2正在购票,剩余:4线程2正在购票,剩余:3线程2正在购票,剩余:2线程2正在购票,剩余:1线程2正在购票,剩余:0 线程的调度不是人为控制的,所以每次的结果可能都是不同的.这个运行结果表示每个线程都拥有各自的资源[指的tickets],它不是共享的. 只有当资源设置成静态的时候才能进行资源共享 1private static Integer tickets = 10; 1234567891011运行结果:线程1正在购票,剩余:9线程2正在购票,剩余:8线程1正在购票,剩余:7线程2正在购票,剩余:6线程1正在购票,剩余:5线程2正在购票,剩余:4线程2正在购票,剩余:2线程1正在购票,剩余:3线程2正在购票,剩余:1线程1正在购票,剩余:0 这个结果表示线程拥有的资源是共享的,因为tickets是静态的,静态资源是类加载的时候被分配空间以及初始化,在内存中只有1份.并且这种情况可能仍旧可能出现两个线程在操作同一份tickets的情况,因为没用锁. 123456789101112131415161718class T1 extends Thread&#123; // 定义一个属性 //private static Integer tickets = 10; private Integer tickets = 10; @Override public void run() &#123; for (int i = 10; i &gt; 0 ; i--) &#123; if(tickets &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;正在购票,剩余:&quot;+(--tickets)); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021运行结果:线程2正在购票,剩余:9线程1正在购票,剩余:9线程1正在购票,剩余:8线程2正在购票,剩余:8线程1正在购票,剩余:7线程2正在购票,剩余:7线程2正在购票,剩余:6线程1正在购票,剩余:6线程2正在购票,剩余:5线程1正在购票,剩余:5线程2正在购票,剩余:4线程1正在购票,剩余:4线程2正在购票,剩余:3线程1正在购票,剩余:3线程1正在购票,剩余:2线程2正在购票,剩余:2线程2正在购票,剩余:1线程1正在购票,剩余:1线程2正在购票,剩余:0线程1正在购票,剩余:0 Runnable:共享代码,共享资源 123456789101112131415161718192021222324252627public class DiffDemo &#123; public static void main(String[] args) &#123; // 创建线程 Runnable r = new T2(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125;class T2 implements Runnable&#123; // 定义一个属性 private Integer tickets = 10; @Override public void run() &#123; for (int i = 10; i &gt; 0 ; i--) &#123; if(tickets &gt; 0)&#123; System.out.println(Thread.currentThread().getName()+&quot;正在购票,剩余:&quot;+(--tickets)); &#125; &#125; &#125;&#125; 1234567891011运行结果:线程1正在购票,剩余:9线程1正在购票,剩余:7线程1正在购票,剩余:6线程1正在购票,剩余:5线程1正在购票,剩余:4线程1正在购票,剩余:3线程1正在购票,剩余:2线程2正在购票,剩余:8线程1正在购票,剩余:1线程2正在购票,剩余:0 线程安全的类和线程非安全的类 StringBuilder - 线程非安全的字符串类; StringBuffer - 线程安全的字符串类 ArrayList - 线程非安全的集合; Vector - 线程安全的集合 HashMap - 线程非安全的集合; Hashtable - 线程安全的集合 以上线程安全的类,它们的api方法都使用了synchronized进行修饰.在某个时刻只能由一个线程去访问,其他线程都是出于等待状态. 实例 - 使用类型安全的类1234567891011121314151617181920212223242526272829303132package tech.aistar.day15.thread01;import java.util.Vector;/** * @Author liuWenXiu * @Date 2021/8/9 19:21 * @description 线程安全与线程非安全的类 */public class SafeThreadDemo &#123; public static void main(String[] args) &#123; // 创建线程 Runnable r = new TS(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); &#125;&#125;class TS implements Runnable&#123; //线程安全的类 private Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); @Override public void run() &#123; for (int i = 0; i &lt; 100000 ; i++) &#123; vector.add(i); &#125; System.out.println(&quot;大小:&quot;+Thread.currentThread().getName()+&quot;:&quot;+vector.size()); &#125;&#125; 123456789运行结果:(随机展示了三种情况)大小:Thread-0:175656大小:Thread-1:200000大小:Thread-0:200000大小:Thread-1:200000大小:Thread-1:174163大小:Thread-0:200000 问:是否能理解为什么数值可以不为200000 在实际运行时,很少能有两个结果都为200000的情况.因为实际时很难做到完成的同步,通常都是第一个打印的结果比第二个打印的结果小(但具体是线程1先打印还是线程2先打印也是不一定的).因为在运行的时候,可能会有一个运行的比较快,然后另一个还没运行完. 老师的例子:小红和小蓝有一个共用的工资卡[Vector],到了发工资的时候,两个人同时发工资,小红五千五千地转钱到这个工资卡,而小蓝则是一千一千的转钱到工资卡.转钱的动作是同时进行的,小红在转十万的同时,小蓝也在向工资卡里面转钱. 有三种情况:第一种情况是小红转完了小蓝还没有转完,小红查看时发现卡里有她自己转的十万,还有小蓝转的几万.第二种情况是小红转完的同时小蓝也转完了,他俩查看的时候都发现卡里正好有二十万.第三种情况是小红转的太慢了,小蓝转完了的时候小红还没转完,小蓝查看的时候有他自己转的十万,还有小红转的几万. 最终的结果不是由一个线程在做贡献,两个线程都在做贡献 实例 - 使用类型不安全的类线程非安全的类 - 不要让它设置成一个共享资源 123456789// 线程不安全的类private ArrayList&lt;Integer&gt; vector = new ArrayList&lt;&gt;();@Overridepublic void run() &#123; for (int i = 0; i &lt; 100000 ; i++) &#123; vector.add(i); &#125; System.out.println(&quot;大小:&quot;+Thread.currentThread().getName()+&quot;:&quot;+vector.size());&#125; 123运行结果:Exception in thread &quot;Thread-0&quot; java.lang.ArrayIndexOutOfBoundsException: 163大小:Thread-1:100136 两者之间的对比: Vector类中的add方法是由synchronized修饰的,要么是由线程1执行,要么是由线程2执行,不可能两个线程同时进入到这个add方法. 而ArrayList类中add方法没有由synchronized修饰,两个线程会同时进入到add方法,明明应该是添加了两个元素,但其中一个线程的值会覆盖另外一个线程的值,导致实际上仅仅是向容器中添加了一个元素.并且每次add方法调用时,底层的size就会自增,但是集合中的有效个数却会少掉一个,导致有效数据&lt;size,因此报错. 常用方法 static Thread currentThread(); //返回当前正在执行的线程的引用对象 String getName(); // 返回线程的名称 void start(); // 启动线程,本质上当线程.start时底层会让jvm去启动线程,我们的程序是没有资格和能力去真正的把一个线程给启动起来的. CPU调度JVM线程 - JVM调用线程 void setName(String name); // 给线程设置名称 synchronized关键字 java语言的关键字 可以用来给对象,方法或者代码块加锁 当它锁定一个方法[同步方法]或者一个代码块[同步代码块]的时候,同一时刻最多只有一个线程执行这段代码 当两个并发线程访问同一个对象object中的这个加锁同步代码块时,一个时间内只能有一个线程得到执行,另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块. 基础方法在java中,每个对象有且仅有一个同步锁,并且同步锁是依赖于对象存在的.当我们调用对象的synchronized修饰的同步方法的时候,就是获取了该对象的同步锁. 修饰普通方法 - 对象锁 - 不同的对象拥有独立的”一把锁”,每个对象的”锁”是不冲突的. 修饰静态方法 - 类锁 - 作用于这个类下的所有对象 - 这个类实例化出来的所有对象竞争的是同一把锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day15.syn;/** * @Author liuWenXiu * @Date 2021/8/10 18:46 * @description */public class SynHello extends Thread&#123; @Override public void run() &#123; //add3(); add4(); &#125; public synchronized void add3()&#123; System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125; public static synchronized void add4()&#123; System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125;&#125;class TestSynHello&#123; public static void main(String[] args) &#123; Thread t1 = new SynHello(); Thread t2 = new SynHello(); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; 使用synchronized修饰非静态方法时是对象锁,每个对象拥有独立的锁,而t1和t2是两个不同的对象,所以不影响结果. 使用synchronized修饰静态方法时是类锁,这个类实例化出来的对象t1和t2竞争的都是同一把锁,所以结果改变,真正实现了将add方法锁住. 还有一个点就是对于Runnable而言,即使是使用synchronized修饰非静态方法,但利用Runnable创建线程new的对象是相同的,所以也是能锁住的. 修饰代码块synchronized(this) - 对象锁 修饰代码块synchronized(类名.class) - 类锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.day15.syn;/** * @Author liuWenXiu * @Date 2021/8/10 19:15 * @description synchronized修饰代码块 * 场景:没有必要锁住整个方法,仅仅只需要锁住需要同步的代码即可. */public class SynLockDemo extends Thread&#123; @Override public void run() &#123; add2(); &#125; public void add()&#123; synchronized (SynLockDemo.class)&#123; System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125; &#125; public void add2()&#123; synchronized (this)&#123; System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125; &#125;&#125;class TestSynLockDemo&#123; public static void main(String[] args) &#123; Thread t1 = new SynLockDemo(); Thread t2 = new SynLockDemo(); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125;&#125; 领悟到对象锁和类锁之间的区别就ok啦. 1234567891011121314151617181920212223public class SynLock2Demo implements Runnable&#123; private Object obj = new Object(); // 要记得初始化 @Override public void run() &#123; add(); &#125; private void add() &#123; synchronized (obj)&#123; // 这个obj在这里的含义和this是一样哒 System.out.println(Thread.currentThread().getName()+&quot;:0&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:1&quot;); &#125; &#125;&#125; synchronized特性 原子性 原子性代表一个操作或者多个操作,要么执行全部并且执行的过程中不能被任何因素打断,要么就不执行. 123456比如i++;i+=2;i=i+1;这些操作都不是原子操作,它们要经过[读取,计算,赋值]这三个操作.三个步骤中的任何一个步骤在执行的时候都可能被其他线程打断.int x = 10; // 这就是一个原子操作double x = 3.0d; // 这不是原子操作long x = 20L; // 这也不是原子操作. 可见性 多个线程访问同一个资源的时候,这个资源的状态信息等对其他线程都是可见的. 线程在遇到synchronized时,会清空本地工作内存,然后重新去主存拷贝最新的值. 有序性 在同一个时刻,只能由一个线程进入. 可重入性. 当一个线程申请到锁资源并且执行完毕之后释放,仍然有机会再去申请曾经申请过的锁资源. JMMJMM - Java内存模型(Java memory model) JMM规定所有的变量都存储在主内存中,包括实例变量[类中的非静态属性],静态变量,但是不包括局部变量和方法参数. 每个线程都有自己的工作内存,线程的工作内存保存了该线程用到的变量和主内存的副本拷贝,线程对变量的操作都在工作内存中进行.线程不能直接读写主内存中的变量 不同的线程之间也无法访问对方工作内存中的变量,线程直接变量值的传递需要通过主内存来完成. 原子性实例1234567891011121314151617181920212223public class PlusNoAtomicity implements Runnable&#123; // 定义一个属性 int i = 0; @Override public void run() &#123; for (int j = 0; j &lt; 100 ; j++) &#123; add(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; public void add()&#123; i++; &#125;&#125;class TestPlusNoAtomicity&#123; public static void main(String[] args) &#123; Runnable r = new PlusNoAtomicity(); Thread t1 = new Thread(r); Thread t2 = new Thread(r); t1.start(); t2.start(); &#125;&#125; 12345运行结果:Thread-0:200Thread-1:200因为自加100次很快,两个线程都在一瞬间完成了,导致结果两个都是200. 如果将循环的次数修改为十万次 1234567@Override public void run() &#123; for (int j = 0; j &lt; 10000 ; j++) &#123; add(); &#125; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; 123456运行结果:Thread-0:14203Thread-1:15055Thread-0:13494Thread-1:13695 那么结果为什么不是两个二十万??? 这就要设计到JMM,前面也提到了,JMM规定所有的变量都存储在主内存中,因此i是存储在主内存中的,而每个线程都有自己的工作内存,存储了主内存的副本拷贝 ,对变量的操作都在工作内存中进行.所以在i++进行时,线程将i的副本保存进工作内存,在工作内存中进行自增,然后刷新会主存. 这幅图同样也解释了为什么两个的结果都不是二十万. i++过程 - 多线程安全问题重点前提: 线程是不能够操作对主存中的数据进行直接的操作的,必须是在本地的工作内存中去完成的.完成之后,刷回主存的 线程之间是隔离的.每个线程去执行方法的时候,都会在本地开辟一块区域[栈帧 - 线程栈],每个线程在本地工作内存中 对资源的修改,那么这个资源的信息,状态对其他线程都是不可见的. add方法没有使用synchronized进行修饰,导致在实现的过程中有线程会使用脏数据. 脏数据 - 本地工作内存中的变量的数据和主存中的变量的数据的值已经不一样,违背了”JMM中的缓存一致性”的原则. 1234567891011121314151617i++ 不是一个原子性操作的意思就是在它的中间的过程中,可以被被其他线程打断①T1线程从主存中拷贝变量的副本到本地的工作内存中 - read读取(i=0) =&gt; T1 `T1线程让出了CPU执行权力.T0线程获取执行权力 - 从主存拷贝变量的副本(i=0)` =&gt; T0 `T0线程直接进行了计算,赋值,重新刷回到主存[i=1]` =&gt; T0 `T0线程刷回i到主存之后,此时主存的i=1,T0线程让出cpu执行权` ②在本地的工作内存中对i进行计算,计算完之后,再把自增的数据重新赋值个i =&gt; T1 `T1线程继续执行②,由于之前T1线程并没有执行结束,因此它不会从已经更新的主存中重新去拷贝i的副本` `所以T1线程继续执行的时候,使用的仍然是自己本地工作内存中的那个变量i[read下来的,初始值仍然是0]` `T1线程i = i + 1,刷回到主存[i=1]` `因为线程是隔离的,T1线程它是不知道T0线程对i进行了修改的.`③把最终的本地工作内存中的i的计算结果 - [当前线程执行完毕之后]刷回到主存中[时间是不固定的.但是当前线程执行完毕之后,它肯定会刷回到主存] =&gt; T1 [如果是单线程环境下,当T1线程把最终的结果刷回到主存之后,第二次再次调用add()方法的时候,那么T1线程仍然会再次从主存中 获取变量的副本,重复执行①②③) 隐约的信号:如果线程T1没有执行结束,那么它是不会从主存中重新拉取值的 看到的效果是 - 俩个线程都同时操作了i++,但是主存中的i实际上是只加了1次的结果. 如何解决问题使用synchronized对i++所在的方法进行修饰 当某个对象调用add方法,得到锁资源的时候,会先清空本地工作内存.清空的目的是为了让后面的操作重新从主存中拷贝最新的值. 123public synchronized void add()&#123; i++;&#125; 1234运行结果:Thread-0:18895Thread-1:20000可能线程0走的比较快线程1还没走完线程0就走完了,所以结果不到20000 123运行结果:Thread-0:20000Thread-1:20000 因为add方法进行了同步 - synchronized进行了修饰了.在某个时刻,只能由一个线程[获得锁资源的]进去执行 [读取,计算,赋值] - 三个步骤中.其他线程是不可能介入的.因为没有获取锁资源的线程都在外部进行同步阻塞. 当正在执行的线程释放锁资源之前,它会将本地工作内存中的改变刷回到主存. 工作内存的改变什么时候同步到主存单线程单线程 - 单线程执行方法结束的时候 多线程 线程释放锁资源的时候 线程切换的时候 可见性实例12345678910111213141516171819202122232425262728293031323334/** * @Author liuWenXiu * @Date 2021/8/10 14:12 * @description */public class VisibilityDemo &#123; private int x; // 写 public void writeX()&#123; x = 5; &#125; public void readX()&#123; while (x!=5)&#123; &#125; if(x == 5) System.out.println(&quot;----stopped----&quot;); &#125;&#125;class TestVisibilityDemo&#123; public static void main(String[] args) &#123; VisibilityDemo vb = new VisibilityDemo(); // 创建一个写线程 Thread t1 = new Thread(()-&gt;&#123; vb.writeX(); &#125;); Thread t2 = new Thread(() -&gt; &#123; vb.readX(); &#125;); &#125;&#125; 先写再读12345678t1.start();// 睡一会try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;t2.start(); 12运行结果:----stopped---- 写线程运行时拷贝主存中的x,默认初值为0,然后将x赋值为5,并且刷新回主存,过了一秒以后读线程再运行,拷贝主存中的x,[一秒钟的时间写线程早就运行完了],x的值就为5,所以打印stopped. 先读再写首先我们需要知道一个道理,多个线程访问同一个资源时,这个资源的状态,信息等对于其他线程都是不可见的. 12345678910 //如果先读后写t2.start();//读try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;t1.start();//写 所以在本实例中,如果先启动读线程,读线程拷贝主存中的数据x=0,然后一直在死循环中,等待了一秒钟以后,写线程启动,拷贝主存中的x=0,将其赋值为5并刷新回主存,此时主存中的x=5,但是读线程并不知道,它也不会从主存中重新拷贝值,一直停留在死循环中. 1234567public void readX()&#123; while (x!=5)&#123; System.out.println(&quot;&quot;); &#125; if(x == 5) System.out.println(&quot;----stopped----&quot;);&#125; 123456public void println(String x) &#123; synchronized (this) &#123; print(x); newLine(); &#125; &#125; 如果readX方法如上所示,结果又会不同.因为println方法中使用到了锁,对象在获得锁资源的时候,会先清空本地工作内存,强制从主存中去拷贝已经更新的变量. 所以在这个实例中,每次打印数据后读线程都会清空本地缓存,从主存中拷贝更新后的变量,所以当写线程把主存中变量的值修改以后,读线程能够知道变量已经改变了,从而退出死循环. 如何解决问题 使用synchronized来保证可见性. 使用volatile来修饰实例变量 强制让程序遵守”缓存一致性”协议.如果主存中的变量一旦发生了改变.线程就会强制从主存中重新拷贝这个最新的数据到自己的本地工作内存中去. volatile关键字的作用 保证可见性 volatile是不会造成阻塞的. 禁止指令重排 12345678910Student s = new Student();指令重排 - JVM指令优化之后①给对象分配空间②空间地址立即给s,s保存到栈③对象的初始化volatile Student s = new Student();//禁止指令重排①给对象分配空间③对象的初始化②空间地址立即给s,s保存到栈 不能保证原子性 volatile和synchronized的区别 volatile只能作用于变量,而synchronized可以作用于变量,方法和代码块. 多线程访问volatile不会发射是那个阻塞,而synchronized可能发生阻塞[锁]. volatile能够保证数据的可见性,但不能保证原子性.而synchronized关键字都可以保证 volatile关键字主要解决的是多个线程之间的可见性,而synchronized关键字保证的是多个线程访问资源的同步性. volatile可以禁止jvm指令重排,而synchronized不能. synchronized的底层原理了解即可. 每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。 进程和线程的区别 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。 进程与进程之间是独立的. 同一个进程内部的多个线程是可以共享进程资源的. 资源拥有：同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的。 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。 进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。 -进程重量级的单位(创建,切换,销毁 - 费时) -线程轻量级的单位(创建,切换,销毁 - 比较高) 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 线程是处理器调度的基本单位，但是进程不是。 两者均可并发执行。 一个线程只属于一个进程，但是一个进程可以拥有多个线程，但至少一个线程资源分配给进程，同一进程中所有线程共享该进程的所有资源。 线程生命周期 New：新建状态/瞬态，当线程对象创立后，即进入了新建状态，如：Thread t = new MyThread() Runnable：就绪状态，当调用线程对象的start()方法（t.start()），线程就进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待cpu调度执行，并不是说执行了t.start()此线程立即就会执行 Running：运行状态，当cpu开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。 Blocked：阻塞状态，处于运行状态中的线程由于某种原因，暂时放弃对cpu的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用以进入到运行状态 Dead：死亡状态(结束状态)，线程执行完了或者因异常退出了run()方法，该线程结束生命周期 （1）就绪状态是进入到运行状态的唯一入口（2）线程想要进入到运行状态执行，首先必须处于就绪状态中（3）根据阻塞产生的原因，阻塞状态又可以分为三种： 【1】等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态 【2】同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态 【3】其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态.之前获取键盘输入. 守护线程GC - 运行在后台的 - 负责回收垃圾对象 核心: **线程结束的时候不需要关心后台的守护线程是否也运行结束,线程是不会等后台的守护线程全部运行结束才结束.**当后台只有守护线程在执行的时候,就可以认为线程可以结束了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day15.thread02;/** * @Author liuWenXiu * @Date 2021/8/11 9:12 * @description 守护线程的使用 */public class DaemonDemo &#123; public static void main(String[] args) &#123; Thread t1 = new T1(); Thread t2 = new T2(); // 将打印数字的线程设置成后台守护线程 // 如果后台只剩下守护线程在执行就可以结束了 // 不需要等待所有的守护线程运行结束才结束 t2.setDaemon(true); t1.start(); t2.start(); &#125;&#125;class T1 extends Thread&#123; @Override public void run() &#123; for (int i = 65; i &lt;=90 ; i++) &#123; System.out.println((char)i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class T2 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; Lock - 同步代码Lock是一个接口,下面有很多的实现类. lock需要手动申请锁(对象锁) lock是锁代码块 lock出现异常的时候是不会主动释放资源的. Lock提供的方法 void lock(); // 手动上锁 boolean tryLock(); // 如果获取锁失败,则直接返回false,如果获取锁成功,返回true boolean tryLock(long time,TimeUnit unit); // 如果在尝试获取锁的过程中等待超过了time,就会导致获取锁失败. 面试题 - synchronized和Lock的区别synchronized和lock都属于独占锁 实现层面不一样.synchronized是Java关键字,jvm层面实现加锁和释放锁.Lock是一个接口,在代码层面实现加锁和释放锁. 是否自动释放锁.synchronized在线程代码执行完或出现异常时自动释放锁.Lock不会自动释放锁,需要在finally{}代码块中显式地释放锁. 是否一直等待.synchronized会导致线程拿不到锁一直等等待.Lock可以设置尝试获取锁或者获取锁失败一定时间超时. 获取锁成功是否可知.synchronized无法得知是否获取锁成功.Lock可以通过tryLock获得加锁是否能够. 功能复杂性.synchronized加锁可重入,不可中断,非公平.Lock可重入,可中断,可公平和不公平,细分读写锁提高效率. 读锁 - java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock - 共享锁 - 允许多个线程去读. 写锁 - java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock - 互斥锁 - 一次只能由一个线程去写. 123不可中断synchronized - A线程竞争到锁资源 - 顺利进入同步代码块执行 - 只要A资源不释放这个锁资源.B线程只能在外面等待.可中断Lock -&gt; A线程顺利执行同步代码,B线程如果tryLock方法话,那么B线程不断尝试获取锁资源.如果设置了超时等待时间.B线程等太久.已经超过了设置的时间.B线程将不会再傻乎乎继续等待下去[可中断],B线程就有可能去干别的事情了. 线程的通信重要方法synchronized wait(); Object类中的方法,必须放在循环体和同步代码块中,执行该方法的线程会释放锁,然后进入线程等待池等待再次被唤醒,再放入锁池中竞争同步锁. notify(); Object类中的方法,随机唤醒一个线程. notifyAll(); Object类中的方法,唤醒所有线程 lock Condition new Condition(); 创建等待度列 void await(); 当前线程会进入到阻塞状态,必须要等其他线程唤醒. void signal(); 哪个线程的Contion对象去调用signal()方法,哪个线程就会被唤醒. 生产者消费者问题单个生产者和单个消费者 生产者线程 - 负责生产产品-box[把产品放入到box] 消费者线程 - 负责消费产品-box[从box中去获取产品] 通信的流程 俩条线程并发执行 - 调用的是不同的方法 假设消费者线程先执行 - 直接从box中去获取产品.但是此时此刻box中尚无产品. 消费者线程就需要调用wait方法 - 自己会释放锁资源,消费者线程进入到线程等待池[意味着当前的线程会进入到等待阻塞的状态] -getter方法 假设生产者线程 - setter方法 先执行了.发现box中没有产品的,顺利放入一个产品到box中的.但是放完之后.生产者还是会继续执行.继续执行的时候又会调用 setter方法.这个时候,不能允许生产者线程连续再放 - 就得调用生产者线程的wait方法,同时还需要唤醒消费者线程过来消费. 消费者线程一旦消费成功,它还是会继续执行自己的getter方法.发现box中没有了.回到第2个步骤 demo1 - synchronized实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package tech.aistar.day15.thread02;/** * @Author liuWenXiu * @Date 2021/8/11 10:35 * @description */public class Communication &#123; public static void main(String[] args) &#123; Box box = new Box(); Thread product = new ProductThread(box); Thread customer = new CustomerThread(box); product.setName(&quot;生产者&quot;); customer.setName(&quot;消费者&quot;); product.start(); customer.start(); &#125;&#125;class Box&#123; private int content; //产品 private boolean flag; public synchronized int getContent() &#123; if(!flag)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; flag = false; notifyAll(); return content; &#125; public synchronized void setContent(int content) &#123; if(flag)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; flag = true; this.content = content; notifyAll(); &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125;&#125;class ProductThread extends Thread&#123; private Box box; private int i = 0; //产品 public ProductThread(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; while (true)&#123; System.out.println(Thread.currentThread().getName()+&quot;=&gt;放&quot;+(++i)+&quot;个&quot;); box.setContent(i); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class CustomerThread extends Thread&#123; private Box box; public CustomerThread(Box box) &#123; this.box = box; &#125; @Override public void run() &#123; while (true)&#123; System.out.println(Thread.currentThread().getName()+&quot;=&gt;取&quot;+box.getContent()+&quot;个&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; demo2 - lock实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package tech.aistar.day15.homework_0811;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author liuWenXiu * @Date 2021/8/11 18:44 * @description 生产者消费者问题 - 利用Lock和Condition解决 * 假设盒子能容纳最大产品数量为10,生产者每次随机生产1-10个产品,并且只有在盒子为空时生产者才能生产产品. * 消费者只能在产品数目不为0时进行消费,并且必须有多少买多少. */public class ProducerAndCustomer &#123; private Lock lock = new ReentrantLock(); // 有几个线程就创建几个Condition private Condition producer = lock.newCondition(); private Condition consumer = lock.newCondition(); private int content; //盒子里的产品个数 // 生产方法 public void produce()&#123; while (true)&#123; try &#123; lock.lock(); // 生产者只有在盒子中产品数目等于0时进行生产 // 如果盒子里的数目不为0,那么让生产者进入阻塞状态 if(content!=0)&#123; producer.await(); &#125; // 否则进行产品的生产 content = (int) (Math.random()*10 + 1); System.out.println(&quot;生产者生产了&quot;+content+&quot;个产品&quot;); Thread.sleep(1000); // 唤醒消费者线程 consumer.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; // 消费方法 public void consume()&#123; while (true)&#123; try &#123; lock.lock(); // 如果盒子里的数目小于等于0表示盒子空了,消费者不能再消费啦 if(content==0)&#123; consumer.await(); &#125; // 消费 System.out.println(&quot;消费者消费了&quot;+content+&quot;个产品&quot;); content = 0; Thread.sleep(1000); // 唤醒生产者线程 producer.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125;class TestProducerAndCustomer&#123; public static void main(String[] args) &#123; ProducerAndCustomer pc = new ProducerAndCustomer(); Thread t1 = new Thread(()-&gt;&#123; pc.produce(); &#125;); Thread t2 = new Thread(()-&gt;&#123; pc.consume(); &#125;); t1.setName(&quot;生产者&quot;); t2.setName(&quot;消费者&quot;); t1.start(); t2.start(); &#125;&#125; 三个线程循环打印abc ABC 123打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package tech.aistar.day15.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author liuWenXiu * @Date 2021/8/11 14:43 * @description * 同程公司笔试题 - 循环打印abc ABC 123 abc ABC 123 * * * * 打印小写字母abc的线程,打印大写字母ABC线程,打印数字123的线程 * * * * 使用Lock中的同步队列 - 解决方案 - **唤醒指定的等待队列上的某个线程.** */public class CommunicationLockDemo &#123; private Lock lock = new ReentrantLock(); // 有几个线程就创建几个队列 // 打印小写字母的队列 private Condition c1 = lock.newCondition(); // 打印大写字母的队列 private Condition c2 = lock.newCondition(); // 打印数字的队列 private Condition c3 = lock.newCondition(); // 定义一个标记 private int count = 0; // 打印小写字母的方法 public void printLower()&#123; while (true)&#123; try &#123; lock.lock(); // 首先判断状态 // 如果count=0则运行,否则进入阻塞状态 if(count!=0)&#123; c1.await(); &#125; // 否则运行 打印小写的abc System.out.print(&quot;abc&quot;); // 打完后等一秒 Thread.sleep(1000); // 修改count的值 count = 1; // 唤醒打印大写字母的线程 c2.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭锁资源 lock.unlock(); &#125; &#125; &#125; // 打印大写字母的方法 public void printUpper()&#123; while (true)&#123; try &#123; // 首先判断 count = 1时打印大写字母 lock.lock(); if(count!=1)&#123; c2.await(); &#125; // 否则打印 System.out.print(&quot;ABC&quot;); Thread.sleep(1000); count = 2; c3.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public void printNum()&#123; while (true)&#123; try &#123; lock.lock(); if(count!=2)&#123; c3.await(); &#125; System.out.print(123); Thread.sleep(1000); count = 0; c1.signal(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; CommunicationLockDemo demo = new CommunicationLockDemo(); Thread t1 = new Thread(()-&gt;&#123; demo.printLower(); &#125;); Thread t2 = new Thread(()-&gt;&#123; demo.printUpper(); &#125;); Thread t3 = new Thread(()-&gt;&#123; demo.printNum(); &#125;); t1.start(); t2.start(); t3.start(); &#125;&#125; 面试题 - 常用方法区别wait方法和sleep方法的区别 wait方法一定是出现字synchronized同步代码内部的,而sleep是可以放在同步代码中也可以放在不是同步代码的代码中. 执行wait方法的线程会释放锁并释放cpu,而执行sleep方法只会释放cpu不会释放锁. - 核心区别 sleep方法线程会自动进入到其他阻塞状态,一旦睡眠结束,会自动从阻塞状态恢复到可就绪态,等待cpu的到来,然后到运行态.wait方法线程会自动进入到等待阻塞状态,自己不会主动醒过来,必须是其他线程调用notify或者notifyAll,然后会进入到锁定状态,再次尝试去获取锁. 官方答案 sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。 yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。 wait：Object类的方法(notify()、notifyAll() 也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁 join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 join方法的实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package tech.aistar.day15.thread02;/** * @Author liuWenXiu * @Date 2021/8/11 9:33 * @description */public class JoinDemo &#123; public static void main(String[] args) &#123; Thread mother = new Mother(); mother.start(); &#125;&#125;class Mother extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;妈妈在烧饭&quot;); System.out.println(&quot;妈妈发现酱油没啦..&quot;); System.out.println(&quot;妈妈让儿子去打酱油&quot;); Thread son = new Son(); son.start(); try &#123; son.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;妈妈继续烧饭!!&quot;); &#125;&#125;class Son extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;儿子去打酱油啦&quot;); for (int i = 3; i &gt; 0 ; i--) &#123; System.out.println(&quot;还有&quot;+i+&quot;分钟儿子就回来啦&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;儿子回来啦&quot;); &#125;&#125; 死锁“哲学家就餐问题” 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程. 死锁产生的条件 互斥条件: 指进程对所分配到的资源进行排他性使用,即在一段时间内某资源只由一个进程占用.如果此时还有其他进程请求资源,则请求者只能等待,直到占有资源的进程使用完毕释放. 请求和保护条件: 指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已经被其他进程占有,此时请求进程阻塞,但又对自己已经获得的其他资源保持不放. 不剥夺条件: 指进程已获得的资源,在未使用完之前,不能被剥夺,只能使用完时自己释放. 环路等待条件: 发生死锁时,必然存在一个进程–资源的环形链,即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 只要打破四个条件的一个,就可以防止死锁. 死锁是不可避免,但是需要写程序的破坏四个条件中的一个. 静态域容易产生死锁. 四种常见的线程池线程池的返回值ExecutorService简介 ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程 Executors.newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务 Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。 Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行 Executors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。","categories":[],"tags":[{"name":"进程","slug":"进程","permalink":"http://beautifulboyy/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://beautifulboyy/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"泛型","slug":"java12","date":"2021-08-06T08:11:53.000Z","updated":"2021-08-09T14:49:02.992Z","comments":true,"path":"2021/08/06/java12/","link":"","permalink":"http://beautifulboyy/2021/08/06/java12/","excerpt":"","text":"泛型Generic定义 java在1.5之后加入了泛型的概念.泛型,即”参数化类型”. 泛型的本质是为了参数化类型(将类型参数化传递),在不创建新的类型的情况下,通过泛型指定的不同类型来控制形参具体限制的类型. 也就是说在泛型使用过程中,操作的数据类型被指定为一个参数. 这种参数类型可以用在类,接口和方法中,分别被称为泛型类,泛型接口,泛型方法. 泛型只能是对象类型.可以是自定义对象类型比如User,Student等,也可以是内置对象类型如String,Integer,Character等[一定是包装类型]. 泛型符号 符号 含义 E 元素 K,V 键值对 N 数字 T 类型 ? 通配符 集合为例子理解泛型的好处123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day14;import java.util.ArrayList;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/7 13:57 * @description 泛型的好处 */public class GenericDemo &#123; public static void main(String[] args) &#123; // 1. jdk5.0之前创建集合的方式 List list = new ArrayList(); // 1.1元素的添加 // 集合可以添加任意对象类型元素 list.add(Object o) list.add(10); // 之类添加的不是基本类型10,而是java.lang.Integer list.add(&quot;qwq&quot;); list.add(2000L); // 1.2元素的获取 // 获取元素时必须要进行类型的强制转换 list.get(index)返回类型为Object // 过程中就有可能转换失败,java.lang.ClassCastException类型转换异常 //String temp = (String) list.get(0); //error Integer i = (Integer) list.get(0); String s = (String) list.get(1); // 2.jdk5.0~jdk7.0创建集合的方法 List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); // 2.1元素的添加 // 集合只能添加指定对象类型元素 list.add(Integer i) list1.add(10); list1.add(20); // 2.2元素的获取 // 不需要进行强制类型转换 list.get(index)返回类型为Integer Integer i1 = list1.get(0); // 3.jdk7.0以后创建集合的方式 - 与第二种方式很相近 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list2.add(&quot;ok&quot;); list2.add(&quot;java&quot;); String s1 = list2.get(0); &#125;&#125; jdk5.0之前:集合可以添加任意对象类型元素 [jdk5.0,jkd7.0):采用了类型安全的集合框架,在编译期间确定了集合中添加的数据类型,在添加元素时只能添加指定类型的元素,获取元素时也不需要进行强制类型转换 jdk7.0:泛型只有在编译期间的概念,在运行期间将会被擦除.所以删除了ArrayList尖括号的类型. 泛型的好处 加入了泛型之后,可以保证代码的健壮性 加入了泛型之后,取值时不需要进行强制类型转换 加入了泛型之后,代码变得更加简洁. 泛型没有多态12345多态的语法 - 多态的引用面向父类编程/面向借口哦编程编译时类型 对象名 = new 运行时类型();父类 对象 = new 子类();接口 对象 = new 实现类(); Class实例12345Book book1 = new Book();System.out.println(book1.getClass()); //class tech.aistar.review.BookBook book2 = new Book();System.out.println(book2.getClass()); //class tech.aistar.review.BookSystem.out.println(book1.getClass() == book2.getClass()); //true 一个类无论被实例化多少次,它在JVM中的Class对象/实例永远都只有一个. 12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day14;import tech.aistar.review.Book;import java.util.ArrayList;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/7 14:13 * @description 泛型只有编译期间的概念, 在运行期间将会被擦除. * * */public class GenericRuntimeDemo &#123; public static void main(String[] args) &#123; // 面向父类编程 // java.lang.Integer extends java.lang.Number // java.lang.Long extends java.lang.Number Number n1 = new Integer(10); Number n2 = new Long(20L); // jdk5.0~jdk7.0 //List&lt;Number&gt; list = new ArrayList&lt;Integer&gt;(); //error // 这样写编译会报错,说明泛型是没有多态的,不能用父类去接子类. // 原因:泛型只有编译期间的概念,在运行期间将会被擦除 List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); List&lt;Long&gt; list2 = new ArrayList&lt;Long&gt;(); // 获取对象的运行时类型 - Class实例 Class&lt;?&gt; c1 = list1.getClass(); Class&lt;?&gt; c2 = list2.getClass(); System.out.println(c1 == c2); //true System.out.println(c1); //class java.util.ArrayList System.out.println(c2); //class java.util.ArrayList // 由此可见,获取运行时类型始终都是ArrayList,和&lt;Integer&gt;,&lt;Long&gt;是无关的. // 所以泛型仅仅是在编译期间有效,在运行期间是无效的. &#125;&#125; 泛型只有编译期间的概念 - 泛型仅仅是在编译期间是有效的. 在编译期间一旦确定了泛型,那么在编译期间就只能向这个容器中添加对应类型的数据,否则编译报错. 运行期间将会被擦除 - 泛型是不存在运行时类型的. 泛型通配符 ? extends T - 只能是T类型或者T类型的子类 - 指定类型的上限[常用] ? super T - 只能是T类型或者T类型的父类 - 指定类型的下限 小测试1234567891011List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();list1.add(1);list1.add(2);list1.add(3);list1.add(4);List&lt;Long&gt; list2 = new ArrayList&lt;&gt;();list2.add(10L);list2.add(20L);list2.add(30L);list2.add(40L); 定义一个方法,打印上面两种集合 1234567public static void print(List&lt;? extends Number&gt; list)&#123; Iterator&lt;? extends Number&gt; iter = list.iterator(); while(iter.hasNext())&#123; Number n = iter.next(); System.out.println(n); &#125;&#125; 注意一下:自己写的时候hasNext忘记加括号了,这是调用的方法,要记得! 泛型类定义类的时候,给定一个泛型,真正使用的时候再确定具体的类型. 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.day14.generic;/** * @Author liuWenXiu * @Date 2021/8/9 21:10 * @description 泛型类 */public class GenericClassDemo&lt;T&gt; &#123; // 定义一个属性 private T type; public GenericClassDemo() &#123; &#125; // 将类型参数化传递 public GenericClassDemo(T type) &#123; this.type = type; &#125; // 泛型方法 public T getType() &#123; return type; &#125; public void setType(T type) &#123; this.type = type; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;GenericClassDemo&#123;&quot;); sb.append(&quot;type=&quot;).append(type); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 1234567891011public class TestGenericClassDemo &#123; public static void main(String[] args) &#123; GenericClassDemo&lt;String&gt; g1 = new GenericClassDemo&lt;&gt;(&quot;haya&quot;); System.out.println(g1); GenericClassDemo&lt;Integer&gt; g2 = new GenericClassDemo&lt;&gt;(); g2.setType(12); System.out.println(g2); &#125;&#125; 泛型类的继承 子类继承父类时不指定具体的类型 子类继承父类时指定具体的类型 12345678910111213141516// 泛型父类class Sup&lt;T&gt;&#123; &#125;// 不指定具体类型的子类class Sub01&lt;T&gt; extends Sup&lt;T&gt;&#123; &#125;// 指定具体类型的子类class Sub02&lt;Product&gt; extends Sup&lt;Product&gt;&#123; &#125;// 指定具体类型的子类可以省略前面的&lt;&gt;class Sub02 extends Sup&lt;Product&gt;&#123; &#125; 泛型方法如果泛型加在类上面,对整个类内部有泛型的地方都会有影响. 可能某个类中就那么几个方法需要使用到泛型,没有必要定义泛型类,只需要定义泛型方法即可 如果很多个方法都使用到了泛型,就有必要定义一个泛型类. 1234567891011121314151617181920212223242526272829303132package tech.aistar.day14.generic;/** * @Author liuWenXiu * @Date 2021/8/9 21:16 * @description 泛型方法 */public class GenericMethodDemo &#123; // 非静态方法 - 无返回类型 public &lt;T&gt; void test01(T t)&#123; System.out.println(&quot;test01...&quot;+t); &#125; // 非静态方法 - 有返回类型 public &lt;T&gt; T test02(T t)&#123; System.out.println(&quot;test02...&quot; + t); return t; &#125; // 静态方法 - 无返回类型 public static&lt;T&gt; void test03(T t)&#123; System.out.println(&quot;test03...&quot;+t); &#125; // 静态方法 - 有返回类型 public static &lt;T&gt; T test04(T t)&#123; System.out.println(&quot;test04...&quot;+t); return t; &#125;&#125; 12345678910111213141516171819package tech.aistar.day14.generic;/** * @Author liuWenXiu * @Date 2021/8/9 21:17 * @description 泛型是类型安全的 */public class TestGenericMethodDemo &#123; public static void main(String[] args) &#123; // 根据传入的实参 确定方法的参数T GenericMethodDemo gm = new GenericMethodDemo(); gm.test01(&quot;ww&quot;); Integer i = gm.test02(12); // 这里已经知道了返回类型是Integer GenericMethodDemo.test03(&quot;hahaha&quot;); String s = GenericMethodDemo.test04(&quot;ok&quot;); &#125;&#125; 泛型的应用1234567ObjectInputStream/ObjectOuputStream - 操作对象类型的字节文件输入流和对象类型的文件字节输出流 Object in.readObject()/out.writeObject(Object obj);Jdk没有对readObject方法进行优化,每次调用完之后,进行强制类型的转换操作的. 思考 - 无论是保存/读取User对象或者Book对象 - 用一个方法去实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344package tech.aistar.util;import java.io.*;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/9 21:25 * @description */public class IOUtil &#123; /** * 利用泛型实现 保存任意对象 * @param list 保存的对象集合 * @param &lt;T&gt; 数据类型 * @param path 保存的地址 */ public static &lt;T&gt; void writeList(List&lt;T&gt; list,String path)&#123; try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; // 写入 out.writeObject(list); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static &lt;T&gt; List&lt;T&gt; readList(String path)&#123; List&lt;T&gt; list = null; try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) &#123; list = (List&lt;T&gt;) in.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return list; &#125;&#125; 1234567891011121314151617181920212223242526272829package tech.aistar.day14.generic;import jdk.internal.org.objectweb.asm.tree.InnerClassNode;import tech.aistar.day13.Book;import tech.aistar.util.IOUtil;import java.util.ArrayList;import java.util.List;/** * @Author liuWenXiu * @Date 2021/8/9 21:31 * @description 测试IOUtil中的方法 */public class TestIOUtil &#123; public static void main(String[] args) &#123; String path = &quot;src/tech/aistar/day14/generic/temp.txt&quot;; List&lt;Book&gt; books = new ArrayList&lt;&gt;(); books.add(new Book(1,&quot;1001&quot;,&quot;java&quot;,1000.d)); books.add(new Book(2,&quot;1002&quot;,&quot;php&quot;,200.d)); books.add(new Book(3,&quot;1003&quot;,&quot;c#&quot;,300.d)); List&lt;Book&gt; newList = IOUtil.readList(path); for (Book book : newList) &#123; System.out.println(book); &#125; &#125;&#125; 如果List newList = IOUtil.readList(path);这里的Book写成其他类型,就会报类型转换异常:java.lang.ClassCastException. 泛型的具体应用场景:在接口的制定中,很多接口具有相同的或者相似的功能. 12345678910111213141516171819//dao层接口 - data access object - 数据访问对象层 - 数据持久层//这一层专门和数据库[crud增删改查操作][文件_IO流操作]打交道// 老师的业务接口public interface ITeacherDao&#123; // 保存教师 void save(Teacher teacher);&#125;// 学生的业务接口public interface IStudentDao&#123; void save(Student student);&#125;//再去写俩个具体的实现类分别是TeacherDaoImpl.java以及StudentDaoImpl.java//这俩个实现类中 - 具体的代码,现阶段知识点 - 把单个java对象保存到文件中[IO流技术].//未来 - 肯定是要把java对象保存到db中 - 持久化的操作[java内存中的对象保存到DB中]//关于dao层 - java如何操作数据库 - 原生技术jdbc,dao层框架 - Hibernate框架以及mybatis框架//比如现在选取的是所谓的Hibernate框架 Hibernate框架把java的内存对象保存到DB中 123session.beginTransaction();//开启一个事务session.save(user);//具体的调用的是这个框架中的保存方法session.getTransaction().commit();//提交一个事务 TeacherDaoImpl伪代码 12345678public class TeacherDaoImpl implements ITeacherDao&#123; @Override public void save(Teacher teacher)&#123; session.beginTransaction();//开启一个事务 session.save(teacher);//具体的调用的是这个框架中的保存方法 session.getTransaction().commit();//提交一个事务 &#125;&#125; StudentDaoImpl伪代码 12345678public class StudentDaoImpl implements IStudentDao&#123; @Override public void save(Student student)&#123; session.beginTransaction();//开启一个事务 session.save(student);//具体的调用的是这个框架中的保存方法 session.getTransaction().commit();//提交一个事务 &#125;&#125; 发现在未来使用框架的时候,会发现很多步骤都是重复的.可能就涉及到具体的对象那一行的代码才会不一样而已. 关键代码:session.save(具体的java对象) 所以考虑抽象出一个顶级的业务类接口 - IBaseDao 12345public interface IBaseDao&lt;T&gt; &#123; //顶级的业务接口中应该存储的就是各个子接口中共性的方法 //这些方法都有共同点 - 大部分的代码是一样的,仅仅是操作的对象不一样而已. void save(T t);&#125; 实现类BaseDaoImpl.java 12345678910public class BaseDaoImpl&lt;T&gt; implements IBaseDao&lt;T&gt; &#123; @Override public void save(T t) &#123;// session.beginTransaction();//开启一个事务// session.save(t);//具体的调用的是这个框架中的保存方法// session.getTransaction().commit();//提交一个事务 System.out.println(t); &#125;&#125; IStudentDao继承了顶级的业务接口 123public interface IStudentDao extends IBaseDao&lt;Student&gt;&#123; void taoKe();//子接口中特有的方法&#125; ITeacherDao继承了顶级的业务接口 1234public interface ITeacherDao extends IBaseDao&lt;Teacher&gt;&#123; void buKe();//子接口中特有的方法&#125; 两个具体的实现类,需要继承顶级的BaseImpl.java,因为save方法已经实现好了,不需要再次实现. 12345678910111213public class StudentDaoImpl extends BaseDaoImpl&lt;Student&gt; implements IStudentDao&#123; @Override public void taoKe() &#123; System.out.println(&quot;逃课...&quot;); &#125;&#125;public class TeacherDaoImpl extends BaseDaoImpl&lt;Teacher&gt; implements ITeacherDao&#123; @Override public void buKe() &#123; System.out.println(&quot;补课...&quot;); &#125;&#125; 单元测试 123456789101112public class TestBase &#123; public static void main(String[] args) &#123; Student s = new Student(1,&quot;tom&quot;); IStudentDao studentDao = new StudentDaoImpl(); studentDao.save(s); Teacher teacher = new Teacher(1,&quot;仓考试&quot;); ITeacherDao teacherDao = new TeacherDaoImpl(); teacherDao.save(teacher); &#125;&#125;","categories":[],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://beautifulboyy/tags/%E6%B3%9B%E5%9E%8B/"}]},{"title":"输入输出流","slug":"java11","date":"2021-08-05T00:31:12.000Z","updated":"2021-08-06T12:34:02.251Z","comments":true,"path":"2021/08/05/java11/","link":"","permalink":"http://beautifulboyy/2021/08/05/java11/","excerpt":"","text":"输入输出流Filejava.io.File[C] - File包含文件或者文件夹[目录directory] 作用:用来操作File本身的元信息,比如支持File的创建,删除,获取File的名称,获取File的路径信息,但它并不支持文件里面的内容的读写操作.[文件内容的读写操作是交给IO流去实现的] 支持本地File以及远程File的操作 File对象 - Java程序将磁盘上的文件加载内存中然后映射到File对象上 - File是内存中的磁盘上的映射. 构造方法 File(String path); // 利用一个路径来构建一个File实例,这个路径可以是文件的路径,也可以是文件夹的路径 路径分为相对路径和绝对路径: 绝对路径 - windows操作系统是以盘符号开头的路径,Linux/max以/开头的路径 相对路径 - 不是以盘符号或者/开头的路径 File(File parent, String child); //child是文件名 常用方法 boolean createNewFile(); // 创建一个文件[该方法需要抓取异常] String getAbsolutePath(); // 获取该File的绝对路径 String getName(); // 获取File的名称 String getParent(); // 获取该File的父目录的路径[如果创建时是绝对路径,那么就是绝对路径,如果是相对路径,那么就是相对路径] String getPath(); // 获取File的路径[如果创建时是绝对路径,那么就是绝对路径,如果是相对路径,那么就是相对路径] boolean exists(); // 判断File是否存在 boolean delete(); // 删除文件或者文件夹 6-1. 文件是否可以直接被删除 6-1-1. 如果是空目录 - 直接删除 6-1-2 如果是非空目录 - 删除失败 - [可以通过递归算法来实现删除非空目录] boolean mkdir(); // 创建单层次的目录,一次只能创建一个目录 boolean mkdirs(); // 既可以创建单层次的目录,又可以同时创建多个不存在的目录 boolean isFile(); // 判断File实例是否为文件实例 boolean isDirectory(); // 判断File实例是否为文件夹实例 String[] list(); // 返回的是File的名称,返回的是传入的路径下的第一层内容 File[] listFiles(); // 返回第一层的File实例 File[] listFiles(FilenameFilter filter); // 找到指定后缀/前缀满足条件的这么一个File实例 创建文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package tech.aistar.day13;import java.io.File;import java.io.IOException;/** * @Author liuWenXiu * @Date 2021/8/5 16:33 * @description FileDemo */public class FileDemo &#123; public static void main(String[] args) &#123; createNewFile(&quot;src/tech/aistar/day13/temp.txt&quot;); &#125; /** * 创建新的文件 * @param path */ public static void createNewFile(String path)&#123; // 1. 构建File实例 File f = new File(path); // 2.判断f是否存在 if(f.exists())&#123; // 如果存在则打印提示并退出方法 System.out.println(f+&quot;已经存在啦&quot;); return; &#125; // 3.实现新的创建 // 调用createNewFile方法,需要抓取异常,并且调用该方法会返回一个布尔类型的值,表示是否创建成功 try &#123; if(f.createNewFile())&#123; // 1. 获取文件名称 System.out.println(&quot;文件名称:&quot;+f.getName()); // 2.获取名称绝对路径 System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath()); // 3.获取创建时的路径 System.out.println(&quot;创建时路径:&quot;+f.getPath()); // 4.获取文件的父目录 System.out.println(&quot;文件父目录:&quot;+f.getParent()); // 5.获取文件 System.out.println(&quot;文件:&quot;+f); &#125;else &#123; System.out.println(&quot;创建失败&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456结果:文件名称:temp.txt文件绝对路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\temp.txt创建时路径:src\\tech\\aistar\\day13\\temp.txt文件父目录:src\\tech\\aistar\\day13文件:src\\tech\\aistar\\day13\\temp.txt 123public static void main(String[] args) &#123; createNewFile(&quot;E:\\\\cxstudy\\\\workspace\\\\j03_student02\\\\src\\\\tech\\\\aistar\\\\day13\\\\qaq.txt&quot;);&#125; 123456结果:文件名称:qaq.txt文件绝对路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt创建时路径:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt文件父目录:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13文件:E:\\cxstudy\\workspace\\j03_student02\\src\\tech\\aistar\\day13\\qaq.txt 删除文件/文件夹1234567891011121314151617181920public static void deleteFileOrFolder(String path)&#123; // 1.构建File实例 File f = new File(path); // 2.判断file是否存在 if(!f.exists())&#123; // 如果不存在则打印提示不存在 System.out.println(f+&quot;不存在!&quot;); return; &#125; // 3.删除文件 // 如果是空目录是可以直接删除的,如果是费空目录,则删除失败 // 调用delete方法 同样会返回一个布尔类型的结果 if(f.delete())&#123; System.out.println(f+&quot;删除成功!&quot;); &#125;else &#123; System.out.println(f+&quot;删除失败!&quot;); &#125;&#125; 创建文件夹版本一1234567891011121314151617public static void createFolder(String path)&#123; // 1.构建file实例 File f = new File(path); // 2.判断文件夹是否存在 if(f.exists())&#123; // 如果存在则打印实体并返回 System.out.println(f+&quot;已经存在啦!&quot;); return; &#125; // 3.创建文件夹 // 调用mkdir方法,返回一个布尔类型的值 if(f.mkdir())&#123; System.out.println(f+&quot;创建成功!&quot;); &#125;else&#123; System.out.println(f+&quot;创建失败&quot;); &#125;&#125; 版本二123456789101112131415public static void createFolder2(String path)&#123; // 1.构建File实例 File f = new File(path); // 2.判断是否存在 if(f.exists())&#123; System.out.println(f+&quot;已经存在啦&quot;); return; &#125; // 3.创建 if(f.mkdirs())&#123; System.out.println(f+&quot;创建成功&quot;); &#125;else&#123; System.out.println(f+&quot;创建失败&quot;); &#125;&#125; mkdir和mkdirs之间的区别是,mkdir只能创建一个目录,而mkdirs可以创建嵌套的目录. list方法 - 返回文件名称123456789101112131415161718public static void lists(String path)&#123; // 1.构建实例 File file = new File(path); // 2.判断是否存在 if(!file.exists())&#123; // 如果不存在则打印提示并返回 System.out.println(file+&quot;不存在!&quot;); return; &#125; // 3.list获取名称 String[] infos = file.list(); if(null!=infos &amp;&amp; infos.length&gt;0)&#123; // 需要进行判断,因为不能确保这个有数据 for (String s : infos) &#123; System.out.println(s); &#125; &#125;&#125; listFiles - 返回File对象12345678910111213141516File[] files = file.listFiles();if(null!= files &amp;&amp; files.length&gt;0)&#123; // 确保数据的有效性 // 遍历输出 for (File file1 : files) &#123; // System.out.println(file1); if(file1.isDirectory())&#123; // 如果是目录则输出绝对路径 System.out.println(file1.getAbsolutePath()); &#125; if(file1.isFile())&#123; // 如果是文件则输出文件名 System.out.println(file1.getName()); &#125; &#125;&#125; listFiles(FilenameFilter filter) - 返回指定后缀的文件步骤: 首先创建一个类实现FilenameFilter接口,该接口是一个函数式接口. 12345678910111213141516171819public class SuffixFilenameFilter implements FilenameFilter &#123; private String suffix; public SuffixFilenameFilter(String suffix) &#123; this.suffix = suffix; &#125; @Override public boolean accept(File dir, String name) &#123; // 在什么情况下返回true什么情况下返回false // dir表示的是父类的绝对路径 // name表示的是文件名 //System.out.println(dir+&quot;:&quot;+name); if (name.endsWith(suffix)) return true; return false; &#125;&#125; 面向接口编程,形参是FilenameFilter可以传入它的实现类 12345File[] files = f.listFiles(new SuffixFilenameFilter(&quot;.txt&quot;));// 获取以.txt为结尾的文件并打印其名称for (File file : files) &#123; System.out.println(file.getName());&#125; 练习 传入一个目录,输出这个目录下的所有内容.如果是文件,直接输出名称.如果是文件夹,输出绝对路径 12345678910111213141516171819202122232425262728/** * 递归获取某个路径下的所有文件 * @param path */public static void listAllFiles(String path)&#123; // 1.创建实例 File f = new File(path); // 指定出口 - 递归的出口是如果该路径是文件,则打印文件名称并返回 if(f.isFile())&#123; System.out.println(f.getName()); return; &#125; // 如果不是文件,那么就是目录,需要获取该目录的所有Files File[] files = f.listFiles(); // 判断合法性 if(null != files &amp;&amp; files.length&gt;0)&#123; // 遍历files,判断如果是文件则打印文件名,如果是目录则打印目录绝对路径并且递归调用 for (File file : files) &#123; if(file.isFile())&#123; System.out.println(file.getName()); &#125;else if(file.isDirectory())&#123; System.out.println(file.getAbsolutePath()); listAllFiles(file.getAbsolutePath()); &#125; &#125; &#125;&#125; 删除一个非空目录[递归] IO流流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式[数据在传输之前,需要进行转换,转换成无结构的字节/字符序列]进行有序的输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入(Input)输出(Output) 流可以想象成是数据传输的管道. 磁盘中数据加载/读入到内存中 - 输入 java内存中数据写出到磁盘中 - 输出 流的分类 按照流的方向 - 输入流和输出流 按照流的读取单位 字节流 - 按照单个字节单个字节进行读写文本文件或者二进制文件 字符流 - 按照单个字符进行读写,只能操作文本字符文件 按照流的功能 节点流 - 又称为基础流,具备真正操作文件的能力 拓展流 - 又称为过滤流或包装流,拓展流只能让流的功能更加强大而已,拓展流脱离了节点流的话,是不允许的.拓展流的使用必须要建立在节点流的基础之上. 字节流字节输入流java.io.InputStream[C] - 字符输入流的顶级的抽象的父类 java.io.FileInputStream[C] - 文件字节输入流,操作文件的读操作. - 典型的节点流 java.io.ObjectInputStream[C] - 操作对象类型的字节输入流 - 典型的包装流 java.io.FilterInputStream[C] - 过滤流 java.io.BufferedInputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DateInputStream[C] - 操作基本数据类型的字节输入流 InputStream常用方法 void close(); // 关闭流,流本身就是一个对象[占内存 - 昂贵的资源] abstract int read(); // 单个字节单个字节的读取,如果读不到,返回-1 int read(byte[] b); // 从输入流读取一些字节数,并将它们存储到缓冲区b 字节输出流java.io.OutputStream[C] - 字节输出流的顶级的抽象父类 java.io.FileOutputStream[C] - 文件字节输出流,操作文件的写操作 - 典型的节点流 java.io.ObjectOutputStream[C] - 操作对象类型的字节输出流 - 典型的包装流 java.io.FilterOutputStream[C] - 过滤流 java.io.BufferedOutputStream[C] - 带缓存功能的流 - 缓冲流 java.io.DataOutputStream[C] - 操作基本数据类型的字节输出流 OutputStream常用方法 void close(); //关闭流 abstract void write(int b); // 将制定的字节写入此输出流 void write(byte[] b,int off,int len); IO流的编程步骤 确定流 - 选什么流 确定源头和目标 - 从哪里读,写到哪里去 循环读取,循环写出 - while 关闭流 文件的拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/6 17:31 * @description IO - 读取文件中的内容 * 文件的拷贝 */public class HelloIO &#123; public static void main(String[] args) &#123; /* IO流步骤: 1. 选择流 2. 确定源头和目标 3. 循环读取/循环写出 4. 关闭流 */ // 面向父类编程 InputStream in = null; OutputStream out = null; try &#123; // 选择流,确定源头 in = new FileInputStream(&quot;src/tech/aistar/day13/FileDemo.java&quot;); out = new FileOutputStream(&quot;src/tech/aistar/day13/FileDemo_copy.java&quot;); int len = -1; //读取的内容 // 循环读取 while (true)&#123; len = in.read(); // 当没有内容的时候,就会返回-1 if(len == -1) break; //System.out.print((char) len); // 英文,符号,字母可以打印出来 但是中文打印的是乱码 // 因为中文在&quot;utf-8&quot;编码是三个字节 // 中文在&quot;gbk&quot;编码下是两个字节 // 进行拷贝 out.write(len); //out在写出去的时候会自动处理中文 &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null!=in)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(null!=out)&#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 注意一下最后要关闭流,并且在关闭流之前先判断流是否为null. 自定义缓冲数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/5 20:20 * @description 使用自定义缓冲数组读取数据 * 减少了java程序和磁盘的IO交互的次数 */public class ByteArrayDemo &#123; public static void main(String[] args) &#123; InputStream in = null; OutputStream out = null; try &#123; in = new FileInputStream(&quot;src/tech/aistar/day13/Book.java&quot;); // 创建缓冲数组 - 具体的大小要根据业务需求而定 byte[] buf = new byte[3*1024]; int len = -1; // 循环读取 while (true)&#123; len = in.read(buf); // 返回的是读取的字节数 if(len == -1) break; // 打印buf的结果 String str = new String(buf); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(null!=in)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334结果:[只截取了部分结果]package tech.aistar.day13;import java.io.Serializable;/** * @Author liuWenXiu * @Date 2021/7/31 16:05 * @description */public class Book implements Serializable &#123; private int id; private String isbn; private String name; private double price; public Book() &#123; &#125; void Book()&#123; System.out.println(&quot;enheng?&quot;); &#125; public Book(int id, String isbn, String name, double price) &#123; this.id = id; this.isbn = isbn; this.name = name; this.price = price; &#125;Process finished with exit code 0 String s = new String(byte[] buf); String的构造方法 - 用byte数组构建字符串 结果证明缓冲数组buf中是有数据的. 文件的拷贝 - 利用自定义缓冲数组 - 关键代码1234567891011byte[] buf = new byte[3*1024];int len = -1;// 循环读取while (true)&#123; //读数据 len = in.read(buf); // 从输入流中读取一定数量的字节放到缓冲数组buf中,并且返回给len[当前总共读到的字节数] if(len == -1) break; // 写数据 out.write(buf,0,len);&#125; 缓冲流BufferedInputStream在它出来之前,可以单个单个字节进行读写操作,缺点是java程序和磁盘的IO交互比较频繁,性能就会低下. 采取了自定义的数组的方式,从磁盘文件中读取一定数量的字节先放入到缓冲数组中,然后再从缓冲数组中一次性写出道磁盘中,减少了java程序和磁盘IO的交互次数. - 性能提高 JDK中发现了这点,提供了缓冲流BufferedInputStream 123456789101112131415private static int DEFAULT_BUFFER_SIZE = 8192;//默认的容量8kbprotected volatile byte buf[];//内置的缓冲区public BufferedInputStream(InputStream in) &#123; this(in, DEFAULT_BUFFER_SIZE);&#125;public BufferedInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;); &#125; buf = new byte[size];//初始化内置的缓冲区数组 - 大小是8kb&#125; 底层利用了”装饰器”思想,这个流属于包装流,拓展流,过滤流,本身不具备真正的文件的读写能力. 构建带缓冲功能的流,必须要以节点作为支持. 构建一个带缓冲功能的能够读取文件的字节输入流. 123BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;路径&quot;));BufferedOutputStream in = new BufferedOutputStream(new FileOutputStream(&quot;路径&quot;)); 缓冲数组BufferedInputStream本身已经在底层定义了8kb的字节数组,那么为什么程序中还自定义了一个3kb的字节数组[可以不定义,read()方法],自定义的byte[]和内置的byte[]各自的作用是什么? 内置的8kb的byte[] - 在一开始或者后面空闲的时候,由JVM去装载磁盘上的数据,提前放入到这个内置的byte[]中的. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/5 20:27 * @description 缓冲流 */public class BufferDemo &#123; public static void main(String[] args) &#123; BufferedInputStream in = null; BufferedOutputStream out = null;//out = new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy.gif&quot;); try &#123; in = new BufferedInputStream(new FileInputStream(&quot;src/tech/aistar/day13/fast.gif&quot;)); out = new BufferedOutputStream(new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy2.gif&quot;)); // 自定义一个byte[] byte[] buf = new byte[3*1024]; int len = -1; while (true)&#123; len = in.read(buf); if(len == -1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; // 关闭资源 try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 读过程 当初始化好缓冲流之后,jvm会立刻读取磁盘中的数据到内置的缓冲数组中. 当程序循环读取到len = in.read(buf)时,程序是直接从内置的缓冲区[内置的缓冲数组中] 一旦内置的数组中的8kb数据被取完,那么jvm在空闲的时候,继续加载文件中下一个8kb的字节到内置的缓冲区. 语法糖jdk7.0提供的写法 - 把流的关闭交给jvm 12345try(资源对象的声明1;资源对象的声明2)&#123;&#125;catch(...)&#123; ...&#125; 123456789101112131415161718192021222324252627282930313233package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/5 20:37 * @description 语法糖 - jvm去关闭流 - 最终的版本 */public class StreamAutoCloseDemo &#123; public static void main(String[] args) &#123; try(BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;src/tech/aistar/day13/fast.gif&quot;)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(&quot;src/tech/aistar/day13/fast_copy4.gif&quot;)))&#123; // 定义一个byte数组 byte[] buf = new byte[3*1024]; int len = -1; while (true)&#123; len = in.read(buf); if(len == -1) break; out.write(buf,0,len); &#125; System.out.println(&quot;文件拷贝成功&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 证明语法糖是自动关闭对象12345678910111213141516public class ScannerDemo &#123; public static void main(String[] args) &#123; int result = get(); System.out.println(result); int x = get(); System.out.println(x); &#125; public static int get()&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); sc.close(); return n; &#125;&#125; 12345public static int get()&#123; try(Scanner sc = new Scanner(System.in))&#123; return sc.nextInt(); &#125;&#125; 1234结果相同,都为如下:11Exception in thread &quot;main&quot; java.util.NoSuchElementException ObjectInputStream/ObjectOutputStream操作对象类型的字节输入流和字节输出流,拓展流,必须要以节点流作为支撑. 构建一个能够读写对象类型的文件字节输入流/输出流 12ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;path&quot;));ObjectOutputStream in = new ObjectOutputStream(new FileOutputStream(&quot;path&quot;)); 构建一个能够读写对象类型的并且带缓冲功能的文件字节输入流 12ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(&quot;path&quot;)));ObjectOutputStream in = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(&quot;path&quot;))); 利用”装饰器”思想,我们构建出功能更加强大的流,但是又不会对原来的流的结构产生任何影响. 序列化对象的序列化数据的持久化的过程,把内存中的java对象存储到磁盘的文件的过程. 注意点: 如果保存的是单个对象,这个对象的实体类必须要实现java.io.Serializable序列化接口. 如果没有实现这个接口,进行序列化的时候,抛出一个java.io.NotSerializableException不可被序列化的异常 保存的是数组/集合,那么集合中的每个对象对应的实体类也是需要实现这个序列化的接口. 关于追加写入,设置FileOutputStream(String path,boolean append);//append设置true,但是不支持分批次读取. 对象的反序列化java对象已经存储到磁盘的文件中,希望再从文件中将这些对象数据加载到内存中[映射到java对象上]. 字符流它和字节流的区别是读取的单位是不同的,字节流是按照单个字节进行读写操作. 字符流是按照单个字符的单位进行读写操作,字符流专门用来处理文本字符文件的,字节流用来处理文本文件或者二进制文件的. 字符输入流 java.io.Reader[C] - 顶级的字符输入流 - 抽象类 BufferedReader[C] - 带缓冲功能的字符流 123public BufferedReader(Reader in)&#123; this(in,defaultCharBufferSize);&#125; 提供的方法:String readLine(); // 每次读取文本文件一整行的数据 FileReader[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作 12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.day13;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/** * @Author liuWenXiu * @Date 2021/8/6 13:50 * @description 字符输入流 */public class ReaderHelloDemo &#123; public static void main(String[] args) &#123; /** * 步骤: * 1. 确定流 * 2. 确定源头 * 3. 循环读取 * 4. 关闭流 - 可以采用语法糖 - jvm自动关闭 */ try(BufferedReader in = new BufferedReader(new FileReader(&quot;src/tech/aistar/day13/book.java&quot;)))&#123; // 一行一行地读取 String line = null; // 循环读取 while (true)&#123; line = in.readLine(); // 读取一整行的数据,如果读取不到了,就返回null if(line == null) break; System.out.println(line); //注意这里不要忘记换行 &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 字符输出流 java.io.Writer[C] - 顶级的字符输出流 - 抽象类 PrintWriter[C] - 自带缓存功能 构造方法: 12PrintWriter(Writer out);PrintWriter(Writer out,boolean autoFlush); 第二个参数是是否自动刷新缓存.缓存里面的数据被同步到磁盘上一般有两种情况,第一种是缓存中的数据满的时候回自动刷新,第二种是缓存中的数据还不足以撑满这个缓存但是使用了close方法或者flush方法手动刷新. FileWriter[C] - 字符流中的节点流 - 具备真正的字符文件的读写操作的 构造方法: 12FileWriter(String path);FileWriter(String path,boolean append); 第二个参数代表的是是否追加写入.如果append设置为true,则可以支持分批次的写和分批次的读.而字节流不行,字节流可以追加写入,但不能读出来. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package tech.aistar.day13;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;/** * @Author liuWenXiu * @Date 2021/8/6 14:16 * @description 字符输出流 */public class WriteHelloDemo &#123; public static void main(String[] args) &#123; //test01(); test02(); &#125; /** * 构建一个不自动刷新,不能够追加写入的字符输出流 * 每次都会覆盖原来的文件,兵器而在第一次写入的时候,会自动创建这个文件 */ public static void test01()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;)))&#123; /** * 因为语法糖 - close操作 - 底层就是关闭流之前,会强制刷新缓存 */ /** * print方法以及println方法 * print方法写入之后,后面是没有加一个\\n * println方法写入之后,后面有一个\\n */ out.print(&quot;java很好玩&quot;); //out.println(&quot;python和好玩&quot;); //out.print(&quot;php很好玩!&quot;); // 把内存的数据持久化到硬盘的文件中 out.flush(); //可以不写,但是保险起见可以写一下 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 构建一个不能自动刷新,但是能够追加写入的字符流 */ public static void test02()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;,true)))&#123; out.print(&quot;hello&quot;); out.print(&quot;nice to meet&quot;); out.println(&quot;you&quot;); out.print(&quot;!&quot;); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void test03()&#123; try(PrintWriter out = new PrintWriter(new FileWriter(&quot;src/tech/aistar/day13/writer.txt&quot;,true),true))&#123; out.print(&quot;hello&quot;); out.print(&quot;nice to meet&quot;); out.println(&quot;you&quot;); out.print(&quot;!&quot;); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 文件的拷贝12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.day13;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/6 14:58 * @description */public class FileCopyReaderDemo &#123; public static void main(String[] args) &#123; copyFile(&quot;src/tech/aistar/day13/hello.txt&quot;,&quot;src/tech/aistar/day13/hello_copy.txt&quot;); &#125; public static void copyFile(String src,String target)&#123; try(BufferedReader in = new BufferedReader(new FileReader(src)); PrintWriter out = new PrintWriter(new FileWriter(target),true))&#123; String line = null; while (true)&#123; line = in.readLine(); if(line == null) break; out.print(line); &#125; out.flush(); System.out.println(&quot;文件拷贝成功!&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 总结笔试 常见的字节流和字符流 装饰器的设计模式 难一点的知识点 - 同步[打电话]IO/异步[发短信]IO区别,阻塞IO/非阻塞IO区别 BufferedInputStream - 内置的缓冲数组 - 8kb 补充 - 破坏单例单例设计模式 - 保证在整个应用程序中,某个类的具体的实例永远只有1个 - 多线程下也是一个 - 双重锁检测 对象的序列化和反序列化可以破坏这种单例,如何破坏? 解决方案: 单例的第四个版本 - 枚举类型来实现单例模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.day13;import tech.aistar.design.singleton.version03.Singleton03;import java.io.*;/** * @Author liuWenXiu * @Date 2021/8/6 15:22 * @description 对象的序列化和反序列化会破坏单例 */public class ObjectSingletonDemo &#123; public static void main(String[] args) &#123; Singleton03 s1 = Singleton03.getInstance(); writeObject(s1,&quot;src/tech/aistar/day13/temp.txt&quot;); Singleton03 s2 = readObject(&quot;src/tech/aistar/day13/temp.txt&quot;); System.out.println(s1 == s2); &#125; public static void writeObject(Singleton03 s,String path)&#123; try(ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) &#123; // 写 out.writeObject(s); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Singleton03 readObject(String path)&#123; Singleton03 s = null; try(ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) &#123; // 读 s = (Singleton03) in.readObject(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return s; &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"http://beautifulboyy/tags/IO%E6%B5%81/"},{"name":"序列化","slug":"序列化","permalink":"http://beautifulboyy/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"异常的处理","slug":"java10","date":"2021-08-04T06:20:14.000Z","updated":"2021-08-04T10:35:25.465Z","comments":true,"path":"2021/08/04/java10/","link":"","permalink":"http://beautifulboyy/2021/08/04/java10/","excerpt":"","text":"Throwablejava.lang.Throwable - 异常和错误的顶级的类 123456两个分支: 1. java.lang.Error - 错误 - 错误一旦发生,程序员是没有办法进行扭转的,不需要在代码中进行处理. 1-1. 子类VirtualMachineError虚拟机级别的错误 1-1-1. 子类java.lang.StackOverflowError 堆栈溢出 - 应用程序因为递归太深没有指定出口的时候. 1-1-2. 子类java.lang.OutOfMemoryError 内存泄露 - [GC垃圾回收机制 - 后台自动回收垃圾对象] 2. java.lang.Exception - 异常 - 程序在运行的过程中发生了不正常的情况 异常的分类运行时异常[RuntimeException]都是非运行时异常的子类[Exception] 运行时异常 - 未检测异常 顶级的父类java.lang.RuntimeException java.lang.NullPointerException - 空指针异常 12String str = null;System.out.println(str.length()); java.util.InputMismatchException - 输入不匹配异常 12Scanner sc = new Scanner(System.in);int n = sc.nextInt(); //只能获取整数,但是输入了一个字符串&quot;abc&quot; java.lang.ArithmeticException: - 分母为0 1System.out.println(10/0); java.lang.IllegalArgumentException - 非法参数异常 1SimpleDateFormat sdf = new SimpleDateFormat(&quot;ff&quot;); java.lang.IndexOutOfBoundsException - 下标越界异常 12List&lt;String&gt; list = new ArrayList&lt;&gt;();System.out.println(list.get(3)); 5.1 java.lang.StringIndexOutOfBoundsException - 字符串下标越界异常 12String str = &quot;faflfsfe&quot;;System.out.println(str.charAt(10)); 5.2 java.lang.ArrayIndexOutOfBoundsException - 数组下标越界异常 12int[] arr = &#123;1,3,5,7,9&#125;;System.out.println(arr[10]); java.util.NoSuchElementException - 不存在此元素 12LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;();System.out.println(list.getFirst()); java.lang.ClassCastException - 类型转换失败异常 12Animal c = new Cat(&quot;小喵&quot;,300.d);Dog dog = (Dog) c; 父类转换子类类型之前,推荐使用instanceof关键字进行类型的判断 非运行时异常 - 已检测异常 非运行时异常在编译时就能发现问题,需要用try…catch语句包裹. java.text.ParseException - 解析失败异常 - 字符串的模板和pattern不匹配 1234567SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);String str = &quot;2021-02-28&quot;;try &#123; Date date = sdf.parse(str);&#125; catch (ParseException e) &#123; e.printStackTrace();&#125; InterruptedException - 中断异常 12345try &#123; Thread.sleep(3000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; java.lang.CloneNotSupportedException - 不支持clone 12345try &#123; Product copy = (Product) p1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 当Product实体类没有实现cloneable接口时就会出现这样的异常 java.io.IOException - IO流异常 4-1. java.io.EOFException - 已经读到文件的末尾了 4-2. java.io.FileNotFoundException - 文件找不到异常 java.sql.SQLException - SQL异常,比如程序中的sql语句写错了. 异常的处理方式 运行时异常不需要处理(也是可以处理的),只需要在编程的时候,注意一下验证/判断,稍微谨慎一点 非运行时异常,在编译期间就需要立即对其进行处理.处理的方式有两种,一种是积极处理,使用try…catch包围可能出现异常的语句,还有一种是消极处理. 积极处理方式 语法: try…catch…catch… 12345678try&#123; //code... //code...&#125;catch(异常类型1 e1)&#123; // code...&#125;cathc(异常类型2 e2)&#123; // code..&#125; 注意:上方的异常类型不能是下方的异常类型的父类 语法 - jdk7.0提供的新的写法 123456try&#123; //code... //code...&#125;catch(异常类型1 | 异常类型2)&#123; // code...&#125; 注意一下这里是非短路或. 语法 12345try&#123; //code..&#125;catch(异常总父类)&#123; //code..&#125; 消极处理比如在某个方法中某些代码出现了非运行时异常,那么在自己方法的内部”不着急”去积极处理.而是把这个异常抛出去了. 为了自己不处理,而是抛出去? - 因为这个方法有可能会被反复在其他地方调用 - 原则:谁调用,谁负责最终处理. 原则谨记 - 不要把异常抛给main方法,等同于把异常抛给jvm,等同于一旦出现异常,程序就会崩溃. 一个简单的实例 12345public void b() throws FileNotFoundException, ParseException &#123; InputStream in = new FileInputStream(&quot;d:\\\\sss&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date strDate = sdf.parse(&quot;2021-02-28&quot;);&#125; 直接在方法的签名[声明]上使用throws关键字+异常类型1,异常类型2 在方法体中使用throw+异常对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class NegativeHandlerException &#123; // 不要把异常抛给main方法 public static void main(String[] args) &#123; d(0); &#125; // c是最终的调用者 public void c()&#123; // 谁最终调用,谁最终进行处理 try &#123; a(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; // 可以一直向上抛 public void a() throws FileNotFoundException&#123; try &#123; b(); //先处理一部分的异常,没有处理的可以继续抛出 &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; public void b() throws FileNotFoundException, ParseException &#123; InputStream in = new FileInputStream(&quot;d:\\\\sss&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date strDate = sdf.parse(&quot;2021-02-28&quot;); &#125; public static void d(int n)&#123; if(n==0)&#123; //System.out.println(&quot;异常...&quot;); /* throw + 运行时异常,不需要在方法的签名上抛出异常 因为本身运行时异常就不需要进行处理 */ throw new RuntimeException(&quot;发生异常啦&quot;); &#125; System.out.println(&quot;n:&quot;+n); &#125; public static void e(int n) throws FileNotFoundException &#123; if(n==0)&#123; /* throw + 非运行时异常 必须要在方法的签名上throws+非运行时异常类型 */ throw new FileNotFoundException(&quot;文件不存在!&quot;); &#125; System.out.println(&quot;n:&quot;+n); &#125;&#125; 自定义异常项目中存在一个exception包,专门定义自己的异常[大量的] jdk内置的异常不够用,不符合实际的业务场景 步骤 写一个异常类继承java.lang.Exception 提供父类的5个构造方法即可. 自定义异常的意义123System.out.println(&quot;余额小于0&quot;); throw new BalanceLtZeroException(&quot;余额小于0!&quot;); 场景:有的时候访问某些网站的时候 - 跳转到一个友好的页面 - 显示比如服务器正在维护/升级… 我们应该提供一个异常处理器 - 会监控软件程序在整个项目运行的过程中发生的一切异常. 一旦它发现了某个地方产生了异常,那么它就会对这些异常进行一个日志记录,然后再让程序跳转到一个友好的界面. SpringMVC/SpringBoot - 异常处理器 - 只认识异常. 相关笔试题1.笔试题1 123456789101112131415try&#123; // code // code return; // 结束整个方法&#125;catch(异常类型 e)&#123; // code&#125;catch(异常类型 e)&#123; // code&#125;finally&#123; // 无论是否出现异常,都会执行&#125;提问:假设try&#123;&#125;中没有任何异常发生,所有的code都会顺利执行.1.finally中的代码是否执行? - 一定会执行2.return语句是在finally块之前执行还是之后执行? - 之后执行 123456789String str = &quot;str&quot;;try &#123; System.out.println(str.length()); return;&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; System.out.println(&quot;-----end-----&quot;);&#125; 123结果:3-----end----- 2.笔试题2 123456789101112131415public class FinallyDemo &#123; public static void main(String[] args) &#123; System.out.println(test()); &#125; public static int test()&#123; int i = 0; // try可以直接和finally一起使用... try&#123; return ++i; &#125;finally &#123; ++i; System.out.println(&quot;i:&quot;+i); &#125; &#125;&#125; 结果: i:2 1 对待基本数据类型:在执行到return语句时,将i自增后的结果缓存起来了,并且这个缓存的结果就是作为最终返回出去的一个结果.然后执行finally中的语句,这时候finally中的修改不影响缓存中的数据,最后执行return语句. 123456789101112131415161718192021222324252627public class FinallyDemo &#123; public static void main(String[] args) &#123; System.out.println(change()); &#125; public static A change()&#123; A a = new A(); try&#123; a.age = 100; return a; &#125;finally &#123; a.age = 200; &#125; &#125;&#125;class A&#123; public int age = 19; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;A&#123;&quot;); sb.append(&quot;age=&quot;).append(age); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 结果:A{age=200} 对待对象类型:finally语句中修改对象的属性值时会影响return的结果 3.笔试题3 final和finally和finalize三者之间的区别? - 一点关系都没有 final a. 修饰的局部变量一旦赋值成功,不可改变. b.修饰的属性一旦赋值成功,不可改变 c.修饰的类不可被继承 d.修饰的方法不可被重写 finally a. 一般是和try.catch搭配使用的,try块中无论是否出现异常,finally块中的代码都会执行 b. finally块中一般写的是释放或者关闭资源的代码 finalize - Object类中提供的方法 a. 当GC想要去回收一个垃圾对象之前,会调用这个对象的finalize方法.这个是由jvm进行调用的. b. 该方法未必一定会调用得到. 4.throw和throws的区别 throw: 表示方法内抛出某种异常对象 如果异常对象是非RuntimeException则需要在方法申明时加上该异常的抛出,即需要加上throws语句或者在方法体内try…catch处理该异常,否则编译报错. 执行到throw语句则后面的语句块不再执行. throws: 方法的定义上使用throws表示这个方法可能抛出某种异常. 需要由方法的调用者进行异常处理.","categories":[],"tags":[{"name":"异常","slug":"异常","permalink":"http://beautifulboyy/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"零碎的知识点","slug":"java09","date":"2021-08-02T01:21:39.000Z","updated":"2021-08-06T03:28:48.155Z","comments":true,"path":"2021/08/02/java09/","link":"","permalink":"http://beautifulboyy/2021/08/02/java09/","excerpt":"","text":"SimpleDateFormat java.text.SimpleDateFormat - 日期格式处理类 它是一个线程不安全的类. 模板 Letter Date or Time Component Presentation Examples G Era designator Text AD y Year Year 1996; 96 Y Week year Year 2009; 09 M Month in year (context sensitive) Month July; Jul; 07 L Month in year (standalone form) Month July; Jul; 07 w Week in year Number 27 W Week in month Number 2 D Day in year Number 189 d Day in month Number 10 F Day of week in month Number 2 E Day name in week Text Tuesday; Tue u Day number of week (1 = Monday, …, 7 = Sunday) Number 1 a Am/pm marker Text PM H Hour in day (0-23) Number 0 k Hour in day (1-24) Number 24 K Hour in am/pm (0-11) Number 0 h Hour in am/pm (1-12) Number 12 m Minute in hour Number 30 s Second in minute Number 55 S Millisecond Number 978 z Time zone General time zone Pacific Standard Time; PST; GMT-08:00 Z Time zone RFC 822 time zone -0800 X Time zone ISO 8601 time zone -08; -0800; -08:00 目标 Date类型转换成String类型 - 按照指定的日期格式 1234Date d = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss E&quot;);String strDate = sdf.format(d);System.out.println(strDate); 结果:2021-08-02 09:44:01 星期一 1234Date d = new Date();SimpleDateFormat sdf = new SimpleDateFormat(&quot;ff&quot;);String strDate = sdf.format(d);System.out.println(strDate); 结果:Exception in thread “main” java.lang.IllegalArgumentException: Illegal pattern character ‘f’ pattern必须是一个有效的格式化模板,如果传入了一个非法模板,就会抛出一个非法参数异常. String类型转成Date类型 12345678String birthday = &quot;2021-09-21&quot;;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);try &#123; Date dt = format.parse(birthday); System.out.println(&quot;Date:&quot;+dt);&#125; catch (ParseException e) &#123; e.printStackTrace(); //打印堆栈中的异常信息&#125; 结果:Date:Tue Sep 21 00:00:00 CST 2021 12345678String birthday = &quot;2021-09-21&quot;;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);try &#123; Date dt = format.parse(birthday); System.out.println(&quot;Date:&quot;+dt);&#125; catch (ParseException e) &#123; e.printStackTrace(); //打印堆栈中的异常信息&#125; 结果:java.text.ParseException: Unparseable date: “2021-09-21” 如果构造中的pattern的格式和日期的字符串格式不一致,在调用的时候回抛出解析失败异常. BigDecimalapi:java.math 构造方法 BigDecimal(double val); BigDecimal(String val); 常用方法 方法 含义 BigDecimal add(BigDecimal augend) 加 BigDecimal substract(BigDecimal subtrahend) 减 BigDecimal multiply(BigDecimal multiplicand) 乘 BigDecimal divide(BigDecimal divisor) 除 12345678910111213141516public class BigDecimalDemo &#123; public static void main(String[] args) &#123; BigDecimal d1 = new BigDecimal(9); BigDecimal d2 = new BigDecimal(3); // 加法运算 System.out.println(d1.add(d2)); //12 // 减法运算 System.out.println(d1.subtract(d2)); //6 // 乘法运算 System.out.println(d1.multiply(d2)); //27 // 除法运算 System.out.println(d1.divide(d2)); //3 &#125;&#125; 笔试题 - 在java开发中如何处理小数精度123456789101112public class BigDecimalHandleFloatDemo &#123; public static void main(String[] args) &#123; // BigDecimal的构造方法中有new BigDecimal(String) BigDecimal d1 = new BigDecimal(&quot;0.1&quot;); BigDecimal d2 = new BigDecimal(String.valueOf(&quot;0.2&quot;)); // 获取两个数相加的结果 BigDecimal result = d1.add(d2); // 相加的结果仍然是BigDecimal. 利用doubleValue获取result的double值 double resultDouble = result.doubleValue(); System.out.println(resultDouble); &#125;&#125; BigInteger笔试题 - 递归算法求阶层12345678public static BigInteger test(int n)&#123; if(n == 1) //return new BigInteger(&quot;1&quot;); return BigInteger.ONE; // 这个是上面那行代码的简写 BigInteger current = new BigInteger(String.valueOf(n)); return current.multiply(test(n-1));&#125; 四种内部类看懂别人写的内部类语法即可. 成员内部类 - 把内部类看成是外部类的一个成员 a. 成员内部类不能定义静态成员 b. 成员内部类中可以通过Outer.this.非静态属性名来访问外部类的非静态方法 c. 外部类.内部类 对象名 = 外部类对象.new 内部类(); 12345678910111213141516171819202122232425262728public class Outer &#123; private int id = 10; // 普通属性 private static int sid = 100; // 静态属性 // 1.成员内部类 - 把内部类看做成外部类的一个成员 public class MemberInner&#123; // 定义非静态属性 private int id = 20; private int age = 18; // 成员内部类不允许定义静态成员 // private static int sid = 200; public MemberInner()&#123; System.out.println(&quot;MemberInner...&quot;); &#125; // 自定义方法 public void test()&#123; System.out.println(&quot;内部类age:&quot;+age); System.out.println(&quot;内部类id:&quot;+id); System.out.println(&quot;外部类id:&quot;+Outer.this.id); System.out.println(&quot;外部类sid:&quot;+Outer.sid); &#125; &#125;&#125; 1234public static void main(String[] args) &#123; // 创建对象 Outer.MemberInner m = new Outer().new MemberInner();&#125; 静态内部类 - 把内部类看成是外部类的一个静态成员 a. 内部可以定义静态和非静态属性 b. 内部的普通方法中是不允许访问外部类的非静态属性的 c. 内部的普通方法中允许访问外部类的静态属性 d. 外部类.内部类 变量名 = new 外部类.静态类(); 1234567891011121314151617181920212223public class Outer &#123; private int id = 10; // 普通属性 private static int sid = 100; // 静态属性 public static class StaticMemberInner&#123; // 定义一个非静态属性 private int id = 20; // 定义一个静态属性 private static int sid = 299; public StaticMemberInner()&#123; System.out.println(&quot;StaticMemberInner&quot;); &#125; public void test()&#123; System.out.println(&quot;内部类-id:&quot;+this.id); System.out.println(&quot;内部类-sid:&quot;+sid); System.out.println(&quot;外部类-sid:&quot;+Outer.sid); // 静态类中访问不到外部类的非静态属性 &#125; &#125;&#125; 1Outer.StaticMemberInner s = new Outer.StaticMemberInner(); 局部内部类 - 内部类是出现在外部类的方法中 a. 内部类不允许使用访问修饰符,比如不能使用public b. 不能定义静态属性 c. 可以访问外部类的静态和非静态成员 d. 生命只在所在的方法中,方法外部是没有办法拿到这个对象的(不能直接在外部new) 123456789101112131415public void testLocalInner()&#123; class LocalInner&#123; public LocalInner()&#123; System.out.println(&quot;LocalInner()...&quot;); &#125; private int id = 10; public void test()&#123; System.out.println(&quot;内部类id:&quot;+id); System.out.println(&quot;外部类id:&quot;+id); System.out.println(&quot;外部类sid:&quot;+sid); &#125; &#125; LocalInner localInner = new LocalInner(); localInner.test();&#125; 匿名内部类 - 必须掌握 好处 - 我们可以在程序中少写实现类 jdk8.x中如果遇到函数式接口.推荐使用lambda表达式来替代匿名内部类的写法的. UMLUnified Modeling Language - 统一建模语言 BA - 需求分析师 powerndesigner starUML 掌握目标:看懂箭头即可 类与类之间由弱到强的关系是:没关系&lt;依赖&lt;关联&lt;聚合&lt;组合 依赖虚线 + 箭头 &lt;—– 简单理解:一个类A使用到了另一个类B.这种使用关系是具有偶然性的,临时性的,非常弱的. 12345678910public class A&#123; public void test(B b)&#123; // 自己的功能 // B类中的功能 b.test(); &#125;&#125;public class B&#123; &#125; 关联实线 + 箭头 &lt;- A类关联了B,A依赖于B 123456public class A&#123; private B b;&#125;public class B&#123; &#125; 组合属于关联的一种,强调的是整体和局部之间的关系,这种关系非常紧密,整体是可以决定局部的生命周期的. 箭头 + 实线 + 实心菱形 1234567891011public class Baby&#123; private Eye eye; private Hand hand; public Baby()&#123; this.eye = new Eye(); this.hand = new Hand(); &#125; public static void main(String[] args)&#123; Baby b = new Baby(); &#125;&#125; 聚合关系属于关联的一种 - 强调的是整体和局部的关系,这种关系较紧密.整体是可以不用决定局部的生命周期的 - 局部单独存在的 箭头 - 实线+空心菱形 123456public class Computer&#123; private Cpu cpu; public Computer(Cpu cpu)&#123; this.cpu = cpu; &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"DateFormat","slug":"DateFormat","permalink":"http://beautifulboyy/tags/DateFormat/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"http://beautifulboyy/tags/BigDecimal/"},{"name":"BigInteger","slug":"BigInteger","permalink":"http://beautifulboyy/tags/BigInteger/"},{"name":"内部类","slug":"内部类","permalink":"http://beautifulboyy/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"UML","slug":"UML","permalink":"http://beautifulboyy/tags/UML/"}]},{"title":"static关键字","slug":"java08","date":"2021-07-31T06:18:40.000Z","updated":"2021-08-02T02:14:57.322Z","comments":true,"path":"2021/07/31/java08/","link":"","permalink":"http://beautifulboyy/2021/07/31/java08/","excerpt":"","text":"static关键字 Static修饰的成员是在JVM加载类的时候就会被立刻分配空间以及初始化,这个过程只有一次,并且内存的实例也只有一份. 非静态的成员是在每次创建对象的时候才会被分配空间以及初始化. Static的作用 static修饰类 - 静态内部类[过] static修饰属性 - 静态属性 static修饰方法 - 静态方法 static修饰代码块 - 静态代码块 JVM加载类进入内存的活动顺序 JVM加载类进入内存 给所有的静态属性分配空间以及初始化 给所有的静态方法分配空间以及初始化 执行静态代码块 如果创建了对象 5-1.给这个对象的所有非静态属性分配空间以及初始化 5-2.给这个对象的所有非静态方法分配空间以及初始化 5-3.执行普通代码块 5-4.执行构造块 static关键字的应用设计模式 - 单例模式 static练习123456789101112131415161718192021222324public class StaticDemo &#123; // 普通属性 - 每次创建对象的时候才会被分配空间以及初始化 private int id = 10; // 静态属性 - static修饰的成员是在jvm加载类的时候就会被立即分配空间以及初始化 private static int sid = 100; // 构造方法 public StaticDemo()&#123; this.id = sid++; &#125; public int getId() &#123; return id; &#125; public static void main(String[] args) &#123; StaticDemo s1 = new StaticDemo(); System.out.println(s1.getId()); StaticDemo s2 = new StaticDemo(); System.out.println(s2.getId()); &#125;&#125; 结果: 100 101 12345678910111213141516171819202122232425262728293031public class StaticBlockDemo &#123; private int id = 10; private static int sid = 100; public StaticBlockDemo()&#123; System.out.println(&quot;构造方法&quot;); System.out.println(&quot;con-id:&quot;+id); System.out.println(&quot;con-sid&quot;+sid); &#125; // 普通代码块 - 每次创建对象的时候,都会执行 - 并且它的时机高于构造块 &#123; System.out.println(&quot;普通代码块&quot;); System.out.println(&quot;b-id&quot;+id); System.out.println(&quot;b-sid&quot;+sid); &#125; // 静态代码块 - jvm加载类进入内存的时候,立即调用静态代码 // 仅仅会执行一次,执行效率最高 static &#123; System.out.println(&quot;静态代码块&quot;); System.out.println(&quot;s-sid:&quot;+sid); &#125; public static void main(String[] args) &#123; StaticBlockDemo s1 = new StaticBlockDemo(); System.out.println(); StaticBlockDemo s2 = new StaticBlockDemo(); &#125;&#125; 结果: 静态代码块s-sid:100普通代码块b-id10b-sid100构造方法con-id:10con-sid100 普通代码块b-id10b-sid100构造方法con-id:10con-sid100 12345678910111213public class Cygnus&#123; static int value = 9; private void printValue()&#123; //局部变量不能使用对象去获取 int value = 69; System.out.println(this.value); &#125; public static void main(String[] args) throws Exception&#123; new Cygnus().printValue(); &#125;&#125; 这个程序会有下面哪种结果？A. 编译错误B. 打印9C. 打印69D. 运行时抛出异常 结果:B 1234567891011121314151617181920212223242526class Base&#123; static&#123; System.out.println(&quot;base static&quot;); &#125; public Base()&#123; System.out.println(&quot;base constructor&quot;); &#125;&#125;public class Test extends Base&#123; static&#123; System.out.println(&quot;test static&quot;); &#125; public Test()&#123; super(); System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; 结果 base statictest staticbase constructortest constructor 12345678910111213public class Test &#123; static&#123; System.out.println(&quot;test static 1&quot;); &#125; public static void main(String[] args) &#123; &#125; static&#123; System.out.println(&quot;test static 2&quot;); &#125;&#125; 结果 test static 1test static 2 123456789101112131415public class test&#123; static&#123; int x=5; &#125; static int x,y; public static void main(String args[])&#123; x--; myMethod( ); System.out.println(x+y+ ++x); &#125; public static void myMethod( )&#123; y=x++ + ++x; &#125;&#125; A. 编译错误B. 输出：1C. 输出：2D. 输出：3E. 输出：7F. 输出：8 结果:D 12345678910111213141516171819202122class HelloA&#123; public HelloA() &#123; System.out.println(&quot;I’m A class &quot;); &#125; static&#123; System.out.println(&quot;static A&quot;); &#125;&#125;public class HelloB extends HelloA&#123; public HelloB()&#123; System.out.println(&quot;I’m B class&quot;); &#125; static&#123; System.out.println(&quot;static B&quot;); &#125; public static void main (String[] args)&#123; new HelloB(); &#125;&#125; A. static A I’m A class static B I’m B classB. I’m A class I’m B class static A static BC. static A static B I’m A class I’m B classD. I’m A class static A I’m B class static B 结果:C 12345678910111213141516public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println(&quot;构造块&quot;); &#125; static&#123; System.out.println(&quot;静态块&quot;); &#125; public static void main(String[] args)&#123; B t = new B(); &#125;&#125; A. 静态块 构造块 构造块 构造块B. 构造块 静态块 构造块 构造块C. 构造块 构造块 静态块 构造块D. 构造块 构造块 构造块 静态块 结果:D 12345678910111213141516171819class A &#123; public int func1(int a, int b) &#123; return a - b; &#125;&#125;class B extends A &#123; public int func1(int a, int b) &#123; return a + b; &#125;&#125;public class ChildClass &#123; public static void main(String[] args) &#123; A a = new B(); B b = new B(); System.out.println(&quot;Result=&quot; + a.func1(100, 50)); System.out.println(&quot;Result=&quot; + b.func1(100, 50)); &#125;&#125; A. Result=150Result=150B. Result=100Result=100C. Result=100Result=150D. Result=150Result=100 结果:A 123456789101112131415public class Test&#123; public static Test t1 = new Test(); &#123; System.out.println(&quot;blockA&quot;); &#125; static&#123; System.out.println(&quot;blockB&quot;); &#125; public static void main(String[] args)&#123; Test t2 = new Test(); &#125; &#125; A. blockAblockBblockAB. blockAblockAblockBC. blockBblockBblockAD. blockBblockAblockB 结果:A","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"static","slug":"static","permalink":"http://beautifulboyy/tags/static/"}]},{"title":"String和StringBuilder的使用","slug":"java05","date":"2021-07-31T03:10:47.000Z","updated":"2021-07-31T12:11:25.569Z","comments":true,"path":"2021/07/31/java05/","link":"","permalink":"http://beautifulboyy/2021/07/31/java05/","excerpt":"","text":"Stringjava中提供的处理字符串的类 - java.lang.String 特点 字符串是不可变的 123String str = &quot;abc&quot;;str = &quot;eef&quot;;// 这里字符串&quot;abc&quot;是没有改变的,将str指向了&quot;eef&quot;,导致&quot;abc&quot;成了垃圾对象. 字符串的本质上就是一个字符数组 123456public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ //String s = &quot;abc&quot;; 会将&quot;abc&quot;打散,保存到value[]数组中. private final char value[];&#125; 1.String被final修饰,被final修饰的类不可以被继承-&gt;String不能被继承 2.final char value[],表示这个String维护的是不可变的字符数组 构建方式 通过new关键字来构建 1String s = new String(&quot;abc&quot;); 通过这个步骤,可能创建一个或两个对象. ①通过new关键字在堆里面创建了一个字符串对象”abc” ②同时查看”串池”里面有没有”abc”,如果没有,还需要在”串池”中再创建一个”abc”对象. 直接通过”串池”/“字符串常量池”的方法来构建 123String s2 = &quot;abc&quot;;String s3 = &quot;abc&quot;;System.out.println(s1 == s2); 构建s2这个字符串时,会在”串池”中创建一个”abc”对象,然后将地址给s2,构建s3字符串时,发现串池中已经有了”abc”对象,则直接将”abc”的地址返回给s3,所以上面判断的结果为true. 串池的特点:利用串池创建对象时优先到串池中查找是否已经存在该对象,如果有则直接返回地址,如果没有则在串池中创建对象. 拼接字符串的拼接使用的是”+”,它的拼接效率非常低 测试”+”和StringBuilder的append耗费时间的对比 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.day09;/** * @Author liuWenXiu * @Date 2021/7/27 17:45 * @description */public class StringPlusDemo &#123; public static void main(String[] args) &#123; test01(); test02(); &#125; public static void test01()&#123; // 获取当前时间的毫秒数 long t1 = System.currentTimeMillis(); String str = &quot;&quot;; for (int i = 0; i &lt; 100000; i++) &#123; str += i; &#125; // 获取拼接之后的时间的毫秒数 long t2 = System.currentTimeMillis(); System.out.println(&quot;str拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125; public static void test02()&#123; StringBuilder builder = new StringBuilder(); // 获取当前时间的毫秒数 long t1 = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; builder.append(i); //StringBuilder利用append()方法进行拼接 &#125; // 获取拼接之后的时间的毫秒数 long t2 = System.currentTimeMillis(); System.out.println(&quot;StringBuilder拼接时间:&quot;+(t2-t1)+&quot;ms&quot;); &#125; &#125; 123结果str拼接时间:39618msStringBuilder拼接时间:3ms 对比发现”+”的效率特别低. 拼接效率低的原因 “+”底层实现时每次拼接都会创建一个StringBuilder对象,每次创建需要耗费大量的时间. “+”底层仍然是调用StringBuilder的append方法. 关于字符串的测试12String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;); 1&gt; javap -c HelloStr 1234567891011121314151617181920212223242526272829303132public class HelloStr &#123; public HelloStr(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String abc 2: astore_1 3: new #3 // class java/lang/String 6: dup 7: ldc #4 // String def 9: invokespecial #5 // Method java/lang/String.&quot;&lt;init&gt;&quot;: //(Ljava/lang/String;)V 12: astore_2 13: new #6 // class java/lang/StringBuilder //字符串每次拼接+,都会产生一个新的StringBuilder对象 16: dup 17: invokespecial #7 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V //StringBuilder builder = new StringBuilder(); 20: aload_1 21: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; //字符串的+,底层仍然是去调用StringBuilder类中提供的append方法 24: aload_2 25: invokevirtual #8 // Method java/lang/StringBuilder.append: //(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #9 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_1 32: return&#125; 在这个代码中,新创建的字符串是”def”,串池中没有,所以要新建,并且是#4.在代码中使用了”+”,对应上面的第13行,创建了StringBuilder对象,在17行进行初始化,21行调用StringBuilder的append方法实现字符串拼接. 比较 s1指向的是”abc”在堆中的地址,s2指向的是”abc”在串池中的地址. intern()强制让s1指向串池中的对象 1234String s1 = new String(&quot;abc&quot;);String s2 = &quot;abc&quot;;System.out.println(s1 == s2); //falseSystem.out.println(s1.intern() == s2); //true s3是一个变量,所以在拼接时,会创建StringBuilder对象,拼接后的结果是String对象,放在堆中,s5则是常量,放在串池中,因此不相等. 12345String s3 = &quot;b&quot;;String s4 = &quot;a&quot; + s3;String s5 = &quot;a&quot; + &quot;b&quot;;System.out.println(s4 == s5); //falseSystem.out.println(s4.intern() == s5); //true s6被final修饰,表示一个常量,所以结果和s5是一致的,都是变量池中的”ab” 123final String s6 = &quot;b&quot;;String s7 = &quot;a&quot; + s6;System.out.println(s5 == s7); //true 这个应该是最容易理解的,每次都新建了一个对象,这个对象和它的值是没有关系的,所以是false. 而**x1.equals(x2)**是用来判断两个字符串值是否相等. 1234String x1 = new String(&quot;abc&quot;);String x2 = new String(&quot;abc&quot;);System.out.println(x1 == x2); //falseSystem.out.println(x1.equals(x2)); //true 常用方法 方法 解释 str.charAt(index); 获取字符串中下标为index的字符 str.length 获取字符串的长度 str.concat(str1) 在原来字符串str的末尾添加新的字符串str1 str.contains(s) 判断字符串str中是否包含子串s str.endsWith(s) 判断字符串str是否以s字符串为结尾 str.startsWith(s) 判断字符串str是否以s字符串为开头 str.equals(str1) 判断字符串str与字符串str1的值是否相等 str.equalsIgnoreCase(str1) 判断字符串str与字符串str1的值是否相等[忽略大小写] str.toUpperCase() 将字符串str中的字符转换为大写 str.toLowerCase() 将字符串str中的字符转换为小写 str.indexOf(s) 返回字符串str中指定字符串s第一次出现的索引 str.lastIndexOf(s) 返回字符串str中指定字符串s最后一次出现的索引 str.isEmpty() 判断字符串是否为空 str.replace(s1,s2) 将字符串str中的所有s1字符串替换为s2字符串 String[] arr = str.split(i) 将字符串str按字符i分割成一个String数组 char[] arr = str.toCharArray() 将字符串转换为字符类型数组 str.substring(a,b) 截取字符串str中下标a到b-1的字符串[a,b) str.substring(a) 截取字符串str中下标a到最后一个字符 str.trim() 去除字符串str左右两边的空格 String s = String.valueOf(n) 将一个整型数n转换成String类型 StringBuilderjava.lang.StringBuilder - 一个可变的字符串 - final修饰,它是性能最高的,默认的容量16,线程不安全 构造方法 1StringBuilder s = new StringBuilder(); 1StringBuilder s2 = new StringBuilder(String str); 扩容机制研究append方法 - 底层代码 每次扩容都为原来长度*2+2 常用方法 方法 解释 str.delete(a,b) 删除字符串str中[a,b)的字符串 str.deleteCharAt(index) 删除字符串str下标为index的字符 str.insert(index,str1) 在字符串str指定下标index位置插入字符串str1 str.reverse() 将字符串str进行反转 注意:StringBuilder是可变的,所以在调用上述方法时不需要进行重新赋值也会改变. 总结类型转换 StringBuilder-&gt;String类型 java.lang.StringBuilder中提供的String toString(); java.lang.String类中提供的构造方法String(StringBuilder builder); java.lang.String类中提供的static String valueOf(Object obj); 面向父类编程 String-&gt;StringBuilder类型 java.lang.StringBuilder中提供的构造StringBuilder(String val); String,StringBuilder,StringBuffer的区别 三者之间都是使用final修饰的,都是不可被继承的,jdk处于安全角度考虑的 - 共同点 不同点 2-1. String它是不可变的字符串,线程安全的.比较耗系统资源和内存的.性能是三个当中最低的. 2-2. StringBuilder可变的字符串 - 线程不安全的,效率是最高的. 2-3. StringBuffer可变的字符串 - 线程安全的.效率低于StringBuilder,但是高于String 方面 区别 可变与不可变 String类是不可变类,StringBuffer和StringBuilder是可变类 线程是否安全 String线程安全,StringBuffer线程安全,StringBuilder线程不安全 效率 String&lt;StringBuffer&lt;StringBuilder","categories":[{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://beautifulboyy/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"贪吃蛇的简单实现","slug":"java-project01","date":"2021-07-30T07:06:08.000Z","updated":"2021-08-01T10:45:26.578Z","comments":true,"path":"2021/07/30/java-project01/","link":"","permalink":"http://beautifulboyy/2021/07/30/java-project01/","excerpt":"","text":"贪吃蛇的简单实现 123456789101112131415161718思路:Point实体类,用于记录点对象.Snake实体类:用于记录这条蛇 定义四个静态常量用于记录蛇头前进的方向[增加代码可读性] 定义一个集合来存储蛇身体的每一个点对象,因为LinkedList集合可以快速找到头节点和尾节点,所以采用LinkedList集合. 定义一个属性,用来记录这个蛇下一次要向哪个方向行动[上下左右]. contains(x,y)方法:判断蛇的身体是否包含(x,y) judgeStep(int dir)方法:判断用户的输入方向是否正确,如果不正确[蛇下一次前进的方向不能与上一次前进的方向相反]抛出异常,正确的话为属性的方向进行赋值.SnakeGames实体类:用于实现这个游戏 定义两个静态常量属性表示游戏边界. 定义一个集合属性来存储食物的坐标,因为坐标是不可重复的,所以用Set集合. 定义一个Snake对象属性. init方法():随机生成食物的点 构造方法:调用init方法初始化集合属性,同时初始化Snake属性 step()方法:实现真正的前进功能.首先要获取蛇的头结点点对象,然后根据方向获得下一个要去的点的位置.判断下一个位置是不是合理的,如果这个位置是墙,则游戏结束,否则将这个位置设置成头结点,再判断这个节点是不是食物,如果是食物就不需要改变了,如果不是食物还需要删除蛇的尾节点. start方法():打印游戏界面,包括判断什么时候打印*[墙],0[食物],#[蛇身]StartGames类:测试类 主方法中接收用户输入并且调用SnakeGames中的start方法. Point实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package day11.snake;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/30 18:48 * @description */public class Point &#123; private int x; private int y; public Point() &#123; &#125; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Point point = (Point) o; return x == point.x &amp;&amp; y == point.y; &#125; @Override public int hashCode() &#123; return Objects.hash(x, y); &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Point&#123;&quot;); sb.append(&quot;x=&quot;).append(x); sb.append(&quot;, y=&quot;).append(y); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; 泪目了!!!!忘记重写equals方法,找了半个多小时问题出在哪里,心痛. Snake实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package day11.snake;import java.util.LinkedList;/** * @Author liuWenXiu * @Date 2021/7/30 18:50 * @description 蛇 - 实体类 */public class Snake &#123; public static final int UP = -1; public static final int DOWN = 1; public static final int LEFT = -2; public static final int RIGHT = 2; private LinkedList&lt;Point&gt; snakes = new LinkedList&lt;&gt;(); private int dir; public Snake() &#123; snakes.add(new Point(5,8)); snakes.add(new Point(5,9)); snakes.add(new Point(5,10)); snakes.add(new Point(5,11)); dir = LEFT; &#125; public LinkedList&lt;Point&gt; getSnake() &#123; return snakes; &#125; public void setSnake(LinkedList&lt;Point&gt; snake) &#123; this.snakes = snake; &#125; public int getDir() &#123; return dir; &#125; public void setDir(int dir) &#123; this.dir = dir; &#125; /** * 判断LinkedList集合中是否包含(x,y)点对应的Point对象 * @param x * @param y * @return */ public boolean contains(int x,int y)&#123; return this.snakes.contains(new Point(x,y)); &#125; /** * 判断用户输入的方向是否合法 * @param dir */ public void judgeStep(int dir)&#123; if(this.dir + dir == 0)&#123; // 相加等于0表示前一次的方向和下一次的正好相反 // 抛出异常 throw new RuntimeException(&quot;对不起,方向相反,游戏结束.&quot;); &#125; // 否则给dir赋值 this.dir = dir; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Snake&#123;&quot;); sb.append(&quot;snake=&quot;).append(snakes); sb.append(&quot;, dir=&quot;).append(dir); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; SnakeGames实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package day11.snake;import java.util.HashSet;import java.util.LinkedList;import java.util.Set;/** * @Author liuWenXiu * @Date 2021/7/30 18:55 * @description 游戏实体类 */public class SnakeGames &#123; // 游戏的边界 public static final int ROWS = 20; public static final int COLS = 20; // 存储食物坐标的集合 private Set&lt;Point&gt; foods = new HashSet&lt;&gt;(); private Snake snake; public SnakeGames()&#123; snake = new Snake(); init(5); &#125; /** * 初始化set集合 * @param n 食物的个数 */ public void init(int n)&#123; while (true)&#123; // 随机数 int x = (int) (Math.random()*(ROWS-2)+1); int y = (int) (Math.random()*(COLS-2)+1); foods.add(new Point(x,y)); // 如果食物的坐标在蛇身上也是不可以的. if(snake.contains(x,y))&#123; continue; &#125; if(foods.size()==n) return; &#125; &#125; public void step(int dir)&#123; snake.judgeStep(dir); //1.获取蛇的头结点 Point header = snake.getSnake().getFirst(); int x = header.getX(); int y = header.getY(); //2.根据方向获得下一个点对象的坐标 switch (snake.getDir())&#123; case Snake.UP: x--; break; case Snake.DOWN: x++; break; case Snake.LEFT: y--; break; case Snake.RIGHT: y++; break; &#125; // 3.判断坐标是否合法 if(x==0 || y==0 || x==ROWS-1 || y==COLS-1) throw new RuntimeException(&quot;对不起,撞墙了,游戏结束&quot;); // 4.创建新的点对象 Point p = new Point(x,y); // 5.将新的点对象设置为snake的头结点 snake.getSnake().addFirst(p); // 6.判断吃掉的这个是不是食物 if(foods.remove(p))&#123; // 如果可以删除,则表示吃的是食物 return; &#125; // 如果不能删除,表示吃的不是食物,需要将蛇的尾节点去掉. snake.getSnake().removeLast(); &#125; public void start()&#123; for (int i = 0; i &lt; ROWS ; i++) &#123; for (int j = 0; j &lt; COLS ; j++) &#123; if(i==0 || j==0 || i==ROWS-1 || j==COLS-1)&#123; // 打印游戏的边界 System.out.printf(&quot;%2s&quot;,&quot;*&quot;); &#125;else if(snake.contains(i,j))&#123; // 打印蛇的身体 System.out.printf(&quot;%2s&quot;,&quot;#&quot;); &#125;else if(foods.contains(new Point(i,j)))&#123; // 打印食物 System.out.printf(&quot;%2s&quot;,&quot;0&quot;); &#125;else &#123; // 打印空白 System.out.printf(&quot;%2s&quot;,&quot;&quot;); &#125; &#125; System.out.println(); &#125; &#125;&#125; StartGames123456789101112131415161718192021222324252627282930313233343536373839package day11.snake;import java.util.Scanner;/** * @Author liuWenXiu * @Date 2021/7/30 19:21 * @description 测试类 */public class StartGames &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); SnakeGames games = new SnakeGames(); while (true)&#123; games.start(); System.out.print(&quot;上w下s左a右d-&gt;&quot;); String dir = sc.nextLine(); switch (dir)&#123; case &quot;w&quot;: games.step(Snake.UP); break; case &quot;s&quot;: games.step(Snake.DOWN); break; case &quot;a&quot;: games.step(Snake.LEFT); break; case &quot;d&quot;: games.step(Snake.RIGHT); break; default: System.out.println(&quot;输入错误,请重试!&quot;); break; &#125; &#125; &#125;&#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://beautifulboyy/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"java","slug":"java","permalink":"http://beautifulboyy/tags/java/"}]},{"title":"集合框架","slug":"java04","date":"2021-07-29T02:36:18.000Z","updated":"2021-08-02T02:14:22.198Z","comments":true,"path":"2021/07/29/java04/","link":"","permalink":"http://beautifulboyy/2021/07/29/java04/","excerpt":"","text":"集合框架内存中的”容器对象” - 存储数据的,开发中来替代数组的使用. 结构123456789101112131415api:java.utilCollection[I] - List[I] - 有序可重复 - ArrayList[C] - LinkedList[C] - Vector[C] - Set[I] - 无序不可重复 - HashSet[C] - SortedSet[I] - TreeSet[C]Map[I] - HashMap[C] - key-value的形式存储数据的,针对key是无序不可重复的. - Hashtable[C] - Properteis[C] - 属性文件在内存中的映射对象 Collection[I] boolean add(E e);//向容器中添加一个元素 void clear();//清空容器 boolean contains(Object o);//判断容器中是否包含某个对象 boolean isEmpty();//如果集合中没有数据,集合大小为0,返回true Iterator iterator();// 获取集合对象的迭代器 boolean remove(Object obj);//删除集合容器中第一次出现的这个对象.只能删除1个 int size();//返回集合中的数据的个数 - 集合的大小 List[I]特点 - 有序并且是可以重复的. E get(int index);//根据下标去取.集合下标边界[0,集合.size()-1] int indexOf(Object obj);//返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。 E remove(int index);//根据下标删除,并且返回刚刚删除的那个元素 Object[] toArray();//将集合转换成数组. ArrayList[C]特点:有序可重复的,底层数据结构就是一个”动态增长”的数组. 优点:因为数组是一个有序的序列,所以它可以通过下标直接取值 - 查询效率高. 缺点:增删效率会低. 分析源码 123456789101112private static final int DEFAULT_CAPACITY = 10; //默认的初始容量private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //一个空数组transient Object[] elementData; // 真正存储数据的数组private int size; // 集合的大小// 构造public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; //构造时初始化elementData &#125; add方法 123456789101112public boolean add(E e) &#123; //第一次:size=0; 执行ensureCapacityInternal(1); //第二次:size=1; 执行ensureCapacityInternal(2); //第十一次:size=10; 执行ensureCapacityInternal(11); ensureCapacityInternal(size + 1); //第一次:elementData[0++] = e; size=1 //第二次:elementData[1++] = e; size=2 //第十一次:elementData[10++] = e; size=11 elementData[size++] = e; return true;&#125; ensureCapacityInternal(); 123456789101112131415private void ensureCapacityInternal(int minCapacity) &#123; //第一次:在构造时进行了初始化,所以if之后的判断为true //第二次:在grow方法中elementData已经重新指向了新的数组,所以结果是false,跳过该if //第十一次:仍旧是跳过 //这个if只有在第一次add的时候是true if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 第一次:minCapacity = Math.max(10,1); =&gt; minCapacity=10 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //第一次:ensureExplicitCapacity(10); //第二次:ensureExplicitCapacity(2); //第十一次:ensureExplicitCapacity(11); ensureExplicitCapacity(minCapacity);&#125; ensureExplicitCapacity(minCapacity); 1234567891011private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 第一次:minCapacity = 10,elementData.length=0;10-0&gt;0的结果是true // 第二次:minCapacity = 2,elementData.length=10;2-10&gt;0的结果是false,跳过该if,返回add方法 // 第十一次:minCapacity = 11,elementData.length=10;11-0&gt;0的结果是true if (minCapacity - elementData.length &gt; 0) // 第一次:执行grow(10); // 第十一次:执行grow(11); grow(minCapacity);&#125; grow(minCapacity);每次扩容都增加原来长度的一半 12345678910111213141516private void grow(int minCapacity) &#123; // 第一次:oldCapacity=0,newCapacity=0; // 第十一次:oldCapacity=10,newCapacity=15; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //1.5倍 // 第一次:0-10&lt;0 true // 第十一次:15-11&lt;0 false if (newCapacity - minCapacity &lt; 0) // 第一次:newCapacity = 10; newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 第一次:进行扩容,新的数组长度为newCapacity=10; // 第十一次:进行扩容,新的数组长度为newCapacity=15; elementData = Arrays.copyOf(elementData, newCapacity);&#125; 集合的遍历12345ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;Hello&quot;);list.add(&quot;Java&quot;);list.add(&quot;oracle&quot;);list.add(&quot;php&quot;); 直接输出 123for (int i = 0; i &lt; list.size(); i++) &#123; System.out.print(list.get(i)+&quot;\\t&quot;);&#125; 增强for循环 - 只读 1只读的循环.如果在循环的过程中进行了remove操作 - 抛出java.util.ConcurrentModificationException并发修改异常 123for (String s : list) &#123; System.out.print(s+&quot;\\t&quot;);&#125; 迭代器 - 很重要 12345Iterator&lt;String&gt; iter = list.iterator();while(iter.hasNext())&#123; String s = iter.next(); System.out.print(s+&quot;\\t&quot;);&#125; 匿名内部类 123456list.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.print(s+&quot;\\t&quot;); &#125;&#125;); lambda表达式 1list.forEach(s -&gt; System.out.print(s+&quot;\\t&quot;)); LinkedList的遍历方法和ArrayList一样. 常用方法 方法 含义 list.add() 添加元素 list.clear() 清空元素 list.remove(index) 按下标删除集合中的元素 list.remove(o) 按元素删除集合中的元素 list.isEmpty() 判断集合是否为空 list.contains(o) 判断集合中是否包含某个元素 list.indexOf(o) 返回某个元素在集合中第一次出现的位置,如果不存在返回-1 list.size() 获取集合的大小 list.get(index) 获取集合中指定下标的值 适用于ArrayList和LinkedList. LinkedList[C]有序的序列,底层的数据双向链表,jdk6以及之前是双向循环链表 链表结构的特点:查询效率很低,每次都会从头节点开始遍历.但是增删效率高,只会涉及到相邻节点的移动. 链表结构相对于数组这种数据结构,需要占用更多的内存.每个节点除了保存具体的数据,还需要保存相邻节点的地址. 单向链表 head - 头节点 tail - 尾节点 element - 节点中真正的保存的数据 next - 下一个节点的地址 单向循环链表 尾节点的next又指向了头节点. 双向链表 - LinkedList底层数据结构 增加了一个pre - 保存的是上一个节点的地址. 双向循环链表 剖析源码1234567891011121314151617//节点类 -&gt; 有三个属性:分别元素,上一个节点对象以及下一个节点对象private static class Node&lt;E&gt; &#123; E item; //元素 Node&lt;E&gt; next; //next的值是下一个节点对象的地址 Node&lt;E&gt; prev; //prev的值是上一个节点对象的地址 // 构造方法 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;transient Node&lt;E&gt; first; //定义了头节点transient Node&lt;E&gt; last; //定义了尾节点 add方法1234public boolean add(E e) &#123; linkLast(e); return true;&#125; 12345678910111213141516void linkLast(E e) &#123; //1.创建节点对象l指向尾节点 final Node&lt;E&gt; l = last; //2.创建节点对象newNode,这个是新创建的节点对象 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //3.将尾节点指向新的节点对象[每次创建新的节点对象,尾节点都变成新的对象] last = newNode; if (l == null) //如果l为空-&gt;之前的尾节点为空-&gt;是第一次创建-&gt;表示链表之前没有任何的元素 first = newNode; // 于是把新的节点作为头节点 else // 如果l不为空-&gt;表示链表不为空,则将之前链表中的尾节点的next指向新的节点 l.next = newNode; size++; //长度++ modCount++;&#125; get方法1234public E get(int index) &#123; checkElementIndex(index); //用于检测元素下标-&gt;可以暂时不用在意 return node(index).item;&#125; 1234567891011121314151617181920212223242526// 获取指定下标的节点Node&lt;E&gt; node(int index) &#123; // size&gt;&gt;1 的含义就是size/2 // 判断index是在[0,size/2)之间还是在[size/2,size)之间 if (index &lt; (size &gt;&gt; 1)) &#123; // 如果index在[0,size/2)之间,则从头节点开始查询 Node&lt;E&gt; x = first; // 获取头节点 // 查找的步骤是从头节点开始一个一个向后取 for (int i = 0; i &lt; index; i++) x = x.next; //假设index=3; //i=0时,x = first.next -&gt; 第二个节点 i++ //i=1时,x -&gt; 第三个节点 i++ //i=2时,x -&gt; 第四个节点 i++(不符合条件,退出) return x; //这时候就返回第四个节点 &#125; else &#123; // 如果index在[size/2,size)之间,则从尾节点开始查询 Node&lt;E&gt; x = last; // 获取尾节点 for (int i = size - 1; i &gt; index; i--) x = x.prev; // 假设index = 7,size = 10 // i = 9时,x = last.prev -&gt; 倒数第二个节点(第九个节点) i-- // i = 8时,x -&gt; 倒数第三个节点(第八个节点) i-- 此时i=7,不符合循环条件,退出循环 return x; //返回第八个节点 &#125;&#125; remove方法123456public E remove(int index) &#123; checkElementIndex(index); // 这里首先node(index)找到下标对应的Node对象 // 然后通过unlink(Node对象)删除对象 return unlink(node(index));&#125; 1234567891011121314151617181920212223242526E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 常用方法 方法 含义 list.addFirst(o) 在头部添加某个元素 list.addLast(o) 在尾部添加某个元素 list.push(o) 把元素压入栈顶[即添加到头部] list.pop() 弹出栈顶元素并返回. list.removeFirst() 删除第一个元素 list.removeLast() 删除最后一个元素 list.getFirst() 获取第一个元素 list.getLast() 获取最后一个元素 offer,offerFirst,offerLast方法和add方法一样. 一个小题目括号匹配,如果是{[()]},{}等匹配成功,{[)}匹配失败. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package day11.homework;import java.util.LinkedList;/** * @Author liuWenXiu * @Date 2021/7/29 10:57 * @description 括号匹配 */public class BracketMatching &#123; /** * 括号的匹配 * @param c1 * @param c2 * @return */ public static boolean match(char c1,char c2)&#123; boolean flag = false; if(c1 == &#x27;&#123;&#x27; &amp;&amp; c2 == &#x27;&#125;&#x27;) flag = true; else if(c1 == &#x27;[&#x27; &amp;&amp; c2 == &#x27;]&#x27;) flag = true; else if(c1 == &#x27;(&#x27; &amp;&amp; c2 == &#x27;)&#x27;) flag = true; return flag; &#125; /** * * @param str * @return */ public static boolean bracketMatching(String str)&#123; char[] arr = str.toCharArray(); LinkedList&lt;Character&gt; list = new LinkedList&lt;&gt;(); list.push(arr[0]); for (int i = 1; i &lt; arr.length; i++) &#123; //!!!!!!!!这里真的要注意一下!!!!!!!!!!!!!-&gt;没有考虑到这种情况 // 为了避免在栈顶已经没有元素的情况下还去获取栈顶元素,非空判断 if(list.isEmpty())&#123; list.push(arr[i]); continue; &#125; if(match(list.getFirst(),arr[i]))&#123; // 匹配就出栈 list.pop(); &#125;else&#123; // 不匹配就入栈 list.push(arr[i]); &#125; &#125; return list.isEmpty(); &#125; public static void main(String[] args) &#123; String str = &quot;&#123;&#125;[]()&quot;; System.out.println(bracketMatching(str)); &#125;&#125; 这里一定要注意在取出栈顶元素的时候,首先需要判断这个集合中是否还有元素. Map[I]HashMap[C]数据存储的形式是key-value,针对key是无序不可重复的. jdk8.x之前,底层的数据结构是桶数组+链表 jd8.0开始,底层的数据结构是桶数组+链表+红黑树 桶(哈希桶)数组 - 里面的元素放在数组的这个位置是通过一个哈希算法计算得到的. 图示 剖析put方法 put方法 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; putVal方法 12345678910111213141516171819202122232425262728293031323334353637383940414243final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 常用方法 方法 含义 map.size() 获取集合大小 map.put(k,v) 添加元素,键为k,值为v map.get(k) 获取键key对应的值 map.clear() 清空集合 map.isEmpty() 判断集合是否为空 map.containsKey(k) 判断集合中是否包含某个key map.keySet() 将map集合中所有的key全部取出来放到一个set集合中 map.entrySet() 将map集合中的每对key-value封装到内置的Entry对象中 map.containsValue(v) 判断集合中是否包含某个value Map集合的迭代方式1234567891011121314151617181920212223// 第一种方式:将map集合中所有的key全部取出来放入到set集合中Set&lt;Integer&gt; sets = maps.keySet();// 遍历set集合Iterator&lt;Integer&gt; inter = sets.iterator();while(inter.hasNext())&#123; Integer key = inter.next(); String value = maps.get(key); System.out.println(key+&quot;:&quot;+value);&#125;System.out.println();// 第二种方式// 将map集合中的每对key-value封装到内置的entry对象中// 然后将每个entry对象放到set集合中Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = maps.entrySet();Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iter = entries.iterator();while(iter.hasNext())&#123; Map.Entry&lt;Integer,String&gt; entry = iter.next(); Integer key = entry.getKey(); String value = entry.getValue(); System.out.println(key+&quot;-&gt;&quot;+value);&#125; HashSetSet[I]接口下的实现类 - 存储的数据是无序,不可重复的. 添加数据到容器的原理 当把对象添加到容器中之前,会调用对象的hashCode方法,得到一个哈希值. 如果这个哈希值在这之前没有出现过,说明这个位置没有被占用,那么就可以直接将这个对象放入到这个容器中的这个位置. 如果这个哈希值在这之前出现过了,产生了哈希碰撞或哈希冲突.但这个时候还不能确定哈希碰撞的两个对象是同一个对象 继续调用对象的equals方法,如果返回true,说明是同一个对象,则拒绝添加. 底层数据结构桶数组 + 链表 + 红黑树 查看HashSet源码 Set sets = new HashSet&lt;&gt;(); 1234public HashSet() &#123;//HashSet的底层是HashMapmap = new HashMap&lt;&gt;();&#125; add方法底层 123456789private static final Object PRESENT = new Object();//此处的e是添加到容器中的对象public boolean add(E e) &#123;//实际上还是在调用map的put方法//HashSet中添加的对象是作为了Map集合的key//Map的key具有什么特点 = HashSet中的数据有何特点.return map.put(e, PRESENT)==null;&#125; TreeSetSet[I] - SortedSet[I] - TreeSet[C] - 不可重复的,但是可以排序. 特点TreeSet在添加元素时,假设排序的规则定好,比如根据price进行排序,那么被添加到容器的这些对象的price就不能一样,一旦存在price相同的对象,就会拒绝添加. 123456789101112131415161718public class ComparatorFactory &#123; public static final int ISBN = 0; public static final int PRICE = 1; public static Comparator&lt;Book&gt; getInstance(int type)&#123; Comparator&lt;Book&gt; c = null; switch (type)&#123; case ISBN: c = (b1,b2)-&gt;b2.getIsbn().compareTo(b1.getIsbn()); break; case PRICE: c = (b1,b2)-&gt; (int) (b2.getPrice()-b1.getPrice()); break; &#125; return c; &#125;&#125; 123456789101112131415// 获取按照price进行排序的比较器Comparator c = CompareFactoryDemo.getInstance(CompareFactoryDemo.PRICE);TreeSet&lt;Book&gt; books = new TreeSet&lt;&gt;(c); //注意一下这里的构造Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d);Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d);Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d);Book b4 = new Book(2,&quot;1004&quot;,&quot;python&quot;,300.0d);books.add(b1);books.add(b2);books.add(b3);books.add(b4);books.forEach(e-&gt; System.out.println(e)); 1234结果Book&#123;id=2, isbn=&#x27;1004&#x27;, name=&#x27;python&#x27;, price=300.0&#125;Book&#123;id=2, isbn=&#x27;1002&#x27;, name=&#x27;java&#x27;, price=200.0&#125;Book&#123;id=1, isbn=&#x27;1001&#x27;, name=&#x27;java&#x27;, price=100.0&#125; 如果构造中没有指明Comparator,就会报java.lang.ClassCastException异常. 排序比较器接口Comparatorjdk8.0开始,在List接口中已经定义了排序的方法 void sort(Comparator&lt;? superE&gt; c) Book实体类 - 省略构造,getter/setter方法/toString方法 123456public class Book &#123; private int id; private String isBn; private String name; private double price;&#125; 测试类 12345678910Book b1 = new Book(1,&quot;1001&quot;,&quot;java&quot;,100.0d);Book b2 = new Book(2,&quot;1002&quot;,&quot;java&quot;,200.0d);Book b3 = new Book(3,&quot;1003&quot;,&quot;java&quot;,200.0d);Book b4 = new Book(4,&quot;1004&quot;,&quot;python&quot;,300.0d);List&lt;Book&gt; bookList = new ArrayList&lt;&gt;();bookList.add(b1);bookList.add(b2);bookList.add(b3);bookList.add(b4); 根据价格降序排序,使用匿名内部类方式 12345678910bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; if(o1.getPrice()&gt;o2.getPrice()) return -1; else if(o1.getPrice()&lt;o2.getPrice()) return 1; return 0; &#125;&#125;); 简化一下 123456bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; return (int) o2.getPrice() - o1.getPrice(); &#125;&#125;); 在排序时,如果符合要求则返回-1,不符合就返回1,相等返回0. 根据价格升序排序,使用lambda表达式 1234567bookList.sort((o1,o2) -&gt; &#123; if(o1.getPrice()&gt;o2.getPrice()) return 1; else if(o1.getPrice()&lt;o2.getPrice()) return -1; return 0;&#125;); 简化 1bookList.sort((o1,o2) -&gt; (int) (o1.getPrice()-o2.getPrice())); 根据编号降序排序,使用lambda表达式 1bookList.sort((o1,o2) -&gt; o2.getIsBn().compareTo(o1.getIsBn())); 因为String类中重写了compareTo方法,所以字符串可以通过compareTo进行比较 根据价格升排序,如果价格一样,按照编号升序继续排序,使用匿名内部类. 12345678910bookList.sort(new Comparator&lt;Book&gt;() &#123; @Override public int compare(Book o1, Book o2) &#123; if(o1.getPrice()&gt;o2.getPrice()) return 1; else if(o1.getPrice()&lt;o2.getPrice()) return -1; else return o1.getIsBn().compareTo(o2.getIsBn()); &#125;&#125;); Collectionsjava.util.Collections[C] - 集合工具类 面试题 - Collection和Collections有什么区别? Teacher类 - 省略构造,getter/setter方法/toString方法 12345public class Teacher &#123; private int id; private String name; private int age;&#125; Teacher测试类 12345678910Teacher t1 = new Teacher(1,&quot;tom&quot;,23);Teacher t2 = new Teacher(2,&quot;jack&quot;,25);Teacher t3 = new Teacher(3,&quot;james&quot;,18);Teacher t4 = new Teacher(4,&quot;rose&quot;,17);List&lt;Teacher&gt; list = new ArrayList&lt;&gt;();list.add(t1);list.add(t2);list.add(t3);list.add(t4); 要求:按照老师的年龄增序排序 static void sort(List list, Comparator&lt;? super T&gt; c)根据指定的比较器引起的顺序对指定的列表进行排序。 123456789// 匿名内部类Collections.sort(list, new Comparator&lt;Teacher&gt;() &#123; @Override public int compare(Teacher o1, Teacher o2) &#123; return o1.getAge()-o2.getAge(); &#125;&#125;);// lambda表达式Collections.sort(list,(o1,o2) -&gt; o1.getAge()-o2.getAge()); static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List list) ;//集合中的对象必须要实现java.lang.Comparable可比较接口 修改Teacher类,实现Comparable接口,并重写compareTo方法 12345678910public class Teacher implements Comparable&lt;Teacher&gt;&#123; private int id; private String name; private int age; @Override public int compareTo(Teacher o) &#123; return this.getAge()-o.getAge(); &#125;&#125; 测试类 1Collections.sort(list); 如果在Teacher类中没有实现接口,这里的语法就会报错. 面试题HashMap 和 HashTable 区别 HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。主要区别如下: HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。 HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。 HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。 HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。 Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。 ArrayList和LinkedList区别 ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据 List和Set区别 两个接口都是继承自Collection，是常用来存放数据项的集合，主要区别如下： List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。 List可以通过下标来访问，而Set不能。 HashSet和HashMap区别 HashSet的底层是HashMap HashMap HashSet HashMap实现了Map接口 HashSet实现了Set接口 HashMap储存键值对 HashSet仅仅存储对象 使用put()方法将元素放入map中 使用add()方法将元素放入set中 HashMap中使用键对象来计算hashcode值 HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false HashMap比较快，因为是使用唯一的键来获取对象 HashSet较HashMap来说比较慢 ArrayList和HashSet区别 1.HashSet 是不重复的 而且是无序的! ​ 唯一性保证. 重复对象equals方法返回为true ，重复对象hashCode方法返回相同的整数 ​ HashSet其实就是一个HashMap,只是你只能通过Set接口操作这个HashMap的key部分, 2.ArrayList是可重复的 有序的 ​ 特点：查询效率高，增删效率低 轻量级 线程不安全。 arraylist：在数据的插入和删除方面速度不佳，但是在随意提取方面较快 HashSet和TreeSet区别 一、HashSet HashSet内部的数据结构是哈希表，是线程不安全的。 HashSet当中，保证集合中元素是唯一的方法。 通过对象的hashCode和equals方法来完成对象唯一性的判断。 假如，对象的hashCode值是一样的，那么就要用equals方法进行比较。 假如，结果是true，那么就要视作相同元素，不存。 假如，结果是false，那么就视为不同元素，存储。 注意了，假如，元素要存储到HashCode当中，那么就一定要覆盖hashCode方法以及equals方法。 二、TreeSet TreeSet能够对Set集合当中的元素进行排序，是线程不安全的。 TreeSet当中，判断元素唯一性的方法是依据比较方法的返回结果是否为0，假如是0，那么是相同的元素，不存，假如不是0，那么就是不同的元素，存储。 TreeSet对元素进行排序的方式： 1、元素自身具备比较功能，也就是自然排序，需要实现Comparable接口，并覆盖其compareTo方法。 2、元素自身不具备比较功能，那么就要实现Comparator接口，并覆盖其compare方法。 除此之外，还要注意了，LinkedHashSet是一种有序的Set集合。 也就是其元素的存入和输出的顺序是相同的。 HashMap和TreeMap区别 HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快。而TreeMap的底层是一个Tree结构，所以速度会比较慢。 另外HashMap因为要保存一个Array，所以会造成空间的浪费，而TreeMap只保存要保持的节点，所以占用的空间比较小。 HashMap如果出现hash冲突的话，效率会变差，不过在java 8进行TreeNode转换之后，效率有很大的提升。 TreeMap在添加和删除节点的时候会进行重排序，会对性能有所影响。 ArrayList和Vector区别 Vector是线程安全的，ArrayList不是线程安全的。 ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。","categories":[{"name":"框架","slug":"框架","permalink":"http://beautifulboyy/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"集合框架","slug":"集合框架","permalink":"http://beautifulboyy/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"设计模式","slug":"java-design","date":"2021-07-27T12:46:54.000Z","updated":"2021-08-14T02:40:50.261Z","comments":true,"path":"2021/07/27/java-design/","link":"","permalink":"http://beautifulboyy/2021/07/27/java-design/","excerpt":"","text":"模板方法设计模式抽象类应用 - 模板方法设计模式 模板方法模式很常用,其目的是在一个方法中定义一个算法骨架,而将一些步骤延迟到子类中.模板方法使得子类可以在不改变算法接口的情况下,重新定义算法的某些步骤. 在标准的模板方法模式实现中,主要是使用继承的方式,来让父类在运行期间可以调用到子类的方法. -&gt;处理某个流程的代码已经都具备,但是其中某个节点的代码暂时不能确定.处理步骤在父类中定义好,具体实现延迟到子类中定义 模板类中只负责定义: 需要做的事情 - 不需要具体的实现,具体的实现留给各个子类去实现. 做事情的流程[步骤] 一个小实例,可以参考理解 TemplateDemo.java 1234567891011121314public abstract class TemplateDemo &#123; //规定了需要完成的事情 public abstract void start(); //演员登台 public abstract void play(); //演员表演 public abstract void end(); //落幕 //提供一个不可变的方法,用来控制事情执行的顺序 public final void execute()&#123; this.start(); this.play(); this.end(); &#125;&#125; YueYueImpl.java 1234567891011121314151617181920212223package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:17 * @description 继承TemplateDemo类并且实现里面的抽象方法 */public class YueYueImpl extends TemplateDemo &#123; @Override public void start() &#123; System.out.println(&quot;小岳岳登场!&quot;); &#125; @Override public void play() &#123; System.out.println(&quot;小岳岳讲相声&quot;); &#125; @Override public void end() &#123; System.out.println(&quot;小岳岳离场&quot;); &#125;&#125; DeGangImpl.java 123456789101112131415161718192021222324package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:58 * @description 继承TemplateDemo类并且实现里面的抽象方法 */public class DeGangImpl extends TemplateDemo &#123; @Override public void start() &#123; System.out.println(&quot;郭德纲登场..&quot;); &#125; @Override public void play() &#123; System.out.println(&quot;郭德纲在讲相声&quot;); &#125; @Override public void end() &#123; System.out.println(&quot;郭德纲退场...&quot;); &#125;&#125; TestTemplate 12345678910111213141516171819202122232425262728package tech.aistar.design.template;/** * @Author liuWenXiu * @Date 2021/7/23 10:18 * @description 测试 */public class TestTemplate &#123; public static void main(String[] args) &#123; TemplateDemo t = new YueYueImpl(); //t.execute(); TemplateDemo t2 = new DeGangImpl(); TemplateDemo[] ts = &#123;t,t2&#125;; for (TemplateDemo demo : ts) &#123; demo.execute(); &#125; &#125;&#125;结果:小岳岳登场!小岳岳讲相声小岳岳离场郭德纲登场..郭德纲在讲相声郭德纲退场... 这个就是模板方法设计模式,不管是DeGangImpl还是YueYueImpl都是遵循一个顺序,分别是start()-&gt;play()-&gt;end();但是这些方法的具体实现是在子类中实现的. 模板方法设计模式的优缺点 优点 模板方法提供了一个很好的代码复用平台. 实现了反向控制,通过一个父类调用其子类的操作,通过对子类的具体实现扩展不同的行为,实现了反向控制,符合”开闭原则”. 缺点 每一个不同的实现都需要一个子类来实现,导致类的个数增加,使得系统更加庞大.结合实例来理解,每一个相声演员都需要一个新的子类来实现,这样就会导致类的数量很多. 单例模式如何保证某个类的对象在内存中永远只有一份,某些类的创建和销毁的时间成本比较高,这些类有必要设计成单例的.比如jdbc中的连接池对象[重量级的对象] 饿汉模式 - 多线程安全 私有化构造方法 初始化一个静态变量,该变量就是该类唯一的一个实例. 提供一个公开的静态方法来返回这个实例 123456789public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉模式 - 多线程不安全 私有化构造方法 创建一个静态变量,但不进行初始化,该变量就是该类唯一的实例 提供一个公开的静态方法,在方法中初始化该实例并返回. 1234567891011public static Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null) instance = new Singleton(); return instance; &#125;&#125; 双重检查锁 - 多线程安全 私有化构造方法 创建一个静态变量,但不进行初始化,该变量就是该类唯一的实例 123456789101112131415161718192021222324252627public static Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; //因为本身&quot;锁&quot;资源就是一个比较昂贵的资源,为了避免跑得慢的线程去抢这个把锁,所以此处也要进行非空判断. if(instance == null)&#123; //跑得快的线程都会进入此处A,B //A,B线程就会去争抢锁资源,谁抢到锁资源,谁就会进入 //同步代码块去执行里面的代码 //假设A线程抢到了,B就会在等待 synchronized (Singleton03.class)&#123; //A进入判断instance==null //只要抢到&quot;锁&quot;的线程,如果此处没有非null判断 //那么进入到这的线程都会去执行instance = new Singleton03(); if(instance == null)&#123; //由A线程进行实例的初始化 //A继续执行,等A执行完毕之后,那么A就会释放锁资源 //其他线程继续争抢锁资源. instance = new Singleton03(); &#125; &#125; &#125; return instance;&#125; volatile 可见性[忽略] 禁止JVM的指令重排 123456789101112int i = 10; //这是一个原子性的操作Student s = new Student(); //这不是一个原则性的操作 /*它需要经过三个过程:①给s对象分配内存空间②调用构造块,执行构造函数 - 初始化③将引用s指向内存中的那个对象但是JVM内部会对这些指令进行一个优化操作.本来顺序是①-&gt;②-&gt;③,经过JVM指令重排之后,顺序有可能变成①-&gt;③-&gt;②*/ 12345678910111213public class Singleton&#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; &#125;&#125; 工厂模式简单工厂模式它违背了”开闭原则” 123456789101112131415public class interface Sender&#123; void send();&#125;public class QQSender implements Sender&#123; @override public void send()&#123; System.out.println(&quot;QQSend...&quot;) &#125;&#125; public class WXSender implements Sender&#123; @override public void send()&#123; System.out.println(&quot;WXSend...&quot;) &#125;&#125; 简单工厂模式必须要脱手写出来 123456789101112131415161718public class ProductFactory&#123; public static final int QQ = 1; public static final int WX = 2; public static Sender getInstance(int type)&#123; swtich(type)&#123; case 1: return new QQSender(); break; case 2: return new WXSender(); break; default: System.out.println(&quot;输入错误!&quot;); break; &#125; &#125;&#125; 多方法简单工厂 12345678public class ProductFactory&#123; public Sender produceQQ()&#123; return new QQSender(); &#125; public Sender produceWX()&#123; return new WXSender(); &#125;&#125; 静态方法简单工厂12345678public class ProductFactory&#123; public static Sender produceQQ()&#123; return new QQSender(); &#125; public static Sender produceWX()&#123; return new WXSender(); &#125;&#125; 简单工厂优缺点优点： 很明显，简单工厂的特点就是“简单粗暴”，通过一个含参的工厂方法，我们可以实例化任何产品类，上至飞机火箭，下至土豆面条，无所不能。所以简单工厂有一个别名：上帝类。 缺点： 任何”东西“的子类都可以被生产，负担太重。当所要生产产品种类非常多时，工厂方法的代码量可能会很庞大 在遵循开闭原则（对拓展开放，对修改关闭）的条件下，简单工厂对于增加新的产品，无能为力。因为增加新产品只能通过修改工厂方法来实现。 工厂方法模式一个工厂类只负责生产一个产品 123456789101112131415161718192021222324public interface ProductFactory&#123; Sender createSender();&#125;public class QQProductFactory implements PrductFactory&#123; @Override public Sender createSender() &#123; return new QQSender(); &#125;&#125;public class WXProductFactory implements ProductFactory&#123; @Override public Sender createSender() &#123; return new WXSender(); &#125;&#125;public class TestProductFactory &#123; public static void main(String[] args) &#123; Sender qq = new QQProductFactory().createSender(); Sender wx = new WXProductFactory().createSender(); qq.send(); wx.send(); &#125;&#125; 工厂方法模式优缺点优点： 工厂方法模式就很好的减轻了工厂类的负担，把某一类/某一种东西交由一个工厂生产；（对应简单工厂的缺点1） 同时增加某一类”东西“并不需要修改工厂类，只需要添加生产这类”东西“的工厂即可，使得工厂类符合开闭原则。 缺点： 相比简单工厂，实现略复杂。 对于某些可以形成产品族的情况处理比较复杂（相对抽象工厂）。 抽象工厂模式产品族 123456789101112131415161718192021222324252627282930public interface Cpu &#123; void info();&#125;public interface Net &#123; void info();&#125;public class IBMCpu implements Cpu&#123; @Override public void info() &#123; System.out.println(&quot;IBMPCpu...&quot;); &#125;&#125;public class IntelCpu implements Cpu&#123; @Override public void info() &#123; System.out.println(&quot;IntelCpu...&quot;); &#125;&#125;public class InternetNet implements Net&#123; @Override public void info() &#123; System.out.println(&quot;InternetNet...&quot;); &#125;&#125;public class GaoTongNet implements Net&#123; @Override public void info() &#123; System.out.println(&quot;GaoTongNet...&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435public interface ProductFactory &#123; Cpu createCpu(); Net createNet();&#125;public class XiaoMiFactory implements ProductFactory&#123; @Override public Cpu createCpu() &#123; return new IBMCpu(); &#125; @Override public Net createNet() &#123; return new InternetNet(); &#125;&#125;public class PhoneXFactory implements ProductFactory&#123; @Override public Cpu createCpu() &#123; return new IntelCpu(); &#125; @Override public Net createNet() &#123; return new GaoTongNet(); &#125;&#125;public class TestFactory &#123; public static void main(String[] args) &#123; ProductFactory pf = new XiaoMiFactory(); Cpu cpu = pf.createCpu(); Net net = pf.createNet(); cpu.info(); net.info(); &#125;&#125; 反射工厂模式反射工厂既能够保证在新增一个产品的时候,遵守”开闭原则”,又能够保证始终仅仅只有一个工厂类. 基础demo1234567891011121314151617public interface IBaseDao &#123; void add();&#125;public class StudentDaoImpl implements IBaseDao&#123; @Override public void add() &#123; System.out.println(&quot;Student...impl&quot;); &#125;&#125;public class TeacherDaoImpl implements IBaseDao&#123; @Override public void add() &#123; System.out.println(&quot;Teacher...impl&quot;); &#125;&#125; 12345678910111213141516171819202122public enum FactoryNum &#123; STUDENT_DAO(&quot;STUDENT_DAO&quot;), TEACHER_DAO(&quot;TEACHER_DAO&quot;), MASTER_DAO(&quot;MASTER_DAO&quot;); private String sign; FactoryNum() &#123; &#125; FactoryNum(String sign) &#123; this.sign = sign; &#125; public String getSign() &#123; return sign; &#125; public void setSign(String sign) &#123; this.sign = sign; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package tech.aistar.design.factory.reflect;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * @Author liuWenXiu * @Date 2021/8/14 9:25 * @description */public enum PropUtil &#123; INSTANCE; // 定义一个Properties文件 private Properties properties; PropUtil()&#123; // 在构造方法中为properties初始化 properties = new Properties(); // 读取属性文件 // 方法一 //InputStream in = null;// try &#123;// in = new FileInputStream(&quot;src/tech/aistar/design/factory/reflect/bean.properties&quot;);// &#125; catch (FileNotFoundException e) &#123;// e.printStackTrace();// &#125; // 方法二 - 推荐使用的方法 - 硬记下来 // 注意一下方法二和方法一文件路径的区别,一个有src一个没有src InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;tech/aistar/design/factory/reflect/bean.properties&quot;); //System.out.println(in); // 加载属性资源 try &#123; properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 根据key获取值 * @param key * @return */ public String getValue(String key)&#123; // 需要确认properties是否为空 if(properties==null) return null; // properties.getProperty(key) 根据键获取值 return properties.getProperty(key); &#125;&#125; 12345678910111213141516171819202122232425262728package tech.aistar.design.factory.reflect;/** * @Author liuWenXiu * @Date 2021/8/14 9:42 * @description 泛型类 负责根据传入的实现类全限定名返回对应的实例 */public class BaseFactory&lt;T&gt; &#123; public static&lt;T&gt; T getInstance(String type)&#123; T t = null; // 传入的是某个类的全限定名 // 创建类的实例 try &#123; Class&lt;?&gt; c = Class.forName(type); // 反射调用空参构造创建实例 t = (T) c.newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; return t; &#125;&#125; 12STUDENT_DAO=tech.aistar.design.factory.reflect.StudentDaoImplTEACHER_DAO=tech.aistar.design.factory.reflect.TeacherDaoImpl 进阶demoStudentDaoImpl的功能要升级. 创建StudentDaoImpl2 1234567891011121314151617181920212223242526package tech.aistar.design.factory.reflect;/** * @Author liuWenXiu * @Date 2021/8/14 10:17 * @description */public class StudentDaoImpl2 implements IBaseDao&#123; private IBaseDao baseDao; public StudentDaoImpl2() &#123; // 为baseDao初始化 baseDao = new StudentDaoImpl(); System.out.println(&quot;StudentDaoImpl....2&quot;); &#125; @Override public void add() &#123; // 调用StudentDaoImpl()的add方法 baseDao.add(); // 实现功能的拓展 System.out.println(&quot;拓展的功能&quot;); // 再修改bean.properties文件,修改STUDENT_DAO对应的value值,改为StudentDaoImpl2的全限定名 &#125;&#125; 修改bean.properties 12STUDENT_DAO=tech.aistar.design.factory.reflect.StudentDaoImpl2TEACHER_DAO=tech.aistar.design.factory.reflect.TeacherDaoImpl 工厂模式对比 简单工厂 优点:简单 缺点:如果有新的产品加入,需要修改工厂类,违背了软件开发的设计原则-“开闭原则” 工厂方法设计模式 优点:一个工厂类只负责生产一个产品,如果有新的产品加入,不需要修改工厂类,只需要增加一个工厂. 缺点:项目中会存在很多的工厂类. 抽象工厂模式 负责创建一个产品族 反射工厂既能够保证在新增一个产品的时候,遵守”开闭原则”,又能够保证始终仅仅只有一个工厂类.","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"包装类型","slug":"java03","date":"2021-07-27T08:50:47.000Z","updated":"2021-08-02T02:13:28.900Z","comments":true,"path":"2021/07/27/java03/","link":"","permalink":"http://beautifulboyy/2021/07/27/java03/","excerpt":"","text":"包装类型每个基本类型都有其对应的包装类型[对象类型] 基本类型 包装类型[对象类型] byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 学习掌握目标 包装类型的api常用方法 包装类型和基本数据类型以及String类型三者之间的相互转换问题 Numberjava.lang.Number - 所有关于上面包装类型[数字]的共同的抽象的父类 byte byteValue()返回指定号码作为值 byte ，这可能涉及舍入或截断。 abstract double doubleValue()返回指定数字的值为 double ，可能涉及四舍五入。 abstract float floatValue()返回指定数字的值为 float ，可能涉及四舍五入。 abstract int intValue()返回指定号码作为值 int ，这可能涉及舍入或截断。 abstract long longValue()返回指定数字的值为 long ，可能涉及四舍五入或截断。 short shortValue()返回指定号码作为值 short ，这可能涉及舍入或截断。 提供的这些方法都是关于包装类型转换成对应的基本类型的方法 Integer构造 Integer(int i);//利用int类型的整数来构建一个Integer对象 - int类型-&gt;Integer类型 Integer(String s);//此处的字符串一定是数字形式的字符串 - String类型-&gt;Integer类型 如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 自动解封箱jdk5.x开始支持的新的功能 封箱 - 基本数据类型可以自动转换成对应的包装类型 解箱 - 包装类型可以自动转换成对应的基本的数据类型 常用方法 static Integer valueOf(int i); int类型-&gt;Integer类型 如果int类型的数在**[-128,127]**之间,就直接返回内部的缓冲数组中的数据,如果不在这个范围,会返回一个新的Integer对象.因为在Integer类中有一个个静态内部类IntegerCache,在它里面有一个缓冲区,提供了缓冲数组,数组在静态代码块中进行预初始化,提前赋值了. 1234567891011121314151617181920212223//如果[-128,127]之间,那么直接返回内部的缓冲数组中的数据//如果不在这个范围,返回一个新的Integer对象public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125;Integer类内部有一个静态内部类private static class IntegerCache &#123; static final int low = -128; static final int high; //缓冲区,提供了缓冲的数组,数组在静态代码块中进行预初始化,提前赋值了. static final Integer cache[]; static&#123; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; &#125; 关于进制的转换 2-1. static String toBinaryString(int n);//十进制n转换成对应的二进制 2-2. static String toHexString(int n);//十进制n转换成对应的十六进制 2-3. static String toOctalString(int n);//十进制n转换成对应的八进制 static int parseInt(String s);//将数字形式的字符串转换成int类型,如果传入的是一个非数字形式的字符串,那么会抛出java.lang.NumberFormatException数字格式化失败异常 static Integer valueOf(String s);//String-&gt;Integer 包装类型和基本数据类型以及String类型三者之间的相互转换问题 int-&gt;Integer 123456//1.构造方法new Integer(int n)Integer t1 = new Integer(12);//2.Integer提供的静态方法valueOfInteger t2 = Integer.valueOf(12);//3.自动封箱Integer t3 = 12; Integer-&gt;int 1234//1.Number提供的方法intValueint n1 = t1.intValue();//2.自动解箱int n2 = t1; int-&gt;String 12//String提供的静态方法valueOfString str = String.valueOf(n1); String-&gt;int 12//Integer提供的静态方法paseIntint n3 = Integer.pareInt(str); String-&gt;Integer 1234//1.构造方法Integer t4 = new Integer(str);//2.Integer的静态方法valueOfInteger t5 = Integer.valueOf(str); Integer-&gt;String 1234//1.String提供的toString方法String str1 = t4.toString();//2.String提供的静态valueOfString str2 = String.valueOf(t4); 总结 Integer.valueOf()可以将int/String转换为Integer对象 String.valueOf()可以将int/Integer转换为String对象 new Integer()可以将int/String转换为Integer对象 int和Integer之间的区别 Integer是int的包装类；int是基本数据类型； Integer变量必须实例化后才能使用；int变量不需要； Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ； Integer的默认值是null；int的默认值是0。 泛型不支持int，但是支持Integer int 存储在栈中，Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。 判断题123456789101112131415161718192021222324Integer i = new Integer(12);Integer j = new Integer(&quot;12&quot;);Integer o = new Integer(12);System.out.println(i==o);System.out.println(i==j);Integer i1 = Integer.valueOf(12);Integer i2 = Integer.valueOf(&quot;12&quot;);System.out.println(i1==i2);Integer i3 = Integer.valueOf(300);Integer i4 = Integer.valueOf(&quot;300&quot;);System.out.println(i3 == i4);Integer i5 = Integer.valueOf(128);Integer i6 = Integer.valueOf(128);System.out.println(i5 == i6);Integer i7 = new Integer(&quot;10&quot;);Integer i8 = Integer.valueOf(10);int i9 = 10;System.out.println(i7 == i9);System.out.println(i8 == i9);System.out.println(i7 == i8); Objectjava.lang.Object类是所有的类的基类,根类,超类 所有的类如果没有明确指定父类,都会默认继承Object类. equal方法页内认可的一种说法 - 基本类型用==比较的是值,对象类型用==比较的是地址 boolean equals(Object obj); 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 默认的比较方式不符合实际的业务需要,因此需要重写equals方法 一个小实例[注意观察equal方法的重写] Product.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package tech.aistar.day10.obj;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/28 11:01 * @description */public class Product &#123; private Integer id; private String name; private Double price; private ProductInfo info; public Product() &#123; &#125; public Product(Integer id, String name, Double price) &#123; this.id = id; this.name = name; this.price = price; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; public ProductInfo getInfo() &#123; return info; &#125; public void setInfo(ProductInfo info) &#123; this.info = info; &#125; @Override public boolean equals(Object obj)&#123; //1.非空性 if(obj == null) return false; //2.自反性 if(this == obj) return true; //3.一致类型,判断具体的哪个属性是一致的,才认为返回true if(obj instanceof Product)&#123; Product p = (Product) obj; return this.id == p.id &amp;&amp; this.getInfo().equals(p.getInfo()); &#125; return false; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Product&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&quot;, price=&quot;).append(price); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; ProductInfo.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 11:06 * @description */public class ProductInfo &#123; private Integer id; private String info; public ProductInfo() &#123; &#125; public ProductInfo(Integer id, String info) &#123; this.id = id; this.info = info; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getInfo() &#123; return info; &#125; public void setInfo(String info) &#123; this.info = info; &#125; /** * 重写父类的equals方法,判断id相等时equals为真 * @param obj * @return */ @Override public boolean equals(Object obj)&#123; // 1.非空性 if(null == obj) return false; // 2.自反性 if(this == obj) return true; // 3.一致性判断,判断具体的哪个属性是一致的,才认为是返回true if(obj instanceof ProductInfo)&#123; // 强制转换 ProductInfo pf = (ProductInfo) obj; return this.id == pf.id; &#125; return false; &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;ProductInfo&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, info=&#x27;&quot;).append(info).append(&#x27;\\&#x27;&#x27;); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; TestProduct.java 1234567891011121314151617181920212223package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 11:11 * @description equals方法的测试类 */public class TestProduct &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac2&quot;,10000.0d); ProductInfo info1 = new ProductInfo(1,&quot;好产品&quot;); p1.setInfo(info1); Product p2 = new Product(1,&quot;mac&quot;,20000.0d); ProductInfo info2 = new ProductInfo(1,&quot;坏产品&quot;); p2.setInfo(info2); boolean flag = p1.equals(p2); System.out.println(p1.equals(p2));//true System.out.println(p1 == p2);//false &#125;&#125; hashCode方法int hashCode(); 用于返回对象的哈希值,一般是和equals方法成对出现的,目的是为了提高效率 容器应用中 - 在什么时候才会去调用equals方法? - 当哈希碰撞的时候,只要哈希不冲突,不会调用equals方法 而调用equals方法执行的时机肯定会慢一点的.因为它需要比较属性值[需要更多的时间] 一个小实例 Course.java 1234567891011121314151617181920212223242526272829303132333435363738package tech.aistar.day10.hashcodes;import java.util.Objects;/** * @Author liuWenXiu * @Date 2021/7/28 19:58 * @description */public class Course &#123; private Integer id; private String name; @Override public boolean equals(Object o) &#123; System.out.println(&quot;equals..&quot;); if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Course course = (Course) o; return Objects.equals(id, course.id); &#125; @Override public int hashCode() &#123; System.out.println(&quot;hash...&quot;); return Objects.hash(id); &#125; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder(&quot;Course&#123;&quot;); sb.append(&quot;id=&quot;).append(id); sb.append(&quot;, name=&#x27;&quot;).append(name).append(&#x27;\\&#x27;&#x27;); sb.append(&#x27;&#125;&#x27;); return sb.toString(); &#125;&#125; TestCourse.java 123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.day10.hashcodes;import java.util.HashSet;import java.util.Objects;import java.util.Set;/** * @Author liuWenXiu * @Date 2021/7/28 19:58 * @description */public class TestCourse &#123; public static void main(String[] args) &#123; Course c1 = new Course(1,&quot;java&quot;); Course c2 = new Course(2,&quot;mysql&quot;); Course c3 = new Course(3,&quot;php&quot;); Course c4 = new Course(4,&quot;c#&quot;); Course c5 = new Course(5,&quot;c++&quot;); Course c6 = new Course(6,&quot;python&quot;); Course c7 = new Course(1,&quot;oracle&quot;);// System.out.println(c1==c2); //false;// System.out.println(c1.equals(c7));//true // 集合 - &quot;容器&quot; 比数组更加强大 Set&lt;Course&gt; sets = new HashSet&lt;&gt;(); sets.add(c1); sets.add(c2); sets.add(c3); sets.add(c4); sets.add(c7); for (Course c : sets) &#123; System.out.println(c); &#125; &#125;&#125; 运行结果 12345678910hash...hash...hash...hash...hash...equals..Course&#123;id=1, name=&#x27;java&#x27;&#125;Course&#123;id=2, name=&#x27;mysql&#x27;&#125;Course&#123;id=3, name=&#x27;php&#x27;&#125;Course&#123;id=4, name=&#x27;c#&#x27;&#125; 总结 如果两个对象hashcode值一样,将会使用equals进行比较,不一定返回true 如果两个对象equals返回true,那么这两个对象的哈希值一定是一样的. - 数据的完整性 笔试题 == 和equals的区别 ==基本类型使用,比较的就是基本类型的数值 equals对象类型使用,如果某个类没有重写equals方法,那么调用的是java.lang.Object中的equals方法,这个时候仍然使用到的是==比较.如果重写了equals,就看equals提供的是哪些属性一致的时候,才返回true. clone方法protected Object clone(); //默认的克隆方法是浅克隆 浅克隆浅拷贝,浅层复制,浅复制 - 默认的 直接生成的clone方法 1234@Overrideprotected Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; 要对其进行修改,将protected修改成public 123456@Overridepublic Object clone() throws CloneNotSupportedException &#123;return super.clone();&#125;Object中的clone方法 - native修饰的方法 - 本地方法栈中的方法 - C写的 - Java语言本地调用C程序.protected native Object clone() throws CloneNotSupportedException; clone方法的使用**:只有实现了java.lang.Cloneable接口[标记接口]的对象才能够调用clone方法,否则会抛出java.lang.CloneNotSupportedException不支持克隆的异常.** 12345try &#123; Product copy = (Product) p1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 关于clone的测试实例 1234567891011121314151617181920212223242526272829303132package tech.aistar.day10.obj;/** * @Author liuWenXiu * @Date 2021/7/28 20:14 * @description */public class TestCloneDemo &#123; public static void main(String[] args) &#123; Product p1 = new Product(1,&quot;mac&quot;,1000.0d); ProductInfo info = new ProductInfo(1,&quot;good&quot;); p1.setInfo(info); // 浅拷贝 try &#123; Product copy = (Product) p1.clone(); // 1. 修改基本类型/String类型 p1.setId(2); p1.setName(&quot;Sakura&quot;); // 2.修改对象类型 p1.getInfo().setId(3); p1.getInfo().setInfo(&quot;bad&quot;); System.out.println(copy); System.out.println(copy.getInfo()); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果: 12Product&#123;id=1, name=&#x27;mac&#x27;, price=1000.0&#125;ProductInfo&#123;id=3, info=&#x27;bad&#x27;&#125; 浅拷贝:修改原来对象的基本数据类型以及字符串不会对拷贝的新对象产生影响,修改原来对象的对象类型数据会对拷贝的新对象产生影响 深克隆深层复制,深拷贝,深复制 - 需要自己重写clone里面的具体的代码的 12345678910111213141516171819 @Override public Object clone() throws CloneNotSupportedException &#123;// return super.clone(); // 手动创建一个Product对象 Product pf = new Product(); pf.setId(this.id); pf.setName(this.name); pf.setPrice(this.price); ProductInfo info = pf.getInfo(); //! 注意这里首先要判断info是否为空,因为info有可能还没有被赋值 if(info!=null)&#123; ProductInfo pi = new ProductInfo(); pi.setId(info.getId()); pi.setInfo(info.getInfo()); // 最后为pf设置 pf.setInfo(pi); &#125; return pf; &#125; 深拷贝每次都创建一个新的对象,所以是很消耗时间的.","categories":[],"tags":[{"name":"Integer","slug":"Integer","permalink":"http://beautifulboyy/tags/Integer/"},{"name":"深拷贝浅拷贝","slug":"深拷贝浅拷贝","permalink":"http://beautifulboyy/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"Date和Calendar的使用","slug":"java02","date":"2021-07-25T08:50:47.000Z","updated":"2021-08-02T02:12:35.376Z","comments":true,"path":"2021/07/25/java02/","link":"","permalink":"http://beautifulboyy/2021/07/25/java02/","excerpt":"","text":"Date api:java.util.Date[C] - 使用这个类之前,必须要导包import 这是java中提供的关于日期的处理,内置的对象类型.它本身是一个过时的类 里面提供了很多已经过时的方法. 目标:掌握这个类中提供的方法 构造方法构造方法 - 创建这个类的对象的方式 在使用api时首先观察该类提供的方法是静态的还是动态的,发现Date类中提供的方法几乎都是非静态的,所以必须创建该类的对象从而调用方法. 构造方法通过new关键字调用 1234567891011121314151617// 方法1:空参构造函数Date d = new Date(); //这个Date指的是当前的时间// 打印这个日期对象System.out.println(d); //结果:Wed Jul 21 18:50:26 CST 2021// 方法2:重载的构造方法[有参构造方法] - 已经过时,不再使用// 以下代码表示创建日期为2021年7月21日// 年份需要减去1900 月份需要-1Date d2 = new Date(2021-1900,6,21);System.out.println(d2); //结果:Wed Jul 21 00:00:00 CST 2021// 方法3:利用毫秒数[时间戳]来构建一个Date对象// 毫秒数表示距离1970经过那么多毫秒到现在的时间// 注意:毫秒数的类型是long型的Date d3 = new Date(1626828910303L);System.out.println(d3); //结果:Wed Jul 21 08:55:10 CST 2021 一个小练习:计算三天之后的此时此刻 1234567// 首先获取当前时间Date date = new Date();// 获取当前毫秒数并且加上三天的毫秒数long time = date.getTime() + 3L*24*60*60*1000;Date threeDayAfter = new Date(time);System.out.println(date); //结果:Wed Jul 21 19:00:03 CST 2021System.out.println(threeDayAfter); //结果:Sat Jul 24 19:00:03 CST 2021 常用方法由api知方法几乎都是非静态方法,需要**日期对象.方法名()**进行调用 long getTime();返回当前日期的毫秒数的表现形式 获取当前系统时间的毫秒数.距离1970年1月1日 123// 我们可以通过设置毫秒数来构建Date对象,当然也可以通过Date对象获取毫秒数long nowTime = d.getTime(); //获取当前时间的时间戳System.out.println(nowTime); //结果:1626865041991 get/set方法 - 过时的 void setYear(int year); //year-1900 void setMonth(int month); //month的范围[0,11] void setDate(int date); //设置今天是几号 void setHours(int hours); //设置小时 void setMinutes(int minutes); //设置分钟 void setSeconds(int seconds); //设置秒钟 12345678910111213System.out.println(&quot;------------Date对象的set方法---------------&quot;);Date now = new Date();now.setYear(2020-1900); //设置年份为2020年now.setMonth(5); //设置月份为6月now.setDate(25); //设置日期为25日System.out.println(now); //结果:Thu Jun 25 19:02:19 CST 2020System.out.println(&quot;------------Date对象的get方法---------------&quot;);System.out.println(&quot;year:&quot;+(now.getYear()+1900));System.out.println(&quot;month:&quot;+(now.getMonth()+1));System.out.println(&quot;date:&quot;+now.getDate());System.out.println(&quot;day:&quot;+now.getDay()); //星期几 [周一,周六]=[1,6] 周日为0System.out.println(&quot;hours:&quot;+now.getHours()); setTime()方法,通过设置毫秒数重新设置Date 1234// 利用setTime(毫秒数)设置DateDate dd = new Date();dd.setTime(1726830007794L);System.out.println(dd); //结果为:Fri Sep 20 19:00:07 CST 2024 Calendarjava.util.Calendar是一个抽象类,它不能被new 常用方法 static Calendar getInstance(); 12// 获取当前系统的日历对象Calendar cal = Calendar.getInstance(); //底层使用到了简单工厂的设计模式 设置日历字段 12345678void set(int year, int month, int date)设置日历字段中的值 YEAR ， MONTH和 DAY_OF_MONTH 。void set(int year, int month, int date, int hourOfDay, int minute)设置日历字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY和 MINUTE 。void set(int year, int month, int date, int hourOfDay, int minute, int second)设置字段中的值 YEAR ， MONTH ， DAY_OF_MONTH ， HOUR_OF_DAY ， MINUTE和 SECOND 。 单独针对单个字段一一进行赋值 12345void set(int field,int value);只要看到field//公开的静态的常量属性public static final int YEAR = 1; 获取日历字段 123Date getTime();//获取日历信息中关于日期部分的信息 - Calendar转成Date类型int get(int field);//关于获取日历指定字段的值 123456789101112131415//Calendar.YEAR -&gt; 年份System.out.println(cal.get(Calendar.YEAR));// 这样就可以获取到年份是2021年// 增加程序的可读性// Calendar.DATE -&gt; 获取日期System.out.println(cal.get(Calendar.DATE));// Calendar.DAY_OF_MONTH -&gt; 获取日期[一个月之中的第几天]System.out.println(cal.get(Calendar.DAY_OF_MONTH));// 上面两个域都是一样的,都是5,所以他俩表示的是同一个意思// Calendar.DAY_OF_WEEK -&gt; 一周中的第几天 [周日,周六]-[1,7]System.out.println(cal.get(Calendar.DAY_OF_WEEK));// Calendar.MONTH -&gt; 获取月份 [0,11]System.out.println(cal.get(Calendar.MONTH)); 总结 毫米数 -&gt; Date Date提供的构造方法 1Date d1 = new Date(1626869108538L); Date提供的setTime(long 毫秒数)方法 1d1.setTime(1726869108538L); Date -&gt; 毫米数 Date提供的getTime()方法 1long l = d1.getTime(); Calendar -&gt; Date Calendar提供的getTime()方法 12Calendar cal = Calendar.getInstance();Date d2 = cal.getTime(); Date -&gt; Calendar Calendar提供的setTime(Date d)方法 1cal.setTime(d1); 一个综合练习题给定一个年份和月份,在idea控制台输出该日历,形式如下 相关api:java.util.Date和java.util.Calendar 123456789请您输入年份:2021请您输入月份:7 2021年7月日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package tech.aistar.day05;import tech.aistar.util.DateUtil;import java.util.Calendar;import java.util.Scanner;/** * @Author liuWenXiu * @Date 2021/7/21 19:07 * @description 打印日历 */public class PrintCalendar &#123; public static void main(String[] args) &#123; // 根据题意分析: // 1.首先获取键盘输入的年份和月份 Scanner sc = new Scanner(System.in); System.out.print(&quot;请您输入年份:&quot;); int year = sc.nextInt(); System.out.print(&quot;请您输入月份:&quot;); int month = sc.nextInt(); // 2.根据年份和月份打印日历 print(year,month); &#125; /** * 根据年份和月份打印日历 * @param year * @param month */ public static void print(int year,int month)&#123; // 1.判断键盘输入的合法性 // 1.1 year是否合法,如果year&lt;0,则不合法 if(year&lt;0)&#123; System.out.println(&quot;年份不合法!&quot;); return; &#125; // 1.2 month是否合法,如果month&lt;0或month&gt;12,则不合法 if(month&lt;0 || month&gt;12)&#123; System.out.println(&quot;月份不合法!&quot;); return; &#125; // 2.打印日历中的标题 例如2021年7月 System.out.println(&quot;\\t\\t&quot;+year+&quot;年&quot;+month+&quot;月&quot;); // 3.打印日历中的星期 System.out.println(&quot;日\\t一\\t二\\t三\\t四\\t五\\t六&quot;); // 4.确定某年某月的1号是周几 int week = DateUtil.getWeek(year,month,1); // 5.确定某年某月的最大天数 int maxDays = DateUtil.getMaxDay(year, month); // 6.确定今天是几号 int date = Calendar.getInstance().get(Calendar.DATE); // 7.打印结果 // 7.1 先根据某年某月的1号是星期几先打印出一号 // 假设1号是星期三 那么星期日星期一星期二的位置都打\\t // 还需要定义一个计数器,当计数器=7时换行,不管打&quot;\\t&quot;还是具体时间都要++ int count = 0; for(int i=0;i&lt;week;i++)&#123; System.out.print(&quot;\\t&quot;); count++; &#125; //经过了这个for循环以后我们找到了1号所在的位置 // 然后开始逐个打印日期,从1~最大天数,每当count=7时换行 for(int i=1;i&lt;=maxDays;i++)&#123; System.out.print(i+&quot;\\t&quot;); count++; if(count==7)&#123; System.out.println(); count=0; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package tech.aistar.util;import java.util.Calendar;/** * 本类用来演示:自定义的日期工具类 - 推荐定义成static */public class DateUtil &#123; /** * 判断某年某月的最大天数 * @param year * @param month * @return */ public static int getMaxDay(int year,int month)&#123; int days = 31; if(month==4 || month==6 || month==9 || month==11)&#123; days = 30; &#125;else if(month ==2)&#123;// if(isLearYear(year))&#123;// days = 29;// &#125;else&#123;// days = 28;// &#125; days = isLeapYear(year)?29:28; &#125; return days; &#125; /** * 根据年份月份和日期返回星期 * @param year 年 * @param month 月 * @param date 日 * @return 星期几 */ public static int getWeek(int year,int month,int date)&#123; // 1. 首先构建Calendar对象 Calendar cal = Calendar.getInstance(); // 2. 设置年份和月份 // 注意一下这个月份:用户输入的是6表示要6月 而在程序中必须-1 cal.set(year,month-1,date); // 3. 返回星期 // 注意一下这个星期:[周日,周六] -&gt; [1,7] return cal.get(Calendar.DAY_OF_WEEK)-1; &#125;&#125;","categories":[{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Date","slug":"Date","permalink":"http://beautifulboyy/tags/Date/"},{"name":"Calendar","slug":"Calendar","permalink":"http://beautifulboyy/tags/Calendar/"}]},{"title":"抽象类和接口","slug":"java07","date":"2021-07-23T12:18:40.000Z","updated":"2021-08-02T06:04:12.535Z","comments":true,"path":"2021/07/23/java07/","link":"","permalink":"http://beautifulboyy/2021/07/23/java07/","excerpt":"","text":"抽象类抽象类的特点 抽象类天生就是用来被子类继承的,抽象类天生就是不能够被外部进行实例化的. 抽象类使用abstract来进行修饰 普通类是没有子类去定义抽象方法的,换句话说,只有抽象类能定义抽象方法 抽象方法也是使用abstract修饰的,抽象方法是指没有方法体的方法.抽象的方法天生也是被子类用来重写的. 抽象类是一种抽象的数据类型 抽象类继承的特点 如果某个普通的子类继承了抽象类,那么这个子类必须要重写这个抽象父类中所有的抽象方法. 如果某个子类继承了抽象类,不想重写抽象父类中所有的抽象方法,那么需要将这个子类也定义成抽象类. 不能一起混用的修饰符 final和abstract不能一起使用 private和abstract不能一起修饰方法 static和abstract不能一起修饰方法. static不存在多态 接口接口的特点 属于抽象的数据类型,也会不能够被实例化的. 接口中不允许定义普通属性也不允许出现构造方法. jdk8.x允许在接口中使用default关键字来定义普通方法 接口也是用来定义抽象的方法的,接口中的方法都是抽象的方法.[不准确] 接口的属性都是公开的静态的常量属性 定义接口的关键字是interface,编译之后也是.class字节码文件. 接口也可以定义静态方法. 接口的命名规则通常以I开头或者able结尾 一个接口的使用实例 123456789101112131415161718192021public interface Userable &#123; // 接口的属性都是公开的静态的常量属性 //public static final int YEAR = 1; // 简写 //public int YEAR = 1; // 再简写 int YEAR =1; //jdk8.x之前不允许定义普通方法 // 之后可以通过default方法来定义普通方法 public default void test()&#123; System.out.println(&quot;test..&quot;); &#125; // 接口中的方法应该都是抽象的方法 //public abstract void add(); // 简写 //public void add(); // 再简写 void add();&#125; 12345678910111213public class UserableImpl implements Userable&#123; @Override public void add() &#123; System.out.println(&quot;impl1...&quot;); &#125;&#125;public class UserableImpl2 implements Userable&#123; @Override public void add() &#123; System.out.println(&quot;impl2...&quot;); &#125;&#125; 12345678public class TestUserable &#123; public static void main(String[] args) &#123; Userable u1 = new UserableImpl(); u1.add(); Userable u2 = new UserableImpl2(); u2.add(); &#125;&#125; 结果 impl1… impl2… 接口的规则 接口和类 接口天生是用实现类来实现的 - implements 普通的类去实现某个接口的话,必须要实现这个接口中所有的抽象方法 如果抽象的类去实现某个接口的话,可以选择实现或者不实现.[如果不实现的话就让子类去实现] 一个接口可以拥有多个实现类. 一个类可以同时实现多个接口,接口之间用逗号隔开,需要实现这些接口中所有的抽象方法. 接口和接口 一个接口可以继承多个接口,接口是支持多重继承的. 接口的应用提供了一种”契约机制”,屏蔽了底层的具体实现,为了程序的拓展 - 在开发中会体会到. 作用 - 指定开发的这个软件的功能 - “业务方法” 接口的分类 业务接口 - 该接口中只定义抽象方法 常量接口 - 该接口中只定义了常量属性,用于管理系统中所有的常量属性.jdk5.x使用了枚举类型来替代常量接口. 标记接口 - 什么都没有,用来做标记的. 1234567public interface IA&#123;&#125;public class Aimpl implements IA&#123; ...&#125;Aimpl a = new Aimpl();System.out.println(a instanceof IA); //true 函数式接口 - jdk8.x - lambda表达式 里面只有一个抽象方法的接口 - @FunctionnallInterface 1234@FunctionalInterfacepublic interface Funable &#123; int add(int a,int b);&#125; 123456class FunableImpl implements Funable&#123; @Override public int add(int a, int b) &#123; return a+b; &#125;&#125; 匿名内部类 123456Funable f = new Funable()&#123; @Override public int add(int a, int b) &#123; return a+b; &#125;&#125;; lambda表达式 123Funable f = (a,b)-&gt;&#123;return a+b;&#125;;// lambda表达式看起来真的很简单 可是真的有点难理解System.out.println(f.add(10,20)); 抽象类和接口的异同 相同点 接口和抽象类都不能被实例化,他们都位于继承树顶端,用于被其他类继承或实现 接口和抽象类都可以包含抽象方法,实现接口或继承抽象类的普通子类都必须实现这些抽象方法,但若是该子类是抽象的,则可以选择实现也可以选择不实现. 不同点 接口中只能包含抽象方法,静态方法,和默认方法,不能定义普通方法,而抽象类中可以包含普通方法. 接口中只能定义静态常量,而抽象类中可以定义普通成员变量,也可以定义静态常量 接口中不能有构造器,而抽象类中可以有. 接口里不能包含初始化块,而抽象类可以包含初始化块. 一个子类中最多只能继承一个抽象类,而一个实现类可以同时实现多个接口.","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"抽象类","slug":"抽象类","permalink":"http://beautifulboyy/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"接口","slug":"接口","permalink":"http://beautifulboyy/tags/%E6%8E%A5%E5%8F%A3/"}]},{"title":"面向对象程序设计","slug":"java06","date":"2021-07-21T12:18:40.000Z","updated":"2021-08-04T13:03:49.387Z","comments":true,"path":"2021/07/21/java06/","link":"","permalink":"http://beautifulboyy/2021/07/21/java06/","excerpt":"","text":"面向对象程序设计 java语言属于面向对象的语言 面向对象本身不是一门具体的技术,符合人类思维的思想. 宗旨:把一个复杂的大型的业务,利用面向对象的思想进行面向对象的分析, 接着面向对象的设计,最终进行面向对象的编程. 对象是数据在内存中的”载体” 类和对象 类是抽象的概念,对象是具体的概念 类是构建对象的蓝图/模板,对象是类的具体的实例化[表现] 类是用来描述对象的. 面向对象的思想核心:”一切皆对象” ①分析出系统中业务的关键对象 - “找对象” - 未来页面上显示的数据 ②找出对象的**”属性”** - “对象拥有什么” ③分析出对象的”方法” - “对象可以干什么,对象的功能” ④找出对象与对象之间的关系. 12345671:1 - 一个丈夫对应一个妻子,一个妻子对应一个丈夫.1:N - 一个客户拥有多个订单.一个订单只能属于一个客户 - 70%N:N - 一个学生可以选择多门课程,一门课程可以被多个学生来选择.自关联 - 自己关联自己. ⑤最后一步才会去考虑具体怎么编码实现.可能也会考虑数据结构或者算法. “相亲业务” - 媒婆帮你找一个”对象” 你要查看”对象”的属性 询问”对象”的功能 分析你和”对象”是否来道🌩 考虑 - 追 - 彩礼 - 结婚 - 具体怎么实现! 面向过程的思想C是典型的面向过程的思想 ①优先考虑的就是算法和数据结构 - 考虑的就是具体怎么实现. 实体类实体类就是用来描述对象的. 实体类中包含属性,构造方法,getter/setter方法,toString方法. 如何定义属性语法:修饰符 数据类型 属性名 [=初始值]; 修饰符 public 公开的 private 私有的 数据类型 八种基本数据类型 内置对象类型以及自定义对象类型. 属性名参考变量的命名 - “小驼峰” this关键字this是自身的一个对象,代表对象本身,可以理解为:指向对象本身的一个指针. 普通的直接引用 this相当于指向当前对象本身 形参与成员名字重名,用this进行区分 12345678910class Person&#123; private int age = 10; public Person()&#123; System.out.println(&quot;初始化年龄:&quot;+age); &#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; 调用本类中另一种形式的构造函数(应该为构造函数中的第一条语句) super关键字super可以理解为指向自己最近父类对象的指针. 普通的直接引用 通过super.xxx来引用父类中的非私有成员 子类中的成员变量或方法与父类中的成员变量或方法同名时进行区分 123456789101112131415class Country&#123; String name; void value()&#123; name = &quot;China&quot;; &#125;&#125;class City extends Country&#123; String name; void value()&#123; name = &quot;Shanghai&quot;; super.value(); //调用父类中的方法啊 System.out.println(name); System.out.println(super.name); &#125;&#125; 调用父类中的某一个构造函数(应该为构造函数中的第一条语句) toString方法 当我们直接输出对象的时候,默认一定会去调用toString方法 - 如果这个对象是null,那么不会调用toString方法的 当自定义的实体类中没有手动提供toString方法,那么这个对象会自动去调用java.lang.Object类中的toString方法 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; java.lang.Object - 它是所有的类的根类,基类,超类,父类. 如果某个类没有明确指定它的父类,那么这个类默认会直接继承java.lang.Object类 “User类是Object类的儿子” - 规定 - “子类可以调用父类中所有的公开的成员“ Object类中提供的toString方法只能用来返回对象的内存地址 - 不满足实际的打印需求 所以需要在实体类中重新重写这个toString方法. 当子类User类一旦重写了toString方法之后,那么就会采取”就近原则”,直接调用自己重写之后的toString方法. 构造方法-constructor作用:创建对象的时候调用构造方法,通过new关键字 可以在创建对象的同时进行赋值操作,赋值的方式只有1次,setter赋值,可以多次赋值 特点 当实体类中如果没有手动提供任何一个构造方法的时候,那么系统会自动分配一个空参构造.如果实体类中一旦手动提供了带参构造之后,那么系统将不会再分配一个空参构造了. 定义的时候,不需要返回类型的 123public 类名([参数列表])&#123; //构造体&#125; 构造允许重载的 实体类中推荐只用提供空参,全参 OO练习业务类和实体类合二为一将业务方法放在实体类中 - 违背了设计原则 - “单一职责原则”. 不要给一个类增加太多的负担. 实体类 - 主要描述的对象,数据在内存中的载体,注重的应该是数据的存储. 业务类 - 存放的是业务的方法 - 在于操作这些数据 实例:设计一个员工类[编号id,姓名name,工资salary],业务方法[crud增删改查]放在实体类中,这是不合理的. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package tech.aistar.day06;import java.util.Arrays;/** * @Author liuWenXiu * @Date 2021/7/22 9:22 * @description 员工类 * * 在这个实例中学习到:在进行功能的实现时一定要先判断参数的合法性等 */public class Emp &#123; private int id; private String name; private double salary; //一个上司拥有多个下属 //一个下属对应一个上司 //自关联 private Emp[] emps; //构造,getter/setter,toString public Emp() &#123; &#125; public Emp(int id, String name, double salary, Emp[] emps) &#123; this.id = id; this.name = name; this.salary = salary; this.emps = emps; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Emp[] getEmps() &#123; return emps; &#125; public void setEmps(Emp[] emps) &#123; this.emps = emps; &#125; //给上司添加一个下属 public void addEmp(Emp e)&#123; // 同样需要判断 if(null != this.emps)&#123; //数组的扩容Arrays.copyOf(数组对象,新的长度); this.emps = Arrays.copyOf(this.emps,this.emps.length+1); this.emps[emps.length-1] = e; &#125;else&#123; System.out.println(&quot;对不起,您没有资格添加员工.&quot;); &#125; &#125; //输出下属的个数 public void printEmpCount()&#123; // 防止下属调用这个方法 if(null == this.emps)&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); return; &#125; System.out.println(&quot;员工个数:&quot;+this.emps.length); &#125; //输出某个上司所有的下属信息 public void printEmp()&#123; //同样需要进行判断 if(null != this.emps &amp;&amp; this.emps.length&gt;0)&#123; System.out.println(&quot;下属信息如下:&quot;); for (int i = 0; i &lt; this.emps.length; i++) &#123; System.out.println(this.emps[i]); &#125; &#125;else&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); &#125; &#125; /** * 根据id删除员工 * @param id */ public void delById(int id)&#123; // 又忘了判断合法性!!!! if(this.emps!=null &amp;&amp; emps.length&gt;0)&#123; // 员工的编号是唯一的,因此新的员工列表的长度是原来长度-1 Emp[] temp = new Emp[this.emps.length-1]; int post = 0; for (int i = 0; i &lt; this.emps.length; i++) &#123; if(this.emps[i].getId() == id) continue; temp[post++] = this.emps[i]; &#125; this.emps = temp; &#125;else&#123; System.out.println(&quot;对不起,您的员工个数为0.&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125;&#125; 业务类和实体类分开业务方法应该专门抽取出来放到一个业务类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package tech.aistar.day06.biz;/** * @Author liuWenXiu * @Date 2021/7/22 10:25 * @description Emp实体类 - 数据的存储 */public class Emp &#123; private int id; private String name; private double salary; private Emp[] emps; public Emp() &#123; &#125; public Emp(int id, String name, double salary, Emp[] emps) &#123; this.id = id; this.name = name; this.salary = salary; this.emps = emps; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Emp[] getEmps() &#123; return emps; &#125; public void setEmps(Emp[] emps) &#123; this.emps = emps; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, salary=&quot; + salary + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package tech.aistar.day06.biz;import java.util.Arrays;/** * @Author liuWenXiu * @Date 2021/7/22 10:28 * @description 业务类 - 业务方法 */public class EmpBiz &#123; /** * 将新的员工添加上司的下属数组中 * @param boss 上司 * @param e 员工 */ public void addEmp(Emp boss,Emp e)&#123; // 1. 判断 Emp[] emps = boss.getEmps(); if(emps!=null)&#123; emps = Arrays.copyOf(emps,emps.length+1); emps[emps.length-1] = e; // 注意一下这里的set 很重要 boss.setEmps(emps); &#125;else&#123; System.out.println(&quot;对不起,您没有资格添加下属.&quot;); &#125; &#125; /** * 打印下属 * @param boss */ public void printEmp(Emp boss)&#123; Emp[] emps = boss.getEmps(); if(emps!=null &amp;&amp; emps.length&gt;0)&#123; System.out.println(&quot;下属信息:&quot;); for (Emp emp : emps) &#123; System.out.println(emp); &#125; &#125;else&#123; System.out.println(&quot;对不起,您没有下属&quot;); &#125; &#125; /** * 删除工资高于salary的员工 * @param boss * @param salary */ public void delBySalary(Emp boss,double salary)&#123; // 1. 首先需要获取boss的所有员工 Emp[] emps = boss.getEmps(); if(emps!=null)&#123; // 2.遍历员工信息,记录需要删除的个数 // 定义一个计数器 int count = 0; for (Emp emp : emps) &#123; if(emp.getSalary()&gt;salary)&#123; count++; &#125; &#125; // 3.此时我们就已经知道了需要删除的个数,可以创建新的数组 Emp[] temp = new Emp[emps.length-count]; // 4.遍历旧的数组 // 定义新的数组下标 int post = 0; for (Emp emp : emps) &#123; if(emp.getSalary()&lt;=salary)&#123; temp[post++] = emp; &#125; &#125; // 5.得到的temp就是删除后的数组,再将它赋值给boss.emps boss.setEmps(temp); &#125;else&#123; System.out.println(&quot;对不起,您没有下属&quot;); &#125; &#125;&#125; 封装性- Encapsulation封装 - Encapsulation - 屏蔽底层的细节,数据提供保护的机制 属性私有化 提供getter/setter方法 setter方法 - set属性名[首字母变大写] - 推荐的命名规则 setter方法这种设置值的好处 2-1. setter方法中是可以进行参数有效性判断的. 2-2. 业务需求改变了 - 属性名称改变了,使用到这个属性的具体的地方都要发生改变 - “可维护性” 2-3. 并不是所有的属性的值都是通过那么太简单的计算得到的. 12345678910111213141516171819202122232425public class Orders&#123; private int id; private double price; private int count; private double total; //getter/setter - 提供好了 public double getTotal()&#123; double result = this.price * this.count; return result; &#125;&#125;Orders o = new Orders();o.setPrice(100.0);o.setCount(10);//o.setTotal(o.getPrice()*o.getCount());System.out.println(o.getTotal()); 2-4. 并不是所有的属性都需要对外进行公开的. 继承 - Inheritance将多个具有共同特点的对象抽象出一个”父类” 父类中存储的是各个子类共同的特点[属性]或者功能[方法] 继承的好处 - 提高了代码的复用性,使用多态的前提,为了代码的可拓展新 继承的缺点 - 增加了类与类之间的关系,不太符合软件的设计原则”高内聚,低耦合 ​ 低耦合 - 模块与模块之间/类与类之间的关系应该越弱越好 - 最好是没有关系 ​ 高内聚 - 单个模块/类能够独立完成某个业务功能的能力比较强 ​ 实际开发中,可以采用设计原则”合成复用原则 “- 来替代继承的使用 使用extends关键字来表示某个类继承某个父类 123456public class A&#123; &#125;public class B extends A&#123; //B继承于A&#125; B是A的子类,A是B的父类,基类,超类 A的父类就是java.lang.Object - 当某个类如果没有明确指定它的父亲是谁,那么这个类默认继承于Object. 子类可以访问到父类中所有的非私有成员 java的类只支持单继承,一个类只能继承一个父类,避免出现网状结构,保证类的层次性. java的接口支持多重继承,一个接口可以继承多个接口. 继承具有传播性 C extends B B extends A C间接继承于A,C也可以访问到A中所有的非私有成员 不要滥用继承,在使用继承时首先要确保B is A,比如说猫是动物等. super关键字必须放在构造方法的首行 调用父类的构造 在子类的构造方法中,如果没有出现任何的super语句,那么系统默认会给定super();调用父类的空参构造. 当在子类中调用了一个和父类中同名的成员的时候,需要通过super关键字来加以区分[强制调用父类中那个同名的成员] 多态 - polymorphism对象有多种形态,发生前提是具有继承关系 相同的消息可能会送给多个不同的类别之对象. 系统可以根据所属类别,引发对应类别的方法,而有不同的行为.简单来说,所谓多态意指相同的消息给予不同的对象会引发不同的动作. instanceof-&gt; 进行类型的判断,只有为true的时候才能够进行类型的强制转换. 在没有进行类型的判断,随便进行了一个强制类型转换,可能会抛出java.lang.ClassCastException类型转换失败异常. Animal父类 12345678910public class Animal &#123; private String name; public Animal()&#123;&#125; public Animal(String name)&#123; this.name = name; &#125; public void spark()&#123; System.out.println(&quot;动物在叫&quot;); &#125;&#125; Dog子类 123456789101112131415161718192021222324252627public class Dog extends Animal&#123; //子类定义各个子类特有的成员 private double loyalty; //忠诚度 public Dog()&#123; super(); //在子类的构造中,如果没有出现任何的super语句 // 那么系统默认会给定super(); // 调用父类的空参构造 System.out.println(&quot;Dog...&quot;); &#125; public Dog(String name,double loyalty)&#123; // 如果一旦提供了super(name),系统不会分配一个super() super(name); // 调用父类的一参 System.out.println(&quot;Dog全参构造&quot;); this.loyalty = loyalty; &#125; // 子类特有的方法 public void watchDoor()&#123; System.out.println(&quot;狗可以看门&quot;); &#125; // 重写父类中的spark()方法 @Override public void spark() &#123; System.out.println(&quot;汪汪&quot;); &#125;&#125; Cat子类 1234567891011121314151617181920public class Cat extends Animal &#123; private double cute; //萌度 public Cat()&#123; &#125; public Cat(String name,double cute)&#123; super(name); this.cute = cute; &#125; // 子类特有的方法 public void catMouse()&#123; System.out.println(&quot;猫猫会抓鼠鼠...&quot;); &#125; // 重写父类的方法 @Override public void spark() &#123; System.out.println(&quot;喵喵喵&quot;); &#125;&#125; Test类 123456789101112131415public static void main(String[] args) &#123; Animal d = new Dog(&quot;小可&quot;,200.0d); Animal c = new Cat(&quot;小喵&quot;,300.d); Animal[] animals = &#123;d,c&#125;; for (Animal animal : animals) &#123; animal.spark(); if(animal instanceof Dog)&#123; ((Dog) animal).watchDoor(); &#125; if(animal instanceof Cat)&#123; ((Cat)animal).catMouse(); &#125; &#125;&#125; 12345结果:汪汪狗可以看门喵喵喵猫猫会抓鼠鼠... final关键字不可更改,不可变 final修饰的变量/属性 - 不能够重新赋值 final修饰的类 - 不能够被继承 final修饰的方法 - 不能被重写 修饰符访问修饰符 - 决定了这个成员可以在哪里能够被访问. 所有包 子类[同/不同包] 同包 本类 public √ √ √ √ protected × √ √ √ 默认的 × × √ √ private × × × √ 安全级别:private&gt;默认的&gt;protected&gt;public 可见区域:public&gt;protected&gt;默认的&gt;private 方法的重写方法的重写的特点:发生的前提是要有继承关系 重写有一个特殊的场景 - 子类重写之后的方法的修饰符,返回类型,方法名,参数列表和父类中高度保持一致. - 重构 方法名必须一致. 参数列表要高度保持一致. 子类重写的方法的访问修饰符可以小于或者等于父类.[按照安全级别]比如说父类是protected,子类可以是protected或者public,不能是private或缺省. 子类重写的方法的返回类型可以小于[可以是父类方法的返回类型的子类类型]或者等于父类的那个方法 笔试题 - 方法的重载和方法的重写有什么区别? 方法的重载 重载的前提是在同一个类中. 重载的方法方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 方法的重写 重写的前提是要有继承关系 重写的方法名必须相同 重写的参数列表要高度保持一致 重写的方法访问修饰符的安全性可以小于或等于父类 重写的返回类型可以小于或等于父类 三种场景应用 面向父类编程 对象的编译时类型写成父类,对象的运行时类型写成子类. 编译时类型 对象名 = new 运行时类型(); 对象的编译时类型决定对象的访问能力 - “对象名只能访问到编译时类型中定义的成员” 对象的运行时类型决定了对象的行为能力 - “子类中如果一旦重写了父类中的方法,那么运行期间调用的是子类重写之后的方法” 方法的参数类型写成父类,调用这个方法的时候,可以传入这个父类的任意一个子类对象 方法的返回类型写成父类,方法的返回结果可以是这个父类的任意一个子类对象 - “简单工厂设计模式” 面向接口编程 对象的编译时类型写成接口,对象的运行时类型写成实现类 方法的参数类型写成接口,调用方法时可以传入这个接口的任意一个实现类. 方法的返回类型写成接口,方法的返回结果的类型可以是这个接口的任意一个实现类. 练习一12345678910111213141516171819202122232425262728293031323334public class Animal &#123; private String desc; public Animal() &#123; this.desc = getDesc(); &#125; public String getDesc() &#123; return &quot;Animal&quot;; &#125; public String toString() &#123; return desc; &#125;&#125;public class Worf extends Animal &#123; private String name; private double weight; public Worf(String name, double weight) &#123; this.name = name; this.weight = weight; &#125; public String getDesc() &#123; return &quot;Worf:&quot; + name + &quot;体重:&quot; + weight; &#125; public static void main(String[] args) &#123; System.out.println( new Worf(&quot;羊&quot;, 10)); &#125;&#125; 运行结果: Worf:null体重:0.0 练习二12345678910111213141516171819202122232425262728public class Super &#123; int i = 10; public Super() &#123; print(); i = 20; &#125; public void print() &#123; System.out.println(i); &#125;&#125;public class Sub extends Super &#123; int j = 30; public Sub() &#123; print(); j = 40; &#125; public void print() &#123; System.out.println(j); &#125; public static void main(String[] args) &#123; System.out.println(new Sub().j); &#125;&#125; 结果: 0 30 40","categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"Java入门","slug":"java01","date":"2021-07-21T11:33:04.000Z","updated":"2021-08-04T07:16:22.095Z","comments":true,"path":"2021/07/21/java01/","link":"","permalink":"http://beautifulboyy/2021/07/21/java01/","excerpt":"","text":"Java入门Java语言特点 简单 可移植性 面向对象 - 核心 跨平台性 安全性 - 本身是强类型语言,在编译期间就需要确定数据的类型 JDK和JRE和JVM 三者之间的区别 - 笔试简单题 JDK - Java Development Kit - Java开发工具包,针对开发者的,包含了很多的开发工具,比如java.exe,javac.exe,javadoc.exe,jar.exe等. JDK中是包含JRE的 JRE - Java Runtime Environment- Java运行时环境,包含了很多核心的内库.针对于使用Java语言开发出来软件的用户,如果一个用户仅仅想运行一个java程序的话,那么计算机中只需要安装jre即可. JRE中包含JVM JVM - Java Virtual Machine - Java虚拟机 [笔试的大头 - 内存模型] jvm本身是用C语言编写的 Java程序并不是直接在计算机中跑的,而是在虚拟机上执行的,虚拟机是安装在操作系统上的. java语言具有跨平台性[使用java语言编写的程序可以运行在不同的os上],但是jvm不具有跨平台性,不同的操作系统需要安装不同的jvm. HelloWorld程序java的基础单元是类class 标识符的命名 只能由字母,数字,下划线,$符号组成,但是不能以数字开头. 推荐使用”大驼峰”命名规则,单词首字母必须要大写,其余字母小写. 不能是jdk中内置的对象类型[String,System] 不能是java中的一些关键字,关键字-&gt;java语言赋予了这些单词具备一定的语法含义 byte,short,int,long,float,double,char,boolean,if,for,else,while,break,continue等等 不能是java中的保留关键词 - goto[汇编] const 不推荐使用中文,防止出现乱码问题 推荐见名知意 不能是以下三个字面量 - true,false,null 代码 首先在某目录下新建一个文件HelloWorld.java java的源文件就是以.java为后缀的文件 打开HelloWorld.java文件[记事本打开或Notepad++],输入以下代码 1234567public class HelloWorld&#123; // 规范 - 缩进四个空格 public static void main(String[] args)&#123; //方法体:现阶段代码一定是放在方法体内部的 System.out.println(&quot;HelloWorld&quot;); &#125;&#125; 在编程语言中,只要出现了符号,一定必须都是英文输入法下的. java以类作为基础的单位,关键字是class,并且类的名称要和文件的名称高度保持一致. 一对{}表示一个block - 块 - 代码块 main方法是程序的”大门”,运行该程序的时候,jvm就会自动寻找main方法,然后进入到这个main方法中执行 jdk中提供了内置的对象[拥有一些功能],开发者可以直接使用,例如java.lang.System类,向控制台输出一句话. java源代码不能够直接被执行,因为计算机不识别java语言程序. 需要对.java为后缀的源文件进行 一个编译操作,一旦语法发生了问题,编译就会失败 编译命令如下所示 1javac HelloWorld.java javac.exe工具其实就是在调用jdk中的编译器,将**.java源文件编译成.class字节码文件** 运行java程序命令如下所示 1java HelloWorld 过程首先编写.java源代码,再使用javac.exe进行编译,最后使用java.exe执行. 原理:.java源文件经过jdk中的编译器生成.class字节码文件,经过jvm中的解释器翻译成机器能够识别的符号. 注:java属于解释型的语言 可能会有题目说java属于半编译型半解释型语言,这是错误的.编译型语言比如C语言,它编写的程序字节编译成计算机能够执行的程序-&gt;xx.exe Java每次执行都会经过jvm解释器进行解释,因此C语言执行的性能高于java语言. Java中的包-package 包是用来管理类的.包的本质就是一个文件夹.包对于类的作用相当于文件夹对于文件的作用. 包的命名规则 2-1. 推荐全部采用小写字母,如果出现多个单词,请你用.隔开,.隔开的每个部分都是一个目录 2-2. 包的命名推荐采用公司的域名倒置[唯一性] + 项目代号 com.baidu.car tech.aistar 2-3. 不用采用java或者javax开头 - 因为jdk中的内置的类和拓展的类都是在java或者javax包中. 一旦创建了package,需要在类文件的首行采用package关键字来声明包. Java中的三种注释 单行注释// Ctrl+/ 添加/取消注释 多行注释 123/* 多行注释的内容 - 注释的内容是不会经过jdk的编译器的*/ 文档注释 可以生成文档树,一般放在类或方法上面 1234/***** 文档注释的内容*/ 注释的内容不会经过jdk的编译器,利用javac命令编译.java源文件生成.class文件,再进行反编译得到的.java文件不包含注释. main方法的细节123456//修饰符在使用的时候,之间是没有顺序的.public static void main(String[] args)&#123;...&#125; //okstatic public void main(String[] args)&#123;...&#125; //ok//jdk8中方法的参数支持可变长参数public static void main(String... args)&#123;...&#125; //ok//args是我们传给虚拟机的参数 输出语句12System.out.println();System.out.print(&quot;\\n&quot;); 特殊字符 \\代表转义字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445package tech.aistar.day01;/** * 用来演示转义字符 */public class NrDemo &#123; public static void main(String[] args) &#123; // \\n换行 - 当输出完毕后,光标停在下一行的起始位置 System.out.println(&quot;hello\\n&quot;); System.out.println(&quot;world&quot;); /*结果 hello world * */ // \\r - 当输出完毕后,光标停在下一行的起始位置 System.out.println(&quot;LoveBoy\\r88&quot;); /*结果 88veBoy * */ // \\b - 退格 System.out.println(&quot;Hello\\bever&quot;); /*结果 Hellever * */ // \\t - 制表符,相当于tab键,默认是空4格 System.out.println(&quot;hello\\tworld&quot;); /*结果 hello world * */ // 双引号 \\&quot; System.out.println(&quot;james:\\&quot;sakura is a good girl\\&quot;&quot;); // 单引号 \\&#x27; // 单个\\ \\\\ System.out.println(&quot;D:\\\\temp\\\\news&quot;); // 输出\\\\ System.out.println(&quot;\\\\\\\\&quot;); &#125;&#125; 变量编程的核心就是从定义变量开始,java语言是一个强类型的语言,在编译期间必须要确定好数据的类型 变量的本质 - “内存中某块区域的名称”,编程的任务就是对数据进行crud+数据分析的操作 但是前提是数据需要先进行存储[内存,磁盘(文件,db数据库)] - JVM内存 “JVM对字节码文件进行解释的前奏工作 - 把这个字节码文件加载到自己的内存中,java只能操作内存中的数据” java中是如何定义和存储简单的这些数据呢? 就是通过数据类型以及变量来定义和存储的. 数据类型java的数据类型有两大块 基本数据类型(8种) - 编程思想中将void归纳为第9种 对象类型(无数种) 2.1内置对象类型 - System,String - JDK中提供的类 2.2自定义对象类型 - 自己定义的那些类 八种基本数据类型 名称 大小 范围 默认值 byte 字节 占1个字节8bit -128~127 0 short 短整型 占2个字节16bit -2^15~2^15-1 0 int 整型 占4个字节32bit -2^31~2^31-1 0 long 长整型 占8个字节64bit -2^63~2^63-1 0 float 单精度浮点数 占4个字节32bit +-(3.4*10^38) 0.0 double 双精度浮点数 占8个字节64bit +-(1.798*10^308) 0.0 char 字符 占2个字节16bit 0~65535 ‘\\u0000’空格 boolean 布尔类型 占1个字节8bit true/false false 这些都要记下来 变量的定义变量的命名的规范请你参考类的命名规范,除了类的命名采用的”大驼峰”,而变量命名采用的是”小驼峰” “小驼峰” - 首字母小写,其余每个单词的首字母大写.比如studentAge 1数据类型 变量名 [= 变量值]; 123456789101112131415161718192021222324252627282930313233package tech.aistar.day01;public class VarDemo &#123; public static void main(String[] args) &#123; //数据存储在JVM的内存当中 //定义在方法内部的变量 - 局部变量[JVM的栈区] // 局部变量的生命周期是伴随着方法(main)的调用的开始和结束 //1.JVM加载VarDemo.class到内存 //2.JVM找到main方法想要去执行里面的程序 //3.此时需要申请一块区域来保存数据10 // 3-1.区域的大小是由前面的数据类型来决定的 比如:int类型需要申请4个字节32bit的大小的区域 // 3-2.栈里面的区域大小一旦被确定了,就不能改变,这样有时就会导致内存的浪费 // 3-3.虽然控件浪费了,但是读取的效率会提高 - 典型的&quot;以空间换时间&quot; 这也是为什么说栈的时间效率很高 //4.只要是内存中的空间,这个控件就必然会有一个地址,所以变量的存在是为了给这个区域取一个名字 // 比如说这个存储数据10的空间有一个地址,并且给它取了一个名字为a // 变量是为了方便用户来通过它访问到这个空间总存储的具体的那个值的. int a = 10; byte b = 10; short c = 20; long d = 10000; boolean e = true; float f = 13.14f; //注意一下float的定义喔! double g = 233.13; char h = &#x27;a&#x27;; System.out.println(a == b); &#125;&#125; 数据类型的转换一些小常识: a. java中看到一个整数,默认就是int类型 b.java中看到一个小数,默认就是double类型 c.大的数据类型和小的数据类型进行计算的时候,计算得到的结果是偏向类型大的一方. 自动转换 小的数据类型可以自动转换成大的数据类型 123byte -&gt; short -&gt; int -&gt; longchar -&gt; intint -&gt; double 强制类型转换 大的数据类型转换成小的数据类型的时候,需要进行强制类型转换的操作 123MaxType 变量1 = 值1;MinType 变量2 = (MinType)变量1; 1234567891011121314151617181920212223242526272829303132package tech.aistar.day01;/** * 数据类型的转换基础 */public class TypeChangeDemo &#123; public static void main(String[] args) &#123; //定义一个byte类型的数据[-128~127] byte b = 127; // 127 - 字面量,数字常量 - 不可改变的量 System.out.println(b); //变量 - 允许多次进行赋值 byte x = 126; //alt+enter可以自动进行强制转换 x = (byte) (x + 1); //注意一下:JVM看待字面量和变量是不同的. byte b2 = 127; //JVM判断出127是字面量,认为它是不可改变的. //JVM再次判断出127正好在byte类型的范围之内,所以精确判断出127可以存储在byte类型定义的变量中 //x = x + 1 这样就会报错 //jvm对待变量的方式,不关心这个变量中具体的数据到底是多大 //只要能够识别出x是byte类型,得出一个结论byte类型+int类型 = int类型 // 所以会报错 &#125;&#125; 一个小实例 12345boolean flag = true;while(flag)&#123; System.out.println(&quot;ddd&quot;);&#125;System.out.println(); 1234while(true)&#123; System.out.println(&quot;ddd&quot;);&#125;System.out.println(&quot;ddd&quot;); 在例子1中可以正常编译,例子2中会报错,就是因为JVM在对象常量和变量时的不同. 隐式转换 1234567int-&gt;long整数后面添加l/L double-&gt;float小数后面加上f/F 推荐在double后面加上d/D - 提高语义 变量的定义和使用八种数据类型的定义和使用 byte类型 1byte b = 127; short类型 - short很少使用 1short s = 155; int类型 - 存在多种情况 - java中的int类型表示的是十进制的数据 12345678//1.整数int a1 = 10;//2.二进制数:在定义二进制数时使用 0b二进制int a2 = 0b1010; //存储的是1010对应的十进制数10//3.字符int a3 = &#x27;a&#x27;; //存储的是字符&#x27;a&#x27;对应的ascii码(97)//4.八进制数:在定义八进制数时使用0八进制[以0开头]int a4 = 032; //存储的是032对应的十进制数26 long类型 - int类型可以自动转换为long类型 12long l1 = 145;long l2 = 1240L; //推荐此种定义方式,隐式转换法 补充:整型数再定义时可以用下划线将数字隔开,增加数字的可读性. 1234int x = 12_3_4_5;System.out.println(x); //结果为12345long l = 3_14_15_936L;System.out.println(l); //结果为31415936 float类型 - 两种方式 12345//1.强制类型转换float f1 = (float)1.34;//2.隐式转换float f2 = 1.34f;//以上两种结果都是一样滴 double类型 12double d1 = 1.25;double d2 = 1.25D; boolean类型 12boolean bl1 = true;boolean bl2 = false; char类型 java中使用单引号表示char类型,使用双引号来表示字符串 java的底层编码是unicode编码,char类型也是采用unicode编码 而unicode编码是双字节[16bit],所以可以用来存储汉字 12345678//1. 字符char c1 = &#x27;c&#x27;;//2. unicode码char c2 = &#x27;\\u5218&#x27;; //结果是刘//3. 汉字char c3 = &#x27;文&#x27;;//4. 数值char c4 = 48; //结果是0 char类型数的计算 - char类型在进行计算的时候会转换成ascii码来进行计算 123456789101112char n1 = &#x27;a&#x27; + 1; //结果是b// 过程: &#x27;a&#x27;-&gt;97 97+1=98 ascii码为98对应的字符是&#x27;b&#x27;char cc = &#x27;a&#x27;;//char nn = cc + 1;//这个会报错!因为cc是变量,并且是char类型的,char+int所以结果应该是int,不能赋值到char// 因此要进行强制转换char nn = (char)(cc + 1);//char--&gt;intint result = &#x27;a&#x27; + &#x27;b&#x27;; //ok//结果是97+98=195 变量的赋值 单个赋值:int a = 10; 通过表达式赋值 123int a = 10;int b = 20;int result = a + b; 链式赋值 1int a=19,b=20,c=39; //同时定义三个变量并进行初始化 先定义变量然后进行赋值 12int a;a = 10; 通过方法赋值 12345678910int result = getResult(); /** * 自定义了一个方法 - 千万不要将它放在main方法中 * java语法 - 方法体内部是不能够再去定义方法的 * @return 整数 */public static int getResult()&#123; return 100;&#125; 变量的分类 局部变量 - 定义在方法体内部 使用范围在它所在的最近的那个{}中 全局变量 - 定义在方法体外部的变量 生命周期 - 面向对象 12345678910111213141516171819202122package tech.aistar.day02;public class LocalVarAndGlobalDemo &#123; //定义全局变量 static int c = 100; public static void main(String[] args) &#123; //&#123;&#125;表示的是代码块 //局部变量 - 定义在方法体内部 int a = 10; &#123; //局部变量使用的范围就在它的最近的&#123;&#125;中 int b = 29; System.out.println(b); //ok System.out.println(a); //ok &#125; //System.out.println(b); //error 跳出&#123;&#125;以后b就无效了 System.out.println(c); //ok &#125;&#125; 常量使用final修饰的变量 - 常量 - 不可改变的量 语法: final 数据类型 变量 [= 初始值] 123456final int s = 100;// s = 200; //error 常量不可以改变final byte b = 100;byte result = b+1; //ok//如果不加final就会报错 运算符算术运算符12345678910111213141516171819201. + java语言中唯一重载[具有多个意义]的运算符 数值之间表示的加法运算,如果出现了&quot;字符串&quot;,表示拼接[后面就会知道拼接效率很低] 2. - 减法 * 乘法 3. / 除法[配合计算过程中需要注意的结果的类型而已] - 取整 4. % 取余/模 /和%结合使用,可以获取某个数字任意位上的数值. 5. += -= *= /= %= 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] 6. ++和-- 前++/后++ - 变量本身都会自增1 前--/后-- - 变量本身都会自减1 未来知道:开发中尽量不要使用,不是一个原子操作,导致多线程不安全. 底层会判断是否需要进行一个类型的窄化操作[类型的强制转换操作] + 123// + 在数值之间表示数值相加// + 在字符串之间表示连接System.out.println(1+2+3+&quot;&quot;+4+5); //结果为645 / 123System.out.println(9.0/2);//4.5System.out.println(9/2);//取整 4 % - 求模/余 1234567// 计算一个多位数每个位数的值int year = 2089;// 原则:任意数字%10 = 最末尾的数字System.out.println(year/1000); //千位数-2System.out.println(year/100%10); //百位数-0System.out.println(year/10%10); //十位数-8System.out.println(year%10); //个位数-9 ++ 和 – 123456789101112131415161718192021222324//现象//前++ 变量和表达式都会自增1int x1 = 1;int result1 = ++x1;System.out.println(&quot;result1:&quot;+result1);//2System.out.println(&quot;x1:&quot;+x1); //2//后++ , 变量仍然自增1,但是x2++的结果是这个x2变量自增之前的值// 表达式的结果是变量自增之前的值int x2 = 1;int result2 = x2++;System.out.println(&quot;result2:&quot;+result2);//1System.out.println(&quot;x2:&quot;+x2);//2System.out.println(&quot;========练习=========&quot;);int o1 = 1;int o2 = 1;//o1=2 o1=3 o2=0//o3 = 1 + 3 + 0 = 4int o3 = o1++ + ++o1 + --o2;//4 + 0int o4 = o3-- + o2++;System.out.println(&quot;o4:&quot;+o4); 逻辑运算符 &amp;&amp; - 逻辑与,短路与.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 所有的条件表达式都是返回true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为false的放在最左边 - 提高代码的执行效率. || - 逻辑或,短路或.作用不是用来进行计算的,而是用来连接条件[多个,条件表达式(包含比较运算符)]的. 为true - 只要有一个表达式是true,那么结果就是true 短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行. 推荐:将条件表达式结果最有可能为true的放在最左边 - 提高代码的执行效率. ! - 逻辑非,true成为false,false成为true 1234567891011121314151617181920//条件表达式//逻辑与 - 短路与System.out.println(10&gt;3 &amp;&amp; 5&lt;3);//true//短路的特性:当左边的条件表达式已经能够决定整个结果了,那么后面的条件表达式将不会执行.System.out.println(2&gt;3 &amp;&amp; 5&lt;3);//false//证明短路的特性int s1 = 1;System.out.println(5&gt;3 &amp;&amp; (++s1)&gt;10);System.out.println(s1);System.out.println(3&gt;2 || 2&lt;3);//trueSystem.out.println(!(2&gt;3));//trueSystem.out.println(10&gt;3 &amp; 3&gt;2);//trueSystem.out.println(10 &amp; 8); 位运算符 &amp; - 按位&amp;,非短路与,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:都是1,结果才是1.只要出现1个0,那么结果就是0 连接条件:为true - 所有的条件表达式都是返回true 123456710 &amp; 8 = 810 对应的二进制数 - 1010 1 0 1 0 &amp;1 0 0 0-------------------- 1 0 0 0 -&gt; 对应的十进制8 | - 按位或,非短路或,最主要的作用就是用来计算的,但是可以用来连接条件表达式. 计算:只要存在一个1,结果就是1 连接条件:为true - 只要存在一个条件表达式为true. 12345610 | 8 = 1 0 1 0 | 1 0 0 0-------------------- 1 0 1 0 -&gt; 对应的十进制10 异或^ 作用:进行计算的 - 相同为0,不同为1 12345678910111210 ^ 8 = 2 1 0 1 0 ^ 1 0 0 0-------------------- 0 0 1 0 -&gt; 对应的十进制2 10 ^ 8 ^ 8 = 10 0 0 1 0 ^ 1 0 0 0-------------------- 1 0 1 0 -&gt; 对应的十进制10 结论:一个数字连续异或同一个数字两次结果是它本身,可以进行加密和解密的操作 一个小实例:交换两个变量的值,不允许出现第三方变量 1234567891011121314151617public static void main(String[] args) &#123; // 方法一:一个数字连续异或同一个数字两次结果是它本身 int m = 100; int n = 200; m = m ^ n; n = m ^ n; m = m ^ n; System.out.println(&quot;m:&quot;+m); System.out.println(&quot;n:&quot;+n); // 方法二:管老师自创写法 int x = 100; int y = 200; y = x ^ (x = y) ^ y; System.out.println(&quot;x:&quot;+x); System.out.println(&quot;y:&quot;+y);&#125; 取反~,1变成0,0变成1 123 ~1 0 0 0-------------------- 0 1 1 1 补码 - 负数在计算机中的变现形式就是以补码的形式存在的 1234补码 = 反码 + 1反码 = 原码符号位不变,其余位依次取反符号位 - 最高位代表的是符号位=&gt;1代表的是负数,0代表的是正数反码本身是没有意义的,它的存在就是为了计算补码 题目:-10的二进制是多少?-10的补码是多少? 1234567-10的原码:10000000 00000000 00000000 00001010-10的反码:11111111 11111111 11111111 11110101-10的补码 = 反码 + 111111111 11111111 11111111 11110110最后这个就是-10的补码,也是-10的二进制 题目:计算~9 12300000000 00000000 00000000 0000100111111111 11111111 11111111 11110110最后这个是~9 发现~9 = -10 结论:-(x+1) = ~x 移位操作 笔试题 - 计算机性能最高的操作,jdk源码里面很多都是移位操作 12345678910111213141516171819202122232425&lt;&lt; 向左移动 2&lt;&lt;2 =&gt; 0010&lt;&lt;2 =&gt; 1000=8 原题:请你用最高性能的方式计算出2的3次方 &gt;&gt; 带符号的向右移动,向右移动多少位,那么就在最高位补符号位 -10 &gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 1111111111 11111111 11111111 111101 -&gt; 负数的二进制,最高位是1 要对这个负数进行求解可以参考结论-(x+1)=~x,因此对它取反 00000000 00000000 00000000 00000010 -&gt; 结果是3 表示那个数是~3 =&gt; 该数为-2 10 &gt;&gt; 2 00000000 00000000 00000000 00001010 &gt;&gt; 2 0000000000 00000000 00000000 000010 -&gt; 结果是2 &gt;&gt;&gt; 不带符号的右移动,向右移动多少位,就在最高位补0 -10 &gt;&gt;&gt; 2 11111111 11111111 11111111 11110110 &gt;&gt; 2 00111111 11111111 11111111 11111101 -&gt; 计算这个十进制(这个就是结果) 为了更好的计算,补齐后面的数,该十进制就等于如下式子 01000000 00000000 00000000 00000000 - 3 ------------------------------------ 1073741821 练习-15&gt;&gt;2 和-15&gt;&gt;&gt;2 123456789101112131415-15 = ~1411111111 111111111 11111111 11110001 &gt;&gt; 21111111111 111111111 11111111 11110011111111 111111111 11111111 11111100 这个就是结果,取反00000000 000000000 00000000 00000011 -&gt; ~3故结果为-411111111 111111111 11111111 11110001 &gt;&gt;&gt; 20011111111 111111111 11111111 11110000111111 111111111 11111111 11111100 这个就是结果,为了配好,所以+401000000 00000000 00000000 00000000- 4-----------------------------------1073741820 方法方法相当于其他语言中的函数function,功能是用来封装代码的逻辑. 把一段代码封装到方法中,方便以后复用,提高了代码的可维护性 语法1234修饰符 返回类型 方法名([参数列表]) [throw 可抛出的异常列表]&#123;...方法体...&#125;现阶段修饰符 返回类型 方法名([参数列表]) &#123;...方法体...&#125; 修饰符访问修饰符决定了这个方法可以被调用的范围 public - 公开的,公共的,如果一个方法被public进行修饰,那么代表这个方法可以在别的地方被调用. private - 私有的,只能在当前类内部被调用 - 体现了”封装性” - 不对外公开的 默认的 受保护的 特殊修饰符 static - 静态的 静态方法 - 使用static修饰的方法 非静态方法 - 没有使用static修饰的方法 是否为静态的方法决定了这个方法被调用的方式 返回类型 有返回类型 - 可以是八种基本数据类型,也可以是对象类型[内置对象类型或者自动以对象类型] 方法体的最终的出口一定有return返回值 12345678return 作用1 - 返回方法最终的执行结果 作用2 - 用来结束整个方法 正常情况方法的返回类型是什么,返回值的结果的类型也应该是什么非正常情况 - 支持类型的自动转换和强制类型转换调用的时候 - 需要使用数据类型和变量来接受这个方法调用的结果 方法的返回类型是什么,就用什么类型去定义,当然也支持类型的转换 无返回类型 - void 不需要使用return + 返回值; 应该如何选择 如果某个方法的执行结果可能在另外一个地方被使用到,那么一定要定义成有返回类型,如果一个方法仅仅是为了输出,只要定义void 123456789public static int test01(int m,int n)&#123; //code... return m和n的最大公约数&#125;public static int test02(int m,int n)&#123; int 公约数 = test01(m,n); return m*n/公约数;&#125;int n = test02(20,12); 方法名参考变量名的命名规则 - 一模一样 参数列表 无参列表 带参列表 1234//此处的age和name就是形参public static void add(int age,String name)&#123; System.out.println(age+&quot;:&quot;+name);&#125; 可变长列表 12345public static void sub(int...arr)&#123; //这里的arr表示数组 for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]); &#125;&#125; 参数的分类 形参 - 定义在方法的参数列表中的参数,目的是告诉这个方法的调用者在调用这个方法时需要传入的参数[个数以及类型],没有实际的值. 实参 - 方法的调用者在调用这个方法的时候传入的真正的参数 - 有真正的值. 如何定义方法 方法体的内部不能够再去定义方法了 main方法仍然是程序的主入口 自定义的方法希望能够被调用,那么最终肯定是在main方法中进行调用的 方法的调用方式取决这个方法是静态的还是非静态的 - static 1234567891011121314151617181920212223242526272829303132333435package tech.aistar.day02.method;public class MethodHelloDemo &#123; public static void main(String[] args) &#123; //1.调用公开的静态方法add MethodHelloDemo.add(); //2.调用公开的非静态方法sub //2.1首先创建对象 MethodHelloDemo m = new MethodHelloDemo(); //2.2利用对象调用方法 m.sub(); //整理笔记 //静态方法是属于类的,由类调用,它在JVM加载类进入内存时就分配空间并进行初始化 //非静态方法是属于对象的,只能由类的对象进行调用,每次创建对象的时候,给各自的非静态成员分配空间并进行初始化. &#125; /** * 定义了公开的静态的无返回类型的方法 */ public static void add()&#123; System.out.println(&quot;add...&quot;); &#125; /** * 定义了公开的非静态的无返回类型的方法 */ public void sub()&#123; System.out.println(&quot;sub...&quot;); &#125;&#125; 1.静态方法只能够直接调用静态方法 2.非静态方法中可以直接调用非静态方法以及静态方法 3.通用的原则 - 类名.静态方法或者对象.非静态方法 4.静态方法属于类拥有的,非静态方法属于对象拥有的 5.静态的方法是jvm加载类进内存的时候就会立即被分配空间以及初始化,并且仅有一次机会,而非静态方法必须是等到创建对象的时候,才会被分配空间以及初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package tech.aistar.day02.method;public class StaticDetailDemo &#123; // 在类中,属性和方法都属于类的成员 //定义全局变量 // 非静态的属性 int n = 19; //等创建对象的时候,才会分配空间和初始化 //静态属性 - 静态属性的初始化的时机优于静态方法 static int m = 199; public static void main(String[] args) &#123; //定义的全局变量n是非静态的,所以此时n还没有初始化,不能直接输出n //System.out.println(n); //error //但是可以直接输出m,因为m是静态的,在JVM加载内存的时候就已经分配了空间并且进行了初始化 System.out.println(m); //要输出n首先需要创建对象 StaticDetailDemo s1 = new StaticDetailDemo(); System.out.println(s1.n); &#125; //非静态方法 public void test01()&#123; System.out.println(&quot;test01...&quot;); &#125; //静态方法 public static void test02()&#123; //在静态方法中可以创建非静态局部变量 int n = 10; //这里可以想象一下 在main方法中可以创建非静态局部变量 System.out.println(&quot;test02...&quot;); // 静态方法中可以调用自定义的静态方法 // 1. 通过类.方法名 StaticDetailDemo.test04(); // 2. 省略类 test04(); // 静态方法中也可以调用非静态方法 // 通过对象.方法 StaticDetailDemo s1 = new StaticDetailDemo(); s1.test03(); &#125; //非静态方法 public void test03()&#123; System.out.println(&quot;test03...&quot;); //非静态方法中不允许定义静态的局部变量 根本就没有静态的局部变量这种东西! //static int n = 20; //error // 想象一下static都是JVM一开始加载的 但是非静态的必须要创建对象才可以 这样是不合理的 //非静态方法中调用静态方法 // 1.类名.方法 StaticDetailDemo.test04(); // 2.省略类 因为这个时候静态方法早已经加载好了 test04(); //非静态方法中调用非静态方法 this.方法 this.test01(); // 在实际写代码时可以省略this关键字,this表示的是当前对象 test01(); &#125; //静态方法 public static void test04()&#123; System.out.println(&quot;test04...&quot;); &#125;&#125; 方法调用补充 方法的调用者和方法的定义者在同一个类中 方法的调用者和方法的定义者不在同一个类中,但是仍然在同一个package中. 只能使用通用的原则类名.静态方法或对象.非静态方法 方法的调用者和方法的定义者是存在不同包的不同类中 必须先通过import关键字进行导包操作 使用jdk中的类的时候,除了java.lang包下的不需要手动import,其余包下的都需要先import 方法的重载(@overload)重载的要求: 重载的方法存在同一个类中 重载的方法方法名必须相同 重载的方法的参数列表必须不相同 重载的方法的返回类型可以不一样,可以一样 12345678910111213141516171819public static void main(String[] args) &#123; add(); //调用无参add方法 add(12,&quot;Tom&quot;); //调用有参add方法1 add(&quot;Lisa&quot;,10); //调用有参add方法2 &#125; public static void add()&#123; System.out.println(&quot;调用无参add方法&quot;); &#125; public static int add(int age,String n)&#123; System.out.println(n+&quot;:&quot;+age); System.out.println(&quot;调用有参add方法1&quot;); return age; &#125; public static int add(String n,int age)&#123; System.out.println(age+&quot;:&quot;+n); System.out.println(&quot;调用有参add方法2&quot;); return age; &#125; 方法重载的优点-&gt;简化api-方便调用 学会用api通过学习java.lang.Math - 数学工具类 - 提供了很多关于数学计算的方式 abs - 求绝对值 random - 随机数 - [0,1.0)之间 - double类型 注意在求随机整数时需要强制转换 floor -&gt; 返回小于或等于参数的最大（最接近正无穷大） double值，等于一个数学整数。 结合例子理解,注意负数的时候的使用 round -&gt; 返回参数中最接近的 long ，其中 long四舍五入为正无穷大。-&gt; round = floor(a+1/2) 同样结合例子理解,注意返回值是long 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; //绝对值 System.out.println(Math.abs(-12)); //12 //随机数 [0,1.0) System.out.println(Math.random()); //[1,100]之间随机的整数 int n1 = (int) (Math.random()*100+1); System.out.println(n1); //[3,5]之间的随机整数 //这里要注意分析 int n2 = (int) (Math.random()*3 + 3); System.out.println(n2); //两个数中的最大值/最小值 System.out.println(Math.max(10,15)); System.out.println(Math.max(10,15)); //floor方法 小于或等于 System.out.println(Math.floor(3.5)); //结果为3.0 System.out.println(Math.floor(3.0)); //结果为3.0 System.out.println(Math.floor(-3.5)); //结果为-4.0 System.out.println(Math.floor(-3.0)); //结果为-3.0 //round方法 四舍五入 这个需要注意一下:!!!返回值是long!!! //round = floor(a+1/2) System.out.println(Math.round(3.5)); //结果为4 System.out.println(Math.round(3.0)); //结果为3 System.out.println(Math.round(-3.5)); //结果为-3 System.out.println(Math.round(-3.0)); //结果为-3&#125; 语句三元操作符三目运算符 条件表法师?result1:result2 表达式为true,结果就是result1,否则结果是result2 支持无限嵌套,但是不推荐,因为可读性很差 m?(表达式?result1:result2):result2 if…else if语句单独使用场景 1234if(条件)&#123; code... code...&#125; {}可以省略的场景 - 如果if{}中的代码只有一行,那么{}可以省略,但是一定要缩进 123if(条件)&#123; code&#125; if…else…的使用 1234567if(条件)&#123; code... code...&#125;else&#123; code...&#125; 多条件分支if…else if…else… 1234567if(条件)&#123; code...&#125;else if(条件)&#123; code...&#125;else&#123; code...&#125; if…else语句可以无限嵌套使用 123456789101112131415if(条件)&#123; if(条件) code... else code...&#125;else if(条件)&#123; if(条件)&#123; code... &#125; else&#123; code... &#125;&#125;else&#123; code...&#125; 习题1.买奶茶,每第二杯半价,单价是10元.求总价. 1234567891011121314int n = 11; //奶茶的数量 double price = 10.0d; //奶茶的价格 // 10 5 10 5 10 5... //如果奶茶是双数杯-&gt; 一半是全价,一半是半价 //如果奶茶是单数杯-&gt; 一半加一杯是全价,一半是半价 double total = n/2 * price + n/2 * (price/2); // 判断是奇数 奇数&amp;1=1 if((n &amp; 1) == 1)&#123; total = total + price; &#125; System.out.println(total); 2.求某年某月最大天数 1234567891011121314151617181920212223242526/** * 判断某年是否为闰年 - (闰年%4=0 &amp;&amp; 闰年%100!=0) || 闰年%400 =0 * @param year 需要判断的年份 * @return */ public static boolean isLeapYear(int year)&#123; return ((year%4==0 &amp;&amp; year%100!=0) || year%400==0); &#125; /** * 求某年某月最大天数 * @param year * @param month * @return */ public static int getMaxDays(int year,int month)&#123; int days = 31; // 4,6,9,11 -&gt; 30 天 // 2 -&gt; 28/29天 // 其他-&gt;31天 if(month==4 || month==6 || month==9 || month==11) days = 30; else if(month == 2) days = isLeapYear(year)?29:28; return days; &#125; switch…caseswitch…case没有if…else灵活 语法 1234567891011switch(变量)&#123; case 值1: //code... [break]; case 值2: //code.. [break]; default: //code... [break];&#125; switch括号中变量的类型只能为byte short int char String enum Byte Short Integer Character 运行过程中如果进入到某个case块中执行,只有遇到break语句才会跳出switch块,如果没有遇到break语句,程序会自动进入到下一个case块中去执行. default语句可以省略,也可以放置在switch{}中的任意位置,但是推荐放置在末尾,如果switch括号中的变量没有匹配到任何的case后面的值,就会进入到default中. 循环语句while while属于后置循环 - 先判断循环条件是否成立,如果成立,则进入到循环体中,否则不执行循环 使用场景: 当不知道循环多少次,但是知道循环退出的条件的时候,优先选择while循环. 语法: 123while(条件)&#123; //循环体...&#125; 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; char c = &#x27;a&#x27;; while(c&lt;=&#x27;z&#x27;)&#123; System.out.print(c); c++; &#125; System.out.println(); //输出&#x27;A&#x27;-&#x27;Z&#x27; int n = 65; while(n&lt;=90)&#123; System.out.print((char)n); n++; &#125; System.out.println(); //死循环 int m = 0; while(true)&#123; System.out.print(m+&quot;\\t&quot;); if(m==10) break; m++; &#125; &#125; 死循环需要注意的点: 一定要有break,否则会一直处于死循环之中 注意要对变量进行操作,使它满足退出循环的条件 练习: 求两个数的最大公约数 12345678910public static int getMaxDivisor(int m,int n)&#123; int divisor = n; int first = m,second = n; while(divisor!=0)&#123; divisor = first % second; first = second; second = divisor; &#125; return first; &#125; 十进制转换为二进制 12345678910111213141516171819202122232425262728/** * 十进制转二进制 - String保存结果 * @param n */ public static void DecimalToBinary(int n)&#123; String result = &quot;&quot;; while(n!=0)&#123; result = n%2 + result; n=n/2; &#125; System.out.println(result); &#125; /** * 十进制转二进制 - int保存结果 * @param n */ public static void DecimalToBinary2(int n)&#123; int result = 0,count=0; while(n!=0)&#123; result = (int) (result + (n%2)*(Math.pow(10,count))); n = n/2; count++; &#125; System.out.println(result); &#125; for循环 单层for 123for(①表达式;②表达式;③表达式)&#123; //④循环体&#125; ①表达式 - 循环过程中变量的初始化操作 - 仅仅执行一次. ②表达式 - 循环退出的条件 - 至少执行一次 ③表达式 - 循环过程中,变量因子的变化 - 可能执行,可能不执行[取决于②表达式是否成立] 执行顺序: ① - ②[成立] - ④ - ③ - ②[成立] - ④ - ③ - … 怪异的写法 - 三个表达式都可以省略不写,或者写到其他地方 123for(;;)&#123; //死循环 - break打破循环&#125; for循环的复合形态 123for(同时定义若干个变量;条件;表达式)&#123; //循环体...&#125; 练习: 打印九九乘法表 12345678for (int i = 1,j=1; i &lt;9 ; j++) &#123; System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j + &quot;\\t&quot;); if(i==j)&#123; System.out.println(); j = 0; i++; &#125;&#125; 嵌套for循环,循环的层数不建议超过三层,嵌套越多,性能越低. 2-1.内外层无关 - 里面的for选中的时候可以单独执行,没有使用到外面for循环的变量因子 1234567//外层循环走一次,内层循环走全部for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 40; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println();&#125; 2-2 内外层相关 - 里面的for使用到了外面for循环的变量因子 123456for (int i = 0; i &lt;9 ; i++) &#123; for (int j = 0; j &lt;=i ; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println();&#125; 练习:打印所有的三位数,三位数由数字1,2,3,4组成,但是不能出现重复的,每打印四个换一行 1234567891011121314151617//定义计数器,用于换行int count = 0;for (int x = 1; x &lt;=4 ; x++) &#123; for (int y = 1; y &lt;=4 ; y++) &#123; for (int z = 1; z &lt;=4 ; z++) &#123; if(x!=y &amp;&amp; y!=z &amp;&amp; x!=z)&#123; System.out.print(x*100+y*10+z+&quot;\\t&quot;); count++; if(count==4)&#123; System.out.println(); count=0; &#125; &#125; &#125; &#125;&#125; 注意一下这里计数器的使用 do…while…do…while属于前置循环 - 无论循环条件是否成立,优先进入到循环体中执行一次,然后再判断条件,决定下一次是否会再次进入. 语法: 123do&#123; //循环体...&#125;while(条件); break语句 break可以跳出switch块. break可以打破它所在的那一层循环. continue语句它只能出现在循环体中,跳过本轮循环,继续执行下一轮循环. 1234567for (int i = 0; i &lt;10 ; i++) &#123; if(i==5)&#123; //break; //结果:01234 continue; //结果:012346789 &#125; System.out.print(i); &#125; 数组 数组的诞生 - 为了解决单个变量只能存储单个知道缺点 数组本身也属于数据结构[数组,栈,堆,树,链表,图] 数组属于对象类型,数组是存在在JVM内存的堆区,基本类型存储在JVM内存的栈区. 数组在内存中一定是一块连续的空间 数组的大小[长度]一旦确定了,就不能改变 语法121. 元素类型[] 变量名 = new 元素类型[size] //推荐使用这种2. 元素类型 变量名[] = new 元素类型[size] 元素类型就是数据类型[8种基本数据类型以及对象类型],决定了这个数组中可以存放的数据的类型 123//arr的数据类型是什么?int[]-&gt;整数型数组// 定义一个长度为3的int型数组int[] arr = new int[3]; 赋值方式如果定义了数据,但是没用对其进行赋值操作,那么系统会默认分配一个默认值.默认值由元素类型决定.byte,short,int,long -&gt; 0float,double -&gt; 0.0boolean -&gt; falsechar -&gt; 空格对象类型 -&gt; null 首先定义数组,然后通过下标一一赋值 下标的范围[0,数组长度-1] 1234int[] arr = new int[3];arr[0] = 10;arr[1] = 10;arr[2] = 10; 如果下标不在此范围,控制台抛出java.lang.ArrayIndexOutOfBoundsException 数组下标越界异常 定义数组的同时进行赋值 12int[] arr= &#123;3,4,5&#125;;int[] arr = new int[]&#123;3,4,5&#125;; 通过普通for循环语句去赋值 1234int[] arr = new int[3];for(int i=0;i&lt;arr.length;i++)&#123; arr[i] = (int)(Math.random()*100+1); //[1,100]的随机数&#125; 获取数组的值 通过下标一一取值 1System.out.println(arr[下标]); 数组提供了属性length - 获取数据的长度,通过普通for循环进行遍历 123for(int i = 0; i &lt; arr.length; i++)&#123; System.out.println(arr[i]);&#125; 使用jdk5.x提供的增强for循环的语法,属于只读的for循环 1234567for(元素类型 元素变量:数组变量名)&#123; System.out.println(元素);&#125;for (int i:arr)&#123; System.out.print(i); &#125; 数组的内存通过new关键字在JVM的堆区中开辟新的空间01,用来存储这个对象{10,20,30},然后将这个对象在堆空间中的内存地址赋值给了引用变量arr1,这个变量存储在栈区中. arr1的本质不是对象,只是一个引用变量. 引用变量中存储的是对象在堆中的内存地址.并且一个引用变量在同一时刻只能指向一个对象,一个对象在同一时刻可以被多个引用指向. 12345int[] arr1 = new int[]&#123;10,20,30&#125;;int[] arr2 = &#123;10,20,30&#125;;arr1 = arr2; //执行完本条语句后,arr1和arr2都是指向第二次创建出来的数组对象//原来第一次创建出来的对象就称为内存中的垃圾对象[没有任何引用指向的对象],会由GC[垃圾回收线程]进行回收并释放内存. 123456int[] arr = &#123;1,3,4,7&#125;; //arr是引用变量,指向该数组在堆区中的地址System.out.println(arr); //打印的是arr的值,也就是数组的地址[I@1b6d3586int[] arr2 = &#123;1,3,4,7&#125;;System.out.println(arr == arr2); //false//因为==始终比较的是值,也就是arr和arr2所代表的值,即两个数组的地址,是不同的,所以是false 方法的参数传递方式 基本类型采用值传递 - 形参的改变不影响实参 12345678910111213141516public static void main(String[] args) &#123; //基本类型采用值传递 int a=10,b=20; //将a,b变量中保存的具体的值拷贝一份赋值给了方法参数中的那俩个变量m,n //所以m和n的改变不影响a,b add(a,b); System.out.println(&quot;main-a:&quot;+a); //10 System.out.println(&quot;main-b:&quot;+b); //20 &#125; private static void add(int m, int n) &#123; m = m + 10; n = n + 10; System.out.println(&quot;add-m:&quot;+m); //20 System.out.println(&quot;add-n:&quot;+n); //30 &#125; 对象类型[引用类型]采用地址传递 12345678910111213public static void main(String[] args) &#123; //对象类型采用的是地址传递/引用传递 int[] arr = &#123;1,3,4,5&#125;; add(arr); System.out.println(&quot;main-arr[3]:&quot;+arr[3]); //15 &#125; private static void add(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] += 10; &#125; System.out.println(&quot;add-arr[3]:&quot;+arr[3]); //15 &#125; 总结:Java中只有值传递,没有地址传递.对象类型[引用类型]看起来是地址传递,但是实际上传递的是引用变量的值,这个值表示的是地址. 注意String类型虽然是一个对象类型,但是具备基本类型传递的特点 12345678910public static void main(String[] args) &#123; String s = &quot;Hello&quot;; add(s); System.out.println(&quot;main-s:&quot;+s);&#125;private static void add(String s) &#123; s += &quot;Sakura&quot;; System.out.println(&quot;add-s:&quot;+s); //main-s:Hello&#125; 一个重点题目: 1234567891011121314public static void main(String[] args) &#123; int[] arr1 = &#123;10&#125;; int[] arr2 = &#123;20&#125;; change(arr1,arr2); System.out.println(&quot;main-arr1[0]:&quot;+arr1[0]); System.out.println(&quot;main-arr2[0]:&quot;+arr2[0]); &#125; private static void change(int[] arr1, int[] arr2) &#123; arr2[0] = 100; arr1 = arr2; System.out.println(&quot;change-arr1[0]:&quot;+arr1[0]); System.out.println(&quot;change-arr2[0]:&quot;+arr2[0]); &#125; 图片虽然有些草率,能看懂大致意思即可. 二维数组定义 数据类型 变量 = 初始化; 数据类型 - 八种基本数据类型以及对象类型 数组本身就属于对象类型 1int[] arr =new int[3]; //arr的数据类型int[],整数型数组,int型数组 元素类型[] 变量名 = new 元素类型[数组长度]; 123int[][] 变量名 = new int[rows][cols];//元素类型决定了数组中可以存放的数据类型//二维数组中的每个元素就是一堆数组 123//定义一个3行2列的int型二维数组int[][] arr = new int[3][2];int arr[][] = new int[3][2]; 一定要理解一下,二维数组的每个元素就是一个一维数组 在定义的时候,列可以省略,行不能省略 赋值方式 通过下标一一赋值 12int[][] arr = new int[3][2];arr[0][0] = 100; 定义二维数组的同时进行赋值 12int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;int[][] arr2 = new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;; 先定义一个数组,然后一行一行进行赋值 1234int[][] arr = new int[3][3];//arr[0] = &#123;1,2,3&#125;; //error//注意一下这个每行进行赋值不能省略newarr[0] = new int[]&#123;1,2,3&#125;; 定义一个不规则的二维数组 1234int[][] arr4 = new int[3][];arr4[0] = new int[]&#123;1&#125;;arr4[1] = new int[]&#123;1,2&#125;;arr4[2] = new int[]&#123;1,2,3&#125;; 遍历方式 通过下标一一输出 通过单层for循环输出 123for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(Arrays.toString(arr[i]));&#125; 双层for循环 123456for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.print(arr[i][j]+&quot;\\t&quot;); &#125; System.out.println();&#125; 利用java.util.Arrays工具类中的方法 1System.out.println(Array.deepToString(arr)); 增强型for循环 123456for (int[] i : arr2) &#123; for (int i1 : i) &#123; System.out.print(i1+&quot;\\t&quot;); &#125; System.out.println();&#125; 实例:二维数组的行列转换 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; String[][] arr = new String[4][6]; arr[0]=new String[]&#123;&quot;白&quot;,&quot;日&quot;,&quot;依&quot;,&quot;山&quot;,&quot;尽&quot;,&quot;,&quot;&#125;; arr[1]=new String[]&#123;&quot;黄&quot;,&quot;河&quot;,&quot;入&quot;,&quot;海&quot;,&quot;流&quot;,&quot;.&quot;&#125;; arr[2]=new String[]&#123;&quot;欲&quot;,&quot;穷&quot;,&quot;千&quot;,&quot;里&quot;,&quot;目&quot;,&quot;,&quot;&#125;; arr[3]=new String[]&#123;&quot;更&quot;,&quot;上&quot;,&quot;一&quot;,&quot;层&quot;,&quot;楼&quot;,&quot;.&quot;&#125;; change(arr); &#125; private static void change(String[][] arr) &#123; // 注意一下这个新建的二维数组的元素个数 String[][] temp = new String[6][4]; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; temp[j][i] = arr[i][j]; &#125; &#125; //打印输出 for (String[] strings : temp) &#123; for (String string : strings) &#123; System.out.print(string+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; 递归算法 方法体中调用方法自己本身 递归算法的方法体中一定要出现递归的出口,否则会抛出java.lang.StackOverflowError - 堆栈溢出错误 使用场景:适合解决大量的,重复性的业务题 缺点:性能比较低,将每次计算的结果都会保存在内存中. 获取键盘输入 java.util.Scanner键盘类 如何构建这个Scanner对象 1Scanner sc = new Scanner(System.in); 方法 3-1. int nextInt();//只能获取整数 3-2. double nextDouble();//获取小数 3-3. String nextLine();//获取字符串 注意点:nextLine不要和nextInt或者nextDouble混用.","categories":[],"tags":[{"name":"Scanner","slug":"Scanner","permalink":"http://beautifulboyy/tags/Scanner/"},{"name":"变量","slug":"变量","permalink":"http://beautifulboyy/tags/%E5%8F%98%E9%87%8F/"},{"name":"方法","slug":"方法","permalink":"http://beautifulboyy/tags/%E6%96%B9%E6%B3%95/"},{"name":"循环语句","slug":"循环语句","permalink":"http://beautifulboyy/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"数组","slug":"数组","permalink":"http://beautifulboyy/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Java算法学习","slug":"javastudy-algorithm","date":"2021-07-20T08:34:09.000Z","updated":"2021-08-02T02:15:00.912Z","comments":true,"path":"2021/07/20/javastudy-algorithm/","link":"","permalink":"http://beautifulboyy/2021/07/20/javastudy-algorithm/","excerpt":"","text":"简单算法题整数的逆序给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:34 * @description 给一个的正整数，要求：一、求它是几位数，二、逆序打印出各位数字. */public class ReverseNumber &#123; /** * 获取正整数的位数 * @param num 输入的正整数 * @return */ public static int getDigit(int num)&#123; int digit = 0; while(num!=0)&#123; digit++; num = num/10; &#125; return digit; &#125; /** * 直接逆序输出正整数 * @param num 输入的正整数 */ public static void reverseNumber(int num)&#123; while(num!=0)&#123; System.out.print(num%10+&quot;\\t&quot;); num = num/10; &#125; System.out.println(); &#125; /** * 把逆序的正整数保存在String类型的字符串中 * @param num * @return */ public static String reverseNumberByString(int num)&#123; String str = &quot;&quot;; while(num!=0)&#123; str += num%10; num = num/10; &#125; return str; &#125; /** * 正整数的逆序,逆序的结果仍然是int型 * @param num * @return */ public static int reverseNumberByInt(int num)&#123; int result = 0; while(num!=0)&#123; result = result*10 + num%10; num = num/10; &#125; return result; &#125; public static void main(String[] args) &#123;// System.out.println(getDigit(1247));// reverseNumber(1247); System.out.println(reverseNumberByString(1247)); System.out.println(reverseNumberByInt(1247)); &#125;&#125; 判断回文数一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同 12345678910111213141516171819202122232425package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:43 * @description 一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同 * 思路 - 判断这个数逆序之后的结果是否与原来的数相等 */public class JudgePalindrome &#123; public static boolean judge(int num)&#123; int result = ReverseNumber.reverseNumberByInt(num); if(result == num) return true; return false; &#125; public static void main(String[] args) &#123; System.out.println(judge(123)); System.out.println(judge(12321)); System.out.println(judge(1221)); &#125;&#125; 打印水仙花数打印出所有的 “水仙花数 “,所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。 例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方 1234567891011121314151617181920212223242526272829303132package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:46 * @description 打印水仙花数 * 打印出所有的 &quot;水仙花数 &quot;,所谓 &quot;水仙花数 &quot;是指一个三位数，其各位数字立方和等于该数本身。 * 例如：153是一个 &quot;水仙花数 &quot;，因为153=1的三次方＋5的三次方＋3的三次方 */public class PrintNumberOfDaffodils &#123; public static boolean judge(int num)&#123; int result = 0; result = (int) (Math.pow(num/100,3) + Math.pow(num/10%10,3) + Math.pow(num%10,3)); if(result == num) return true; return false; &#125; public static void print()&#123; for (int i = 100; i &lt; 1000; i++) &#123; if(judge(i)) System.out.print(i+&quot;\\t&quot;); &#125; &#125; public static void main(String[] args) &#123; print(); &#125;&#125; 结果:153 379 371 407 判断完数一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。 例如6=1＋2＋3.编程找出1000以内的所有完数 123456789101112131415161718192021222324252627282930313233343536373839404142package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 15:55 * @description 判断完数 * 一个数如果恰好等于它的因子之和，这个数就称为 &quot;完数 &quot;。 * 例如6=1＋2＋3.编程找出1000以内的所有完数 */public class JudgePerfectNumber &#123; /** * 判断完数 * @param num * @return */ public static boolean judge(int num)&#123; int result = 0; //存储因子的结果 for (int i = 1; i &lt;num ; i++) &#123; if(num%i==0) result += i; &#125; if(result == num) return true; return false; &#125; /** * 打印1000以内的完数 */ public static void print()&#123; for(int i=1;i&lt;1000;i++)&#123; if(judge(i)) System.out.print(i+&quot;\\t&quot;); &#125; &#125; public static void main(String[] args) &#123; print(); &#125;&#125; 结果:6 28 496 打印菱形打印如下图形,空心的和实心的 123456789* 4 * * 3 5 * * 2 6 * * 1 7 * * 0 8 * * 1 7 * * 2 6 * * 3 5 * 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 16:05 * @description 打印菱形 * 找规律 - 找i和j之间的关系 * * 4 i=0,j=4; * * * 3 5 i=1,j=3,j=5; * * * 2 6 i=2,j=2,j=6; * * * 1 7 i=3,j=1,j=7; * * * 0 8 i=4,j=0,j=8; * * * 1 7 i=5,j=1,j=7; * * * 2 6 i=6,j=2,j=6; * * * 3 5 i=7,j=3,j=5; * * 4 i=8,j=4; * * 左上的边:i+j=4 * 右上的边:j-i=4 * 左下的边:i-j=4 * 右下的边:i+j=12 */public class PrintDiamond &#123; public static void printHollowDiamond()&#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt;9 ; j++) &#123; if(i+j==4 || j-i==4 || i-j==4 || i+j==12) System.out.print(&quot;*&quot;); else System.out.print(&quot; &quot;); &#125; System.out.println(); &#125; &#125; public static void printSolidDiamond()&#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt;9 ; j++) &#123; if(i+j&lt;4 || j-i&gt;4 || i-j&gt;4 || i+j&gt;12) System.out.print(&quot; &quot;); else System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125; public static void main(String[] args) &#123; printHollowDiamond(); printSolidDiamond(); &#125;&#125; 判断素数输出[1~199]之间所有的质数,并且每打印7个换一行 123456789101112131415161718192021222324252627282930313233343536373839404142package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/25 20:10 * @description 判断素数 * 输出[1~199]之间所有的质数,并且每打印7个换一行 */public class JudgePrime &#123; public static boolean judge(int num) &#123; boolean flag = true; // 注意一下范围是Math.sqrt() for (int i = 2; i &lt;= Math.sqrt(num); i++) &#123; if (num % i == 0) &#123; flag = false; break; &#125; &#125; return flag; &#125; public static void print()&#123; int count = 0; for (int i = 2; i &lt;200 ; i++) &#123; if(judge(i))&#123; System.out.print(i+&quot;\\t&quot;); count++; if(count==7)&#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; //System.out.println(judge(13)); print(); &#125;&#125; 求某年某月的最大天数12345678910111213141516171819202122232425262728293031323334353637383940package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 8:11 * @description 求某年某月的最大天数 */public class GetMaxDay &#123; public static boolean isLeapYear(int year)&#123; if((year%4 == 0 &amp;&amp; year%100!=0) || year%400 == 0) return true; return false; &#125; /** * 获取某年某月的最大天数 * @param year * @param month * @return */ public static int getMaxDay(int year,int month)&#123; int days = 31; if(month == 4 || month == 6 || month == 9 || month == 11)&#123; days = 30; &#125;else if(month == 2)&#123; // 判断平闰年 if(isLeapYear(year)) days = 29; days = 28; &#125; return days; &#125; public static void main(String[] args) &#123; System.out.println(getMaxDay(2021,2)); &#125;&#125; 斐波那契数列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 8:32 * @description 斐波那契数列 * 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 */public class FeiBoNaQi &#123; /** * 递归实现求斐波那契数列中第n个数的值 * @param n * @return */ public static int getFei(int n)&#123; if(n==1 || n==2) return 1; return getFei(n-1) + getFei(n-2); &#125; /** * 循环实现求斐波那契数列中第n个数的值 * @param n * @return */ public static int getFei2(int n)&#123; int first = 1,second=1; int result = 0; if(n==1 || n==2) return 1; int i = 3; while(i&lt;=n)&#123; result = first + second; first = second; second = result; i++; &#125; return result; &#125; public static void main(String[] args) &#123; //System.out.println(getFei(10)); System.out.println(getFei2(10)); &#125;&#125; 求阶乘123456789101112131415161718192021222324252627282930313233343536373839package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 11:13 * @description 求阶乘! * 1! = 1 * 2! = 1 * 2 = 2 * 3! = 1 * 2 * 3 = 6 */public class GetFactorial &#123; /** * 利用递归求阶乘 * @param n * @return */ public static int getFactorial(int n)&#123; if(n==1) return 1; return n*getFactorial(n-1); &#125; public static int getFactorial2(int n)&#123; if (n==1) return 1; int i = n; int result = 1; while(i&gt;0)&#123; result = result * i; i--; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getFactorial(4)); &#125;&#125; 求最大公约数和最小公倍数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 14:55 * @description 求两个数的最大公约数和最小公倍数 */public class GetCommonDivisor &#123; /** * 递归求最大公约数 * * @param m * @param n * @return */ public static int getDivisor2(int m, int n) &#123; if (m % n == 0) return n; return getDivisor2(n, m % n); &#125; /** * 求两个数的最大公约数 * 20 12 * 20 % 12 = 8 * 12 % 8 = 4 * 8 % 4 = 0 * @param m * @param n * @return */ public static int getDivisor(int m,int n)&#123; int first = m,second = n,result = first % second; while(result!=0)&#123; result = first % second; first = second; second =result; &#125; return first; &#125; /** * 求最小公倍数 * 最小公倍数 = m*n/最大公约数 * @param m * @param n * @return */ public static int getMultiple(int m,int n)&#123; return m*n/getDivisor(m,n); &#125; public static void main(String[] args) &#123; System.out.println(getDivisor(12,20)); System.out.println(getMultiple(12,20)); &#125;&#125; 十进制转二进制12345678910111213141516171819202122232425262728293031323334353637package tech.aistar.algorithm;/** * @Author liuWenXiu * @Date 2021/7/26 14:56 * @description 十进制转二进制 */public class DecimalToBinary &#123; /** * 十进制转二进制 * 10 -&gt; 1010 * 10 / 2 = 5 ... 0 * 5 / 2 = 2 ... 1 * 2 / 2 = 1 ... 0 * 1 / 2 = 0 ... 1 * * @param n * @return */ public static int getBinary(int n) &#123; int result = 0; int count = 0; while (n!=0) &#123; int j = n % 2; result = (int) (result + Math.pow(10, count++) * j); n = n/2; &#125; return result; &#125; public static void main(String[] args) &#123; System.out.println(getBinary(12)); &#125;&#125; 杨辉三角12345public static int yang(int x,int y)&#123; if(x==y || y==0) return 1; return yang(x-1,y-1) + yang(x-1,y);&#125; 一维数组根据值删除元素123456789101112131415161718192021222324252627282930public static int[] deleteByTarget(int[] arr,int target)&#123; // 0.首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1. 首先判断数组中有几个这个值 // 定义count记录 int count = 0; for (int i : arr) &#123; if(i==target) count++; &#125; // 2. 根据结果进行下一步 // 2.1如果count=0,表示没有该值,直接返回原数组 if(count == 0) return arr; // 2.2 如果count不为0,则定义一个新的数组,数组长度为原数组长度-count int[] newArr = new int[arr.length-count]; // 2.3 将arr中除了target以外的值都复制到newArr中 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(!(arr[i] == target)) newArr[pos++] = arr[i]; &#125; // 3.最后返回新的数组 return newArr;&#125; 根据下标删除数组123456789101112131415public static int[] deleteByIndex(int[] arr,int index)&#123; // 要求删除指定下标,而下标是唯一的 // 1.首先判断下标是否合法 if(null==arr || arr.length==0 || index&lt;0 || index&gt;=arr.length) return new int[]&#123;-1&#125;; // 2.定义新的数组,数组长度为原来的长度-1 int[] newArr = new int[arr.length-1]; // 3.循环赋值 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(i!=index) newArr[pos++] = arr[i]; &#125; return newArr;&#125; 数组的去重 - 三种方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 数组的去重 * 思路:将数组的值放到另一个数组中,每次放入一个数,都删掉所有与它值相同的数 * @param arr * @return */public static int[] delDoubleElement(int[]arr)&#123; // 0.首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1.首先定义一个新的数组,用于存储去重后的数据 int[] newArr = new int[arr.length]; // 2.遍历arr数组 int pos = 0; while(arr.length!=0)&#123; // 3. 每次都将arr[0]添加到newArr中 newArr[pos++] = arr[0]; // 4. 删除数组中所有值为arr[0]的元素 arr = deleteByTarget(arr,arr[0]); &#125; // 5.此时得到的newArr数组的末尾可能会有0 // 利用Arrays.copyOf()方法复制 newArr = Arrays.copyOf(newArr,pos); return newArr;&#125;/** * 数组的去重 - 方法二 * 遍历元素,将该元素和后面的所有元素进行比较,如果相同,就删除后面的元素 * @param arr * @return */public static int[] delDoubleElement2(int[]arr)&#123; // 首先判断参数的合法性 if(null == arr || arr.length==0) return arr; // 1.遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; // 遍历数组之后的值 for (int j = i+1; j &lt; arr.length; j++) &#123; if(arr[i] == arr[j])&#123; // 别忘了给arr重新赋值 arr = deleteByIndex(arr,j); j--; &#125; &#125; &#125; return arr;&#125;/** * 数组的去重方法三 - 利用boolean类型的数组 -&gt; 不需要依赖按下标删除或按元素删除的方法 * @param arr * @return */public static int[] delDoubleElement3(int[]arr)&#123; if(null == arr || arr.length == 0) return arr; // 1. 定义一个boolean类型的数组 boolean[] flag = new boolean[arr.length]; // 2.利用Arrays.fill方法为flag数组赋值,所有的值都赋值为true Arrays.fill(flag,true); // 3. 遍历数组 如果元素在前面已经出现过,同样的位置上,flag设置为false for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if(arr[i] == arr[j]) flag[j] = false; &#125; &#125; // 4.统计true的个数,新数组的长度就是true的个数 int count = 0; for (int i = 0; i &lt; flag.length; i++) &#123; if(flag[i]) count++; &#125; // 5.定义新的数组 int[] newArr = new int[count]; // 6.进行赋值,如果值是false就不赋值 int pos = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if(flag[i]) newArr[pos++] = arr[i]; &#125; return newArr;&#125; 排序冒泡排序12345678910111213141516171819/** * 冒泡排序 - 两两比较 * @param arr * @param flag flag为true表示从小到大排序,flag为false表示从大到小排序 */public static int[] bubble(int[] arr,boolean flag)&#123; //遍历数组 for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = 0; j &lt; arr.length-1-i; j++) &#123; if(flag?arr[j]&gt;arr[j+1]:arr[j]&lt;arr[j+1])&#123; //进行值交换 arr[j] = arr[j] ^ arr[j+1]; arr[j+1] = arr[j] ^ arr[j+1]; arr[j] = arr[j] ^ arr[j+1]; &#125; &#125; &#125; return arr;&#125; 选择排序123456789101112131415161718/** * 选择排序 - 将第一个数和后面所有的数相比,如果不符合需求则交换值 * @param arr * @param flag flag为true表示从小到大,flag为false表示从大到小 * @return */public static int[] select(int[] arr,boolean flag)&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = i+1; j &lt;arr.length ; j++) &#123; if(flag?arr[i]&gt;arr[j]:arr[i]&lt;arr[j])&#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; &#125; &#125; return arr;&#125; 直接插入排序1234567891011121314151617181920 /** * 直接插入排序 - 前面的序列是有序序列,每次插入一个,都要插入在正确的位置 * @param arr * @param flag flag为true表示从小到大,flag为false表示从大到小 * @return */public static int[] insert(int[] arr,boolean flag)&#123; //下标从1开始 for (int i = 1; i &lt; arr.length; i++) &#123; // 从第二个数开始比较 for (int j = i; j &gt;0 ; j--) &#123; if(flag?arr[j]&lt;arr[j-1]:arr[j]&gt;arr[j-1])&#123; arr[j] = arr[j] ^ arr[j-1]; arr[j-1] = arr[j] ^ arr[j-1]; arr[j] = arr[j] ^ arr[j-1]; &#125; &#125; &#125; return arr;&#125; 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /** * 找基准数 * @param arr * @param start * @param end * @return */public static int getIndex(int[] arr,int start,int end)&#123; int i = start; int j = end; int x = arr[i]; //每次都先将arr[i]设为基准数 即x为基准书 while(i&lt;j)&#123; // 从右往左如果大于等于基准数则继续向左 即j-- while(i&lt;j &amp;&amp; arr[j]&gt;=x)&#123; j--; &#125; if(i&lt;j)&#123; // 此时表示从右往左找到了一个数小于基准数,那么进行占坑操作 arr[i] = arr[j]; // 在占坑以后i的指向要往后一位 i++; &#125; // 从左往右如果小于等于基准数则继续向右 即i++ while(i&lt;j &amp;&amp; arr[i]&lt;x)&#123; i++; &#125; if(i&lt;j)&#123; // 此时表示从左往右找到了一个数大于基准数,那么进行占坑操作 arr[j] = arr[i]; // 在占坑以后j的指向要往前一位 j--; &#125; &#125; //退出循环的时候 表示i&gt;=j 这个时候找到了基准数 // 所以要给基准数赋值 arr[i] = x; return i; //基准数的位置&#125;public static void quickStart(int[] arr,int start,int end)&#123; if(start&lt;end)&#123; int index = getIndex(arr,start,end); quickStart(arr,0,index-1); quickStart(arr,index+1,end); &#125;&#125; 递归类型 求某个数的阶层 12345678910111213 /** * 求某个数的阶层 * 1 = 1 * 2 = 2 * 1 * 3 = 3 * 2 *1 * @param n * @return */public static int jie(int n)&#123; if(n==1) return 1; return n*jie(n-1);&#125; 求斐波那契数列 1234567891011 /** * 斐波那契数列 * //1 1 2 3 5 8 13 21 34 55 ... * @param n * @return */public static int Fibonacci(int n)&#123; if(n==1 || n==2) return 1; return Fibonacci(n-1)+Fibonacci(n-2);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://beautifulboyy/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"hexo和github部署","slug":"blog-deployment","date":"2021-07-15T10:08:42.000Z","updated":"2021-07-31T12:20:39.509Z","comments":true,"path":"2021/07/15/blog-deployment/","link":"","permalink":"http://beautifulboyy/2021/07/15/blog-deployment/","excerpt":"","text":"博客项目Hexo安装 1.首先在某个盘目录下新建文件夹,假设为hello-hexo,这是博客项目的根目录 2.打开终端通过dos命令进入到hello-hexo目录中,输入以下命令 1&gt;E:/cxstudy/hello-hexo&gt;npm install hexo-cli -g 创建真正的博客目录12E:/cxstudy/hello-hexo&gt;hexo init hello-studyE:/cxstudy/hello-hexo/hello-study&gt;nmp install 测试-启动博客服务器启动服务器代码: 1E:/cxstudy/hello-hexo/hello-study&gt;hexo s 关闭服务器:ctrl+c 打开浏览器输入:localhost:4000 主题模板的安装使用 优质主题模板:https://blog.csdn.net/zgd826237710/article/details/99671027 可以在该博客中找到自己想要的主题进行下载(从github上直接clone) 1.通过cmd进入到hello-study目录中的themes目录中 2.通过git clone命令进行克隆 12&gt;E:/cxstudy/hello-hexo/hello-study&gt;cd themes&gt;E:/cxstudy/hello-hexo/hello-study/themes&gt;git clone https://gitee.com/guancg/hexo-theme-pure.git 配置主题模板1.指定新的主题 修改hello-study目录下的_config.yml文件 1theme: hexo-theme-pure 2.修改个人信息 修改hexo-theme-pure目录下的_config.yml文件 12345678profile: enabled: true # Whether to show profile bar avatar: images/avatar.jpg author: Sakurayo author_title: Web Developer author_description: I have nothing to say。 location: Shangrao, China follow: https://github.com/beautifulboyy 3.添加主题侧边栏 为了使得侧边栏的链接生效,将hello-study/themes/hexo-theme-pure/_source下的除了_data文件夹,其余文件夹拷贝一份到hello_study目录下的source目录中即可. 4.博客的语言环境设置 修改hello-study目录下的_config.yml文件 1language: zh-CN 5.设置图片的显示 首先需要安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm install https://gitee.com/guancg/hexo-asset-image.git --save 配置hello_study目录下的_config.yml文件 1post_asset_folder: true 6.内置搜索功能的实现 安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm i -S hexo-generator-json-content 7.评论功能的实现 评论功能不需要本地数据库进行存储,用的是第三方的LeanCloud 注册 - 登录 - 控制台 - 创建应用 - 右下设置 - 应用凭证 复制appId和appKey 在hexo-theme-pure目录下的_config.yml文件中进行配置 123valine: # Valine. https://valine.js.org appid: 复制的appid # your leancloud application appid appkey: 复制的appkey 8.字数统计和阅读时长功能的实现 安装插件,输入以下代码[插件安装一次即可,以后就不用安装了] 新建工程需要安装! 1npm i -S hexo-wordcount 在hexo_theme-pure目录下的_config.yml文件中配置 1234postCount: enable: true wordcount: true # 文章字数统计 min2read: true # 阅读时长预计 9.项目展示功能的实现 配置hexo_theme-pure目录下的_config.yml文件 12github: username: beautifulboyy # github username 新建博文1E:/cxstudy/hello-hexo/hello-study&gt;hexo n blog-deployment 部署到github中首先创建新的repository,命名规则为:用户名.github.io 例如:[beautifulboyy.github.io] 修改hello-study目录下的_config.yml文件 1234deploy: type: &#x27;git&#x27; repo: &#x27;https://github.com/beautifulboyy/beautifulboyy.github.io.git&#x27; branch: &#x27;master&#x27; 然后进行hexo三连操作 1234hexo clhexo ghexo shexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://beautifulboyy/tags/hexo/"}]}],"categories":[{"name":"java基础","slug":"java基础","permalink":"http://beautifulboyy/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"内置类的使用","slug":"内置类的使用","permalink":"http://beautifulboyy/categories/%E5%86%85%E7%BD%AE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"name":"项目","slug":"项目","permalink":"http://beautifulboyy/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"框架","slug":"框架","permalink":"http://beautifulboyy/categories/%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","permalink":"http://beautifulboyy/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"DTL","slug":"DTL","permalink":"http://beautifulboyy/tags/DTL/"},{"name":"DDL","slug":"DDL","permalink":"http://beautifulboyy/tags/DDL/"},{"name":"DML","slug":"DML","permalink":"http://beautifulboyy/tags/DML/"},{"name":"DQL","slug":"DQL","permalink":"http://beautifulboyy/tags/DQL/"},{"name":"注解","slug":"注解","permalink":"http://beautifulboyy/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"面试题","slug":"面试题","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"反射","slug":"反射","permalink":"http://beautifulboyy/tags/%E5%8F%8D%E5%B0%84/"},{"name":"枚举","slug":"枚举","permalink":"http://beautifulboyy/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"进程","slug":"进程","permalink":"http://beautifulboyy/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"http://beautifulboyy/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"泛型","slug":"泛型","permalink":"http://beautifulboyy/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"IO流","slug":"IO流","permalink":"http://beautifulboyy/tags/IO%E6%B5%81/"},{"name":"序列化","slug":"序列化","permalink":"http://beautifulboyy/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"异常","slug":"异常","permalink":"http://beautifulboyy/tags/%E5%BC%82%E5%B8%B8/"},{"name":"DateFormat","slug":"DateFormat","permalink":"http://beautifulboyy/tags/DateFormat/"},{"name":"BigDecimal","slug":"BigDecimal","permalink":"http://beautifulboyy/tags/BigDecimal/"},{"name":"BigInteger","slug":"BigInteger","permalink":"http://beautifulboyy/tags/BigInteger/"},{"name":"内部类","slug":"内部类","permalink":"http://beautifulboyy/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"UML","slug":"UML","permalink":"http://beautifulboyy/tags/UML/"},{"name":"static","slug":"static","permalink":"http://beautifulboyy/tags/static/"},{"name":"字符串","slug":"字符串","permalink":"http://beautifulboyy/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"java","slug":"java","permalink":"http://beautifulboyy/tags/java/"},{"name":"集合框架","slug":"集合框架","permalink":"http://beautifulboyy/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://beautifulboyy/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Integer","slug":"Integer","permalink":"http://beautifulboyy/tags/Integer/"},{"name":"深拷贝浅拷贝","slug":"深拷贝浅拷贝","permalink":"http://beautifulboyy/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"Date","slug":"Date","permalink":"http://beautifulboyy/tags/Date/"},{"name":"Calendar","slug":"Calendar","permalink":"http://beautifulboyy/tags/Calendar/"},{"name":"抽象类","slug":"抽象类","permalink":"http://beautifulboyy/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"name":"接口","slug":"接口","permalink":"http://beautifulboyy/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"面向对象","slug":"面向对象","permalink":"http://beautifulboyy/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Scanner","slug":"Scanner","permalink":"http://beautifulboyy/tags/Scanner/"},{"name":"变量","slug":"变量","permalink":"http://beautifulboyy/tags/%E5%8F%98%E9%87%8F/"},{"name":"方法","slug":"方法","permalink":"http://beautifulboyy/tags/%E6%96%B9%E6%B3%95/"},{"name":"循环语句","slug":"循环语句","permalink":"http://beautifulboyy/tags/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"},{"name":"数组","slug":"数组","permalink":"http://beautifulboyy/tags/%E6%95%B0%E7%BB%84/"},{"name":"hexo","slug":"hexo","permalink":"http://beautifulboyy/tags/hexo/"}]}